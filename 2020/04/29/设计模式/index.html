<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>设计模式 | MRZ de 博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="设计模式  设计模式 策略模式  动机：  策略模式定义了一系列的方法并进行封装，使他们可以相互转换。策略允许算法独立于使用它的客户机而变化。 由客户端决定什么情况下使用具体策略角色（与状态模式的区别）    结构：      优缺点：  优点：  对“开闭”的完美支持 避免使用多重条件转移语句    缺点：  造成多种策略类       适用：  许多相关的类只在它们的行为上有所不同。策">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://yoursite.com/2020/04/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="MRZ de 博客">
<meta property="og:description" content="设计模式  设计模式 策略模式  动机：  策略模式定义了一系列的方法并进行封装，使他们可以相互转换。策略允许算法独立于使用它的客户机而变化。 由客户端决定什么情况下使用具体策略角色（与状态模式的区别）    结构：      优缺点：  优点：  对“开闭”的完美支持 避免使用多重条件转移语句    缺点：  造成多种策略类       适用：  许多相关的类只在它们的行为上有所不同。策">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205190915875.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205192818337.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205210217187.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205210436672.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205210700731.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205200021777.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205200119393.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205200832402.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205201730783.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205203139211.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205203633222.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205204108256.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205204534262.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205204729484.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205205213653.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205213115381.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205205602904.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205220754959.png">
<meta property="og:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205215230419.png">
<meta property="article:published_time" content="2020-04-29T15:46:03.271Z">
<meta property="article:modified_time" content="2020-04-29T15:46:22.654Z">
<meta property="article:author" content="MRZ">
<meta property="article:tag" content="程序员，工程师，南京大学，java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/南大宋仲基/AppData/Roaming/Typora/typora-user-images/image-20191205190915875.png">
  
    <link rel="alternate" href="/atom.xml" title="MRZ de 博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MRZ de 博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">write something to the future!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-04-29T15:46:03.271Z" itemprop="datePublished">2020-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      设计模式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>设计模式</title><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="MRZ de 博客" type="application/atom+xml">
</head>
<body><h2>设计模式</h2>
<h4>策略模式</h4>
<ul>
<li><p>动机：</p>
<ul>
<li>策略模式定义了一系列的方法并进行封装，使他们可以相互转换。策略允许算法独立于使用它的客户机而变化。</li>
<li>由客户端决定什么情况下使用具体策略角色（与状态模式的区别）</li>

</ul>
</li>
<li><p>结构：</p>
<ul>
<li><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205190915875.png" alt="image-20191205190915875" style="zoom:50%;" /></li>

</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>对“开闭”的完美支持</li>
<li>避免使用多重条件转移语句</li>

</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>造成多种策略类</li>

</ul>
</li>

</ul>
</li>
<li><p>适用：</p>
<ul>
<li>许多相关的类只在它们的行为上有所不同。策略提供了一种用许多行为之一来配置类的方法。你需要不同的算法。</li>
<li>当这些变量被实现为算法的一个类层次结构时，可以使用策略[HO87]。算法使用客户不应该知道的数据。使用策略模式来避免暴露复杂的、特定于算法的数据结构。</li>
<li>类定义了许多行为，这些行为在其操作中表现为多个条件语句。不要使用许多条件句，而是将相关的条件分支移到它们自己的策略类中。</li>

</ul>
</li>
<li><p>与状态模式的区别：</p>
<ul>
<li><p>是否对客户透明</p>
</li>
<li><p>策略模式允许客户根据环境或条件的不同，选择不同的具体策略来完成任务。</p>
<p>即状态模式中的状态转换对于用户是透明的，用户不需要关心对象的具体状态，也不需要关心状态是如何完成转换的。状态模式封装了当前的状态以及状态转换的行为。</p>
<p>而策略模式仅仅封装了算法，提供新算法插入到已有系统中，以及老算法从系统中退休的方便。模式本身不决定何时何地试用何种算法，算法的选择由客户端决定，因此策略模式中客户端必须明确指定试用何种具体策略，也就是策略不能对客户端透明。</p>
</li>

</ul>
</li>

</ul>
<p>&nbsp;</p>
<hr />
<h4>观察者模式</h4>
<ul>
<li><p>模式动机：</p>
<ul>
<li>建立对象与对象之间的依赖关系，一个对象发生改变时自动通知其他对象，其他对象将相应做出反应。一个观察目标可以对应多个观察者，可以根据需要增加和删除观察者，使得系统易于扩展</li>

</ul>
</li>
<li><p>结构：</p>
<ul>
<li><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205192818337.png" alt="image-20191205192818337" style="zoom:50%;" /></li>
<li>Subject 里面有多个observers</li>
<li>concreteobsever 对 c subject 进行订阅</li>

</ul>
</li>
<li><p>使用环境</p>
<ul>
<li>一个方面依赖另一个方面 ，将这些方面封装在独立对象</li>
<li>一个对象改变将导致其他对象改变，不知道具体有多少对象改变</li>
<li>一个对象必须统治其他对象，且不知道这些对象是谁</li>
<li>需要在系统中创建一个触发链——<strong>创建链式触发机制</strong></li>

</ul>
</li>
<li><p>优缺点</p>
<ul>
<li><p>优点：</p>
<ul>
<li>符合“开闭原则”——观察者的增加和删除，主题的增加和删除</li>
<li>实现表示层和数据逻辑层分离</li>
<li>支持广播通信</li>

</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>将所有观察者通知会花费很多时间</li>
<li>若观察者与目标产生循环依赖的话，可能导致系统崩溃   </li>
<li>没有相应机制让观察者知道目标是怎么变化的，只是知道目标发生变化了而已</li>

</ul>
</li>

</ul>
</li>
<li><p>组合-迭代器的方式通知观察者：复合模式中有</p>
</li>
<li><h4>待解决</h4>
</li>
<li><p>java中的观察者具体采用了哪些选择策略（推/拉/内部/外部）、原因（优缺点、JAVA语言本身的限制）</p>
<ul>
<li><p>考试内容：</p>
<p>内部和外部实现的问题，pattern in the pattern，如何判断内部和外部实现，观察观察者的位置。内部和外部的好处和缺点，对update的方法，谁去发起update的方法</p>
<p>观察者怎么用，如何与其他模式联用，如MVC这样的情况（不会用MVC的例子），观察者的实现细节：推和拉，谁是Update的发起者，哪里存储这些。</p>
</li>

</ul>
</li>

</ul>
<p>&nbsp;</p>
<hr />
<h4>工厂模式</h4>
<p>&nbsp;</p>
<h4>简单工厂模式</h4>
<ul>
<li>简单工厂模式(Simple Factory Pattern)：。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</li>

</ul>
<p><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205210217187.png" referrerpolicy="no-referrer" alt="image-20191205210217187"></p>
<ul>
<li><p>分析</p>
<ul>
<li><p>简单工厂模式最大的问题在于</p>
<ul>
<li>工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，</li>
<li>这一点与开闭原则是相违背的。</li>

</ul>
</li>
<li><p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节</p>
</li>

</ul>
</li>
<li><p>优点</p>
<ul>
<li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；</li>
<li>简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li>

</ul>
</li>
<li><p>缺点</p>
<ul>
<li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li>
<li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li>
<li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>

</ul>
</li>
<li><p>适用情况</p>
<ul>
<li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li>

</ul>
<p>&nbsp;</p>
</li>

</ul>
<h4>工厂方法</h4>
<ul>
<li>工厂方法模式(Factory Method Pattern)又称为工厂模式，在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</li>

</ul>
<p><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205210436672.png" referrerpolicy="no-referrer" alt="image-20191205210436672"></p>
<ul>
<li><p>分析</p>
<ul>
<li>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</li>

</ul>
</li>
<li><p>优点</p>
<ul>
<li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li>
<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li>
<li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li>

</ul>
</li>
<li><p>缺点</p>
<ul>
<li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li>

</ul>
</li>

</ul>
<p>&nbsp;</p>
<ul>
<li><p>适用情况</p>
<ul>
<li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li>
<li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
<li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中</li>

</ul>
</li>

</ul>
<p>&nbsp;</p>
<h4>抽象工厂模式</h4>
<ul>
<li><p>动机</p>
<ul>
<li>生产出的商品不是一个简单的对象，而是多种不同产品</li>
<li>工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构</li>

</ul>
</li>
<li><p>定义</p>
<ul>
<li>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。
<img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205210700731.png" referrerpolicy="no-referrer" alt="image-20191205210700731"></li>

</ul>
</li>
<li><p>优点</p>
<ul>
<li>符合开闭原则</li>

</ul>
</li>
<li><p>缺点</p>
<ul>
<li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</li>
<li>开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）</li>

</ul>
</li>
<li><p>使用环境</p>
<ul>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>

</ul>
</li>

</ul>
<p>工厂模式的退化</p>
<ul>
<li>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；</li>
<li>当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</li>

</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<h4>命令模式</h4>
<ul>
<li><p>动机：请求发送者与请求接收者解耦。客户端只需在程序运行时指定具体的请求接收者</p>
</li>
<li><p>定义：将请求封装为一个对象，用不用的请求对客户进行参数化（支持undo，宏）</p>
</li>
<li><p>结构：</p>
<ul>
<li><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205200021777.png" alt="image-20191205200021777" style="zoom:50%;" /></li>
<li><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205200119393.png" alt="image-20191205200119393" style="zoom:50%;" /></li>

</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li>优点：降低耦合，符合开闭</li>
<li>缺点： pass</li>

</ul>
</li>
<li><p>适用环境：</p>
<ul>
<li>需要将请求调用者和请求接受者解耦</li>
<li>需要对不同的时间指定请求，将请求排队和执行请求</li>
<li>需要支持命令撤销和恢复操作</li>
<li>需要将一组操作组合在一起，即支持宏命令（数组来实现：组合）</li>

</ul>
</li>
<li><p>宏命令（MacroCommand）：配合组合模式</p>
<ul>
<li><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205200832402.png" referrerpolicy="no-referrer" alt="image-20191205200832402">  </li>

</ul>
</li>

</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h4> </h4>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<h4>模板方法模式</h4>
<ul>
<li><p>动机：基于继承的代码复用，将相同的代码放到父类，不同的方法实现放在子类中（典型的抽象类）</p>
</li>
<li><p>定义：定义算法的骨架，将一些步骤延迟到子类。不改变一个算法的结构即可重定义算法的某些步骤</p>
</li>
<li><p>结构：</p>
<ul>
<li><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205201730783.png" alt="image-20191205201730783" style="zoom:50%;" /></li>

</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li><p>优点：</p>
<ul>
<li><p>由子类实现细节处理</p>
</li>
<li><p>由父类实现算法骨架</p>
</li>
<li><p>反向控制结构——通过钩子方法（isPrint()）实现，子类可以通过重写</p>
<ul>
<li>父类定义一下空的方法，子类去实现</li>

</ul>
</li>
<li><p>符合开闭原则</p>
</li>

</ul>
</li>
<li><p>缺点：类的增加</p>
</li>

</ul>
</li>
<li><p>子类不显式调用父类的方法，而是通过覆盖父类的方法来实现某些具体的业务逻辑，<strong>父类控制对子类的调用。</strong></p>
</li>
<li><p>使用环境：</p>
<ul>
<li><p>    i.一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</p>
<p>    ii.各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。</p>
<p>   iii.对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可             以改变的细节由其子类来实现。</p>
<p>   iv.控制子类的扩展。</p>
</li>

</ul>
</li>

</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<h4>状态模式</h4>
<ul>
<li><p>动机：</p>
<ul>
<li>一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态</li>

</ul>
</li>
<li><p>定义：</p>
<ul>
<li>对象行为模式，允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类</li>

</ul>
</li>
<li><p>结构</p>
<ul>
<li><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205203139211.png" referrerpolicy="no-referrer" alt="image-20191205203139211"></li>

</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li><p>优点： 封装了转换规则 枚举可能的状态 可以方便的增加新状态</p>
<p>            允许转态转换逻辑与状态对象合成一体</p>
<p>            让多个环境对象共享一个组状态对象从而减少系统中对象的个数</p>
</li>
<li><p>缺点：不符合开闭，增加了类</p>
</li>

</ul>
</li>
<li><p>使用环境</p>
<ul>
<li><p>对象的行为依赖于它的状态，并且可以根据她的状态改变她的相关行为</p>
<p>包含大量与对象状态有关的条件语句</p>
</li>

</ul>
</li>

</ul>
<p>&nbsp;</p>
<hr />
<h4>外观模式</h4>
<ul>
<li><p>动机</p>
<ul>
<li>引入外观角色后，用户只需要直接与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现，降低了系统的耦合度。</li>

</ul>
</li>
<li><p>结构：</p>
<ul>
<li><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205203633222.png" referrerpolicy="no-referrer" alt="image-20191205203633222"></li>
<li>单一职责：系统划分为多个子系统有利于降低系统的复杂性。外观模式中，将系统划分出多个子系统，使他们之间通信和相互依赖关系达到最小。外观对象为子系统的访问提供了一个简单又单一的入口</li>
<li>迪米特原则：通过引入外观类，降低了原有系统的复杂度，<strong>同时降低客户端与子系统类的耦合度。即客户端只需要与外观对象打交道，无需了解子系统内部的细节，不需要与子系统内部的若干对象打交道。</strong></li>

</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li><p>优点：<strong>对客户屏蔽子系统组件，客户处理对象数目减少，使得子系统使用起来更加容易</strong></p>
<p><strong>实现了子系统与客户之间的松耦合。子系统的组件变化不会影响客户类，只需调整外观类。</strong></p>
<p><strong>降低编译依赖性，简化系统的移植过程。可以独立地编译子系统。</strong></p>
<p><strong>不影响用户直接使用子系统类。</strong></p>
</li>
<li><p>缺点：<strong>不能很好地限制客户使用子系统类</strong></p>
<p><strong>违背了*</strong>*“<strong></strong>开闭原则<strong></strong>”<strong></strong>，不引入抽象外观类的情况下，添加子系统可能要修改外观类。**</p>
</li>

</ul>
</li>
<li><p>适用环境：</p>
<ul>
<li>为一个复杂系统提供一个简单接口时</li>
<li>客户程序与多个子系统之间存在很大的依赖性</li>
<li>层次化的结构中使用外观模式，使用外观模式定义每层的入口，层与层之间不直接产生联系，通过外观类建立联系，降低层间耦合度</li>

</ul>
</li>
<li><p>不要试图通过外观类为子系统增加新行为</p>
</li>
<li><p><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205204108256.png" referrerpolicy="no-referrer" alt="image-20191205204108256"></p>
</li>

</ul>
<p>&nbsp;</p>
<hr />
<h4>代理模式</h4>
<ul>
<li><p>动机：代理对象在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者客户需要的额外服务</p>
</li>
<li><p>定义：通过引入代理对象来间接访问一个对象，由代理对象控制对原对象的引用</p>
</li>
<li><p>结构</p>
<ul>
<li><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205204534262.png" referrerpolicy="no-referrer" alt="image-20191205204534262"></li>

</ul>
</li>
<li><p>远程代理，虚拟代理</p>
<ul>
<li>虚拟代理： 小对象代表大对象，减少系统资源的消耗，对系统优化并提高响应速度。真正的大对象在需要时才会被真正创建</li>
<li><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205204729484.png" referrerpolicy="no-referrer" alt="image-20191205204729484"></li>

</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li>优点：协调调用者和被调用者，降低耦合度</li>
<li>缺点：复杂性。可能造成请求的处理速度变慢</li>

</ul>
</li>

</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<h4>单例模式</h4>
<ul>
<li><p>动机 </p>
<ul>
<li>只有一个实例比较重要</li>

</ul>
</li>
<li><p>定义</p>
<ul>
<li>单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</li>

</ul>
</li>
<li><ul>
<li><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205205213653.png" alt="image-20191205205213653" style="zoom:80%;" /></li>
<li><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205213115381.png" alt=" image-20191205213115381" style="zoom:80%;" /></li>

</ul>
</li>

</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<h4>适配器模式</h4>
<blockquote><p>将一个类的接口转换为客户期望的另一个接口。让原本不兼容的类可以合作无间</p>
</blockquote>
<ul>
<li><p>动机</p>
<ul>
<li>现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用</li>
<li>当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。</li>

</ul>
</li>
<li><p>定义</p>
<ul>
<li>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式</li>

</ul>
</li>
<li><p>结构：</p>
<ul>
<li><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205205602904.png" alt="image-20191205205602904" style="zoom:80%;" /></li>

</ul>
</li>
<li><p>适配器类持有新的引用，再把适配器放入旧的里面</p>
</li>
<li><p>优点</p>
<ul>
<li>引入一个适配器类来重用现有的适配者类，而无须修改原有代码</li>
<li>开闭原则</li>
<li>提高了适配者的复用性</li>

</ul>
</li>

</ul>
<p>&nbsp;</p>
<hr />
<h4>迭代器模式</h4>
<ul>
<li>定义 ： 提供一个方法顺序的访问一个聚合对象的各个元素，而又不暴露其内部的表示</li>

</ul>
<p>&nbsp;</p>
<hr />
<h4>组合模式</h4>
<ul>
<li>组合（Composite）模式的定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</li>
<li>组合模式的主要优点有：</li>

</ul>
<ol start='' >
<li><ul>
<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li>

</ul>
</li>
<li><ul>
<li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<p><img src=" C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205220754959.png" alt="image-20191205220754959" style="zoom:50%;" /></p>
<ul>
<li>树枝构件对接口持有引用</li>
<li>主要缺点是：</li>

</ul>
<ol start='' >
<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li>
<li>不容易限制容器中的构件；</li>
<li>不容易用继承的方法来增加构件的新功能；</li>

</ol>
<hr />
<h4>装饰模式</h4>
<ul>
<li><p>动机</p>
<ul>
<li>装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是装饰模式的模式动机</li>

</ul>
</li>
<li><p>定义</p>
<ul>
<li>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活</li>

</ul>
</li>

</ul>
<p><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191205215230419.png" referrerpolicy="no-referrer" alt="image-20191205215230419"></p>
<ul>
<li><p>装饰者不仅仅继承上级 更是拥有上级的引用</p>
</li>
<li><p>分析</p>
<ul>
<li>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，关联关系的缺点是比继承关系要创建更多的对象</li>

</ul>
</li>
<li><p>优点 </p>
<ul>
<li>装饰模式更加的灵活</li>
<li>动态的扩展</li>
<li>可以多个具体装饰类装饰同一对象</li>
<li>开闭原则，构建类与装饰类可以独立变化，随意组合</li>

</ul>
</li>
<li><p>缺点</p>
<ul>
<li>容易出错，排查麻烦</li>

</ul>
</li>
<li><p>使用环境</p>
<ul>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
<li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li>
<li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）</li>

</ul>
</li>

</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>
</html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="ck9lijala000aqova4kk8hqg4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/04/29/%E7%BD%91%E7%BB%9C/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">网络</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/2020/04/29/%E7%BD%91%E7%BB%9C/">网络</a>
          </li>
        
          <li>
            <a href="/2020/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91/">高并发</a>
          </li>
        
          <li>
            <a href="/2020/04/29/Mysql%E9%9D%A2%E8%AF%95/">Mysql面试</a>
          </li>
        
          <li>
            <a href="/2020/04/29/java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89/">java常用集合（重点）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 MRZ<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="MRZ的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="MRZ的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="MRZ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>MRZ的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MRZ的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">something need to do!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">7</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MRZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MRZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/26/%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91/" class="post-title-link" itemprop="url">英语翻译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-26 14:54:40" itemprop="dateCreated datePublished" datetime="2020-03-26T14:54:40+08:00">2020-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-14 23:35:53" itemprop="dateModified" datetime="2019-12-14T23:35:53+08:00">2019-12-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="英语翻译"><a href="#英语翻译" class="headerlink" title="英语翻译"></a>英语翻译</h2><p>翻译句子主要三种：简单句，并列句，复合句</p>
<ul>
<li>简单句：干掉修饰语，翻译主谓宾，然后修饰语一层一层的往上加<ul>
<li>简单句只有中心句+修饰语</li>
<li><strong>I will love  you</strong> ==for the rest of my life==</li>
</ul>
</li>
<li>并列句：找到并列连词，前一句简单句，后一句简单词，逐句翻译</li>
<li>复合句：找到关联词，劈开，先找主干：先主谓宾，再加修饰语，最后翻译从句<ul>
<li>从句主要有两大种：定语从句，同位语从句，其他从句均可视为修饰语<ul>
<li>关联词删除，==判断从句是否缺成分==（也就是是不是完整的一句话），缺的话就是定语，否则为同位语</li>
</ul>
</li>
<li>对于复合句而言，只要翻译对了主干就可以得到一部分的分</li>
</ul>
</li>
<li>关联词：<strong>关联词划分主，从句</strong><ul>
<li>that   which  ：定语，同位语从句</li>
<li>when why where who ：引导时间，原因，地点状语从句</li>
<li>and  while  but: 一般表示并列结构</li>
</ul>
</li>
</ul>
<p>翻译：完整，准确，通顺</p>
<ul>
<li><p>完整：简单句翻译主谓宾，并列句翻译每个句子的主谓宾，复合句翻译主干句</p>
</li>
<li><p>准确：单词句子翻译准确，无错误</p>
</li>
<li><p>通顺：语句通顺，符合中文阅读习惯</p>
</li>
<li><p>英文的嵌套思维转为中文思维</p>
</li>
</ul>
<p>下面举一个同位语的栗子</p>
<p>例句：But even as the number of English speakers expands further ,there are signs that the  predominance of the language may fade within the foreseeable future.</p>
<ul>
<li>逗号分隔的两个并列句，分别翻译</li>
<li>But even as the number of English speakers expands further <ul>
<li>as 和 with 一样 ，可以翻译为  随着。。。</li>
<li>但是，即使随着说英语的人数进一步增加</li>
</ul>
</li>
<li>there are signs ==that== the  predominance of the language may fade within the foreseeable future.<ul>
<li>去掉that后，从句仍然为一个独立的句子，所以为同位语</li>
<li>同位语的作用是为了对前文的补充说明的作用，所以翻译时“迹象表明：…”或者“迹象表明—”</li>
<li>先翻译前面：there are signs ：有迹象表明，该语言的优势在可预见的将来可能会消失。</li>
<li>再翻译后面： the  predominance of the language may fade within the foreseeable future.<ul>
<li><strong>the</strong>  predominance <strong>of</strong> the language ：<strong>a of b：这种类型 :翻译为：b的a</strong><ul>
<li>语言的优势</li>
</ul>
</li>
<li>句子比较简单：该语言的优势在可预见的将来可能会消失</li>
</ul>
</li>
<li>综合：迹象表明：该语言的优势在可预见的将来可能会消失。</li>
</ul>
</li>
<li>全句：但是，即使随着说英语的人数进一步增加，有迹象表明：该语言的优势在可预见的将来可能会消失。</li>
</ul>
<p>例句：Chomsky`s grammar should show pattens of language change <strong>that</strong> are indepent of the family tree.</p>
<ul>
<li>注意到这里的that引导的是定语从句（从句非完整的话），定语从句翻译时，从句要加主语：一般为:它，这</li>
<li>先翻译主句：Chomsky`s grammar should show pattens of language change<ul>
<li>乔姆斯基的语法应该显示了语言变化模式。</li>
</ul>
</li>
<li>从句，that翻译为 ：这  ：这独立于家谱</li>
<li>整合：乔姆斯基的语法应该显示了语言变化模式，这种模式独立于家谱</li>
<li>更好的翻译：乔姆斯基的语法应该显示独立于家谱的语言变化模式。</li>
</ul>
<p>例句：the virgin forest with its richness ==and== variety of trees was a real treasure-house ==which== extended from Maine all the way down to Georgia.</p>
<p>解析：</p>
<ul>
<li>这是一个复合句：which引导的定于从句</li>
<li>找主句：the virgin forest with its richness and variety of trees was a real treasure-house<ul>
<li>主句中的主谓宾：the virgin forest was a real treasure-house ：原始森林是一个真正的宝库</li>
<li>加修饰语：with its richness and variety of trees：丰富多样的树木</li>
<li>结合：拥有丰富且多样树木的原始森林是一个真正的宝库</li>
</ul>
</li>
<li>从句：which extended from <strong>Maine</strong> all the way down to <strong>Georgia</strong>.（大写的单词通常为人名，地名）<ul>
<li>which引导定语从句，这里直接翻译为  它</li>
<li>从缅因州一直延伸到佐治亚州</li>
</ul>
</li>
<li>整合：拥有丰富且多样树木的原始森林是一个真正的宝库，它从缅因州一直延伸到佐治亚州</li>
<li>注：这里的and前后为两个单词，并不构成句子</li>
</ul>
<hr>
<h4 id="英语二真题"><a href="#英语二真题" class="headerlink" title="英语二真题"></a>英语二真题</h4><ol start="19">
<li>It is easy to underestimate English writer James Herriot. He had such a pleasant, readable style that are might think that anyone could imitate it. How many times have I heard people say, “I could write a book, I just haven’t the time” Easily said. Not so easily done. James Herriot, contrary to popular opinion did not find it easy in his early days of, as he put it, “having a go at the writing game”. While he obviously had an abundance of natural talent, the final polished work that he have to the world was the result of years of practicing, re-writing and reading. Like the majority of authors, he had to suffer many disappointments and rejections along the way, but these made him all the more determined to succeed. Everything he achieved in life was earned the hard way and his success in the literacy field was no exception.</li>
</ol>
<ul>
<li>It is easy to underestimate English writer James Herriot. <ul>
<li>it is 。。。形式主语：这是很容易去低估英国作家家詹姆斯·赫里欧</li>
<li>形式主语在中文中是没有的，可以翻译为：詹姆斯·赫里欧是一位很容易让人低估的英国作家</li>
</ul>
</li>
<li>He had such a pleasant, readable style <strong>that</strong> are might think that anyone could imitate it.<ul>
<li>找到that将句子切开，这里是定语从句</li>
<li>他的作品有一种令人愉快、易读的风格，这种风格可能就让人以为任何人都能模仿他</li>
</ul>
</li>
<li>How many times have I heard people say     ,    “I could write a book, I just haven’t the time”<ul>
<li>逗号切开</li>
<li>How many times have I heard people say：我很多次（总是）听人说，</li>
<li>“I could write a book, I just haven’t the time” ：我也可以写书，也是没有时间</li>
</ul>
</li>
<li>Easily said. Not so easily done：容易说，但不容易做</li>
<li>James Herriot, <strong>contrary to popular opinion did not find it easy in his early days of,</strong> <strong>as he put it</strong>, “having a go at the writing game”. <ul>
<li>这种是属于插入语，在阅读理解中，逗号里面的句子都可以不用看：补充说明的作用，这里同样先跳过</li>
<li>James Herriot,as he put it, “having a go at the writing game”. ：詹姆斯·赫里欧，用他的话说，“在写作游戏中尝试”</li>
<li><strong>contrary to popular opinion did not find it easy in his early days of</strong> <ul>
<li><strong>contrary to popular opinion</strong> 与流行的观点相悖</li>
<li>did not find it easy in his early days of <ul>
<li>这句话少了主语，少了宾语</li>
<li>主语是James Herriot，宾语为“having a go at the writing game”</li>
<li>结合就是James Herriot did not find it easy <strong>in his early days</strong> of “having a go at the writing game”  ：詹姆斯·赫里欧在他早期，发现“在写作游戏中尝试”并不容易</li>
</ul>
</li>
</ul>
</li>
<li>整合：与大众的观点相反，詹姆斯·赫里欧在他早期发现，用他的话说，“在写作游戏中尝试”并不容易。</li>
</ul>
</li>
<li>While he obviously had an abundance of natural talent, the final polished work that he have to the world was the result of years of practicing, re-writing and reading.<ul>
<li>while 引导并列，前后两个句子分别翻译（while引导的是转折）</li>
<li>While he obviously had an abundance of natural talent：他显然极具天赋</li>
<li>the final polished work <strong>that</strong> he have to the world <strong>was</strong> the result of years of practicing, re-writing and reading<ul>
<li>that引导的定语从句，was谓语，切成三分</li>
<li>主：the final polished work，谓:was,宾：the result of years of practicing, re-writing and reading（a of b）：b的a   ：… 的结果 <ul>
<li>翻译：他最终出版的作品是多年练习、重写和阅读的结果</li>
</ul>
</li>
<li>最后加上修饰语（定语从句）： <strong>that</strong> he have to the world缺少的主语是出版的作品</li>
</ul>
</li>
<li>整合：但他留给世人的最终出版作品却是多年练习、重写和阅读的结果</li>
</ul>
</li>
<li>Like the majority of authors, he had to suffer many disappointments and rejections along the way, <strong>but</strong> these made him all the more determined to succeed<ul>
<li>并列的简单句，分别翻译</li>
<li>Like the majority of authors, he had to suffer many disappointments and rejections along the way,<ul>
<li>和大多数作家一样，他在写作过程中也遭受了许多失望和拒绝</li>
</ul>
</li>
<li><strong>but</strong> these made him all the more determined to succeed：但这些都使他更加坚定了成功的决心</li>
</ul>
</li>
<li>Everything he achieved in life <strong>was</strong> earned the hard way <strong>and</strong> his success in the literacy field <strong>was</strong> no exception.<ul>
<li>and引导的并列句，分别翻译</li>
<li>Everything he achieved in life <strong>was</strong> earned the hard way ：<ul>
<li>Everything he achieved in life 其实也是定语从句这里只是省略了that，因为句子过于简单</li>
<li>直译：他人生中取得的一切都是以一种困难的方式获得</li>
<li>意译：他人生中所取得的一切成就都是来之不易的</li>
</ul>
</li>
<li>his success in the literacy field <strong>was</strong> no exception：他在文学领域的成功也不例外</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MRZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MRZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/26/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/" class="post-title-link" itemprop="url">算法作业</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-26 14:54:23" itemprop="dateCreated datePublished" datetime="2020-03-26T14:54:23+08:00">2020-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-28 23:13:45" itemprop="dateModified" datetime="2019-12-28T23:13:45+08:00">2019-12-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="算法作业"><a href="#算法作业" class="headerlink" title="算法作业"></a>算法作业</h2><h4 id="解决方案的整体描述"><a href="#解决方案的整体描述" class="headerlink" title="解决方案的整体描述"></a>解决方案的整体描述</h4><ul>
<li>库所(Place)、变迁(Transition)、弧线(Arc)创建统一的节点类：id ， name ， token等</li>
<li>实现接口方法<ul>
<li>导入jdom工具包，用于解析xml文件</li>
<li>遍历xml文件，提取出库所(Place)、变迁(Transition)、弧线(Arc)中的信息依次封装入节点对象</li>
<li>确定输入库所，输出库所</li>
<li>使用数组来存放每个节的令牌信息</li>
<li>从输入库所开始使用广度优先遍历<ul>
<li>如果是库所：确定其相邻的变迁是否可达，可达的话递归遍历该变迁</li>
<li>如果是变迁：确定其是否被重复遍历，最多只能遍历二次，前库所相应令牌减一，后库所加一，再依次对后库所进行递归</li>
</ul>
</li>
<li>对结果写入到文件中</li>
</ul>
</li>
</ul>
<h4 id="整体解决方案的伪代码"><a href="#整体解决方案的伪代码" class="headerlink" title="整体解决方案的伪代码"></a>整体解决方案的伪代码</h4><ul>
<li><pre><code class="伪代码">类 node{
    id  name  token
    出节点列表  入节点列表
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
 getLogOfModel(String modelFile, String logFile) 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
placeChildren = xml解析出的place集合
transitionChildren = xml解析出的transition
ArcChildren = xml解析出的Arc集合
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
for _ in xml解析出的place集合
    Node node = new Node(id name tocken)
for _ in xml解析出的transition集合
    Node node = new Node(id name tocken)
for _ in xml解析出的Arc集合
    出节点，入节点
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
BFS:
    if 是库所：
  for next in 所有相邻的变迁
        for (Node pre : next.in)
                    if (toKen[pre]] &lt;= 0)
                        该next变得不可达;
        if next 可达：
            加入遍历队列
           for i in 遍历队列:
               remove(i)
               递归bfs
else 为变迁：
    if 变迁访问了三次：
        则该路不通
    for (Node preNode : cur.in)：//遍历其前节点
        tocken[prenode]-=1
    for (Node nextNode : cur.out)：//遍历其后节点
        tocken[nextnode]+=1
        if nextnode == end：
            return
    curBFSNode.addAll(cur.out);
    for (Node next : curBFSNode) ：
        remove(next)
        BFS递归
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">-</span><br></pre></td></tr></table></figure>
writeTxt(logFile, string) // 写入文件中
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 解决方案各个模块的描述</span><br><span class="line"></span><br><span class="line">- 创建类的节点</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
  类 node{ 
      id  name  token
      isplace //是否为库所
      出节点列表  入节点列表
  }
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 引用第三方解析xml库</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
  //1.创建SAXBuilder对象
  SAXBuilder saxBuilder = new SAXBuilder();
  //2.加载文件流
  Document document = saxBuilder.build(new FileInputStream(new File(modelFile));
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 解析xml</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
  for _ in xml解析出的place集合
      Node node = new Node(id name tocken)
      map.put(id,node)
  for _ in xml解析出的transition集合
      Node node = new Node(id name tocken)
      map.put(id,node)
  for _ in xml解析出的Arc集合
      //设置出节点，入节点
      arc(2).innode.(arc(1))
      arc(1).outnode.add(arc(2))
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 确定输入，输出库所</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
  for node in map.values:
      if node.isplace == true &amp;&amp; node.innode.size==0&amp;&amp;node.outnode&gt;0:
          输入库所
      else if (node.isPlace==true &amp;&amp; node.inNode.size&gt;0 &amp;&amp; node.outNode.size 、== 0)
          输出库所
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- BFS</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
  if 是库所：
      for next in 所有相邻的变迁
          for (Node pre : next.in)
                      if (toKen[pre]] &lt;= 0)
                          该next变得不可达;
          if next 可达：
              加入遍历队列
             for i in 遍历队列:
                 remove(i)
                 递归bfs
  else 为变迁：
      if 变迁访问了三次：
          则该路不通
      for (Node preNode : cur.in)：//遍历其前节点
          tocken[prenode]-=1
      for (Node nextNode : cur.out)：//遍历其后节点
          tocken[nextnode]+=1
          if nextnode == end：
              return
      curBFSNode.addAll(cur.out);
      for (Node next : curBFSNode) ：
          remove(next)
          BFS递归
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 写入文件</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
      if (file.exists()) {
          file.createNewFile();
          }
        fileOutputStream = new FileOutputStream(file);
        fileOutputStream.write(content.getBytes());
        fileOutputStream.flush();
        fileOutputStream.close();</code></pre>
</li>
</ul>
<h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><ul>
<li>第一个</li>
</ul>
<p><img src="C:%5CUsers%5C%E5%8D%97%E5%A4%A7%E5%AE%8B%E4%BB%B2%E5%9F%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191228230942308.png" alt="image-20191228230942308"></p>
<ul>
<li><p>结果</p>
<ul>
<li><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191228231001428.png" alt="image-20191228231001428" style="zoom:100%;" />
</li>
</ul>
</li>
<li><p>第二个</p>
</li>
</ul>
<p><img src="C:%5CUsers%5C%E5%8D%97%E5%A4%A7%E5%AE%8B%E4%BB%B2%E5%9F%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191228231331612.png" alt="image-20191228231331612"></p>
<ul>
<li>结果<ul>
<li><img src="C:%5CUsers%5C%E5%8D%97%E5%A4%A7%E5%AE%8B%E4%BB%B2%E5%9F%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191228231307718.png" alt="image-20191228231307718"></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/javase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MRZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MRZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/26/javase/" class="post-title-link" itemprop="url">javase</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-26 14:54:07" itemprop="dateCreated datePublished" datetime="2020-03-26T14:54:07+08:00">2020-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-01 17:40:26" itemprop="dateModified" datetime="2020-01-01T17:40:26+08:00">2020-01-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="javase"><a href="#javase" class="headerlink" title="javase"></a>javase</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>1.jdk与jre</p>
<ul>
<li>JDK：Java Development Kit</li>
<li>JRE：Java Runtime Environment</li>
</ul>
<p>简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ┌─    ┌──────────────────────────────────┐</span><br><span class="line"> │     │     Compiler, debugger, etc.     │</span><br><span class="line"> │     └──────────────────────────────────┘</span><br><span class="line">JDK ┌─ ┌──────────────────────────────────┐</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> │ JRE │      JVM + Runtime Library       │</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> └─ └─ └──────────────────────────────────┘</span><br><span class="line">       ┌───────┐┌───────┐┌───────┐┌───────┐</span><br><span class="line">       │Windows││ Linux ││ macOS ││others │</span><br><span class="line">       └───────┘└───────┘└───────┘└───────┘</span><br></pre></td></tr></table></figure>

<p>2.如何运行java文件？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────────┐</span><br><span class="line">│    Hello.java    │&lt;─── source code</span><br><span class="line">└──────────────────┘</span><br><span class="line">          │ compile</span><br><span class="line">          ▼</span><br><span class="line">┌──────────────────┐</span><br><span class="line">│   Hello.class    │&lt;─── byte code</span><br><span class="line">└──────────────────┘</span><br><span class="line">          │ execute</span><br><span class="line">          ▼</span><br><span class="line">┌──────────────────┐</span><br><span class="line">│    Run on JVM    │</span><br><span class="line">└──────────────────┘</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>javac</code>可以将<code>.java</code>源码编译成<code>.class</code>字节码；</li>
<li>使用<code>java</code>可以运行一个已编译的Java程序，参数是类名。</li>
</ul>
<hr>
<h4 id="java程序基础"><a href="#java程序基础" class="headerlink" title="java程序基础"></a>java程序基础</h4><ul>
<li><p>基本数据类型</p>
<ul>
<li>整数类型：byte，short，int，long</li>
<li>浮点数类型：float，double</li>
<li>字符类型：char</li>
<li>布尔类型：boolean</li>
</ul>
</li>
<li><p>占用字节数</p>
<ul>
<li><pre><code class="ascii">       ┌───┐
  byte │   │   1
       └───┘
       ┌───┬───┐
 short │   │   │ 2 
       └───┴───┘
       ┌───┬───┬───┬───┐
   int │   │   │   │   │ 4
       └───┴───┴───┴───┘
       ┌───┬───┬───┬───┬───┬───┬───┬───┐
  long │   │   │   │   │   │   │   │   │ 8
       └───┴───┴───┴───┴───┴───┴───┴───┘
       ┌───┬───┬───┬───┐
 float │   │   │   │   │ 4
       └───┴───┴───┴───┘
       ┌───┬───┬───┬───┬───┬───┬───┬───┐
double │   │   │   │   │   │   │   │   │ 8
       └───┴───┴───┴───┴───┴───┴───┴───┘
       ┌───┬───┐
  char │   │   │ 2
       └───┴───┘
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    &#96;byte&#96;恰好就是一个字节，而&#96;long&#96;和&#96;double&#96;需要8个字节。</span><br><span class="line"></span><br><span class="line">- 整型</span><br><span class="line"></span><br><span class="line">  - 对于整型类型，Java只定义了带符号的整型，因此，**最高位的bit表示符号位**（0表示正数，1表示负数）。各种整型能表示的最大范围如下：</span><br><span class="line"></span><br><span class="line">    - byte：-128 ~ 127      **2^7**</span><br><span class="line">    - short: -32768 ~ 32767    **2^15**</span><br><span class="line">    - int: -2147483648 ~ 2147483647   **2^31**</span><br><span class="line">    - long: -9223372036854775808 ~ 9223372036854775807</span><br><span class="line"></span><br><span class="line">  - 通常**JVM内部会把&#96;boolean&#96;表示为4字节整数。**</span><br><span class="line"></span><br><span class="line">  - 整性运算</span><br><span class="line"></span><br><span class="line">    - 整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分</span><br><span class="line">    - 特别注意：**整数的除法对于除数为0时运行时将报错，但编译不会报错。**</span><br><span class="line"></span><br><span class="line">  - 溢出</span><br><span class="line"></span><br><span class="line">    - 要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出*不会出错*，却会得到一个奇怪的结果</span><br><span class="line"></span><br><span class="line">    - eg</span><br><span class="line"></span><br><span class="line">      - 要解释上述结果，我们把整数&#96;2147483640&#96;和&#96;15&#96;换成二进制做加法：</span><br><span class="line"></span><br><span class="line">        &#96;&#96;&#96;ascii</span><br><span class="line">          0111 1111 1111 1111 1111 1111 1111 1000</span><br><span class="line">        + 0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">        -----------------------------------------</span><br><span class="line">          1000 0000 0000 0000 0000 0000 0000 0111</span><br></pre></td></tr></table></figure>

    由于最高位计算结果为`1`，因此，加法结果变成了一个负数</code></pre>
</li>
<li><p>类型自动提升和强制转型</p>
<ul>
<li>在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型（<strong>自动提升</strong>）</li>
<li>将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用<code>(类型)</code><ul>
<li>超出范围的强制转型会得到错误的结果，原因是int转型short，<code>int</code>的两个高位字节直接被扔掉，仅保留了低位的两个字节</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>浮点型</p>
<ul>
<li><p>只能进行加减乘除这些数值计算，不能做位运算和移位运算</p>
</li>
<li><p><strong>浮点数无法精确表示</strong>，比如十进制的<code>0.1</code>换算成二进制是一个无限循环小数</p>
</li>
<li><p><strong>正确的比较方法</strong>：判断两个浮点数之差的绝对值是否小于一个很小的数</p>
</li>
<li><p><strong>自动类型提升</strong>：整性与浮点型运算时，自动转化为浮点型</p>
</li>
<li><p><strong>强制转型</strong>：可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉</p>
</li>
<li><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>整数运算在除数为<code>0</code>时会报错，而浮点数运算在除数为<code>0</code>时，不会报错，但会返回几个特殊值：</p>
<ul>
<li><code>NaN</code>表示Not a Number</li>
<li><code>Infinity</code>表示无穷大</li>
<li><code>-Infinity</code>表示负无穷大</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>字符串</p>
<ul>
<li><p>字符串的不可变性</p>
<ul>
<li><p>执行<code>String s = &quot;hello&quot;;</code>时，JVM虚拟机先创建字符串<code>&quot;hello&quot;</code>，然后，把字符串变量<code>s</code>指向它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      s</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌───┬───────────┬───┐</span><br><span class="line">│   │  &quot;hello&quot;  │   │</span><br><span class="line">└───┴───────────┴───┘</span><br></pre></td></tr></table></figure>

<p>紧接着，执行<code>s = &quot;world&quot;;</code>时，JVM虚拟机先创建字符串<code>&quot;world&quot;</code>，然后，把字符串变量<code>s</code>指向它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      s ──────────────┐</span><br><span class="line">                      │</span><br><span class="line">                      ▼</span><br><span class="line">┌───┬───────────┬───┬───────────┬───┐</span><br><span class="line">│   │  &quot;hello&quot;  │   │  &quot;world&quot;  │   │</span><br><span class="line">└───┴───────────┴───┴───────────┴───┘</span><br></pre></td></tr></table></figure>

<p>原来的字符串<code>&quot;hello&quot;</code>还在，只是我们无法通过变量<code>s</code>访问它而已。因此，字符串的不可变是指字符串内容不可变。</p>
</li>
</ul>
</li>
<li><p>注意要区分空值<code>null</code>和空字符串<code>&quot;&quot;</code>，空字符串是一个有效的字符串对象，它不等于<code>null</code></p>
</li>
<li><p>数组字符串</p>
<ul>
<li><p>字符串是引用类型，因此我们先定义一个字符串数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] names &#x3D; &#123;</span><br><span class="line">    &quot;ABC&quot;, &quot;XYZ&quot;, &quot;zoo&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于<code>String[]</code>类型的数组变量<code>names</code>，它实际上包含3个元素，但每个元素都指向某个字符串对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          ┌─────────────────────────┐</span><br><span class="line">    names │   ┌─────────────────────┼───────────┐</span><br><span class="line">      │   │   │                     │           │</span><br><span class="line">      ▼   │   │                     ▼           ▼</span><br><span class="line">┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┐</span><br><span class="line">│   │░░░│░░░│░░░│   │ &quot;ABC&quot; │   │ &quot;XYZ&quot; │   │ &quot;zoo&quot; │   │</span><br><span class="line">└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┘</span><br><span class="line">      │                 ▲</span><br><span class="line">      └─────────────────┘</span><br></pre></td></tr></table></figure>

<p>对<code>names[1]</code>进行赋值，例如<code>names[1] = &quot;cat&quot;;</code>，效果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          ┌─────────────────────────────────────────────────┐</span><br><span class="line">    names │   ┌─────────────────────────────────┐           │</span><br><span class="line">      │   │   │                                 │           │</span><br><span class="line">      ▼   │   │                                 ▼           ▼</span><br><span class="line">┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┬───────┬───┐</span><br><span class="line">│   │░░░│░░░│░░░│   │ &quot;ABC&quot; │   │ &quot;XYZ&quot; │   │ &quot;zoo&quot; │   │ &quot;cat&quot; │   │</span><br><span class="line">└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┴───────┴───┘</span><br><span class="line">      │                 ▲</span><br><span class="line">      └─────────────────┘</span><br></pre></td></tr></table></figure>

<p>这里注意到原来<code>names[1]</code>指向的字符串<code>&quot;XYZ&quot;</code>并没有改变，仅仅是将<code>names[1]</code>的引用从指向<code>&quot;XYZ&quot;</code>改成了指向<code>&quot;cat&quot;</code>，其结果是字符串<code>&quot;XYZ&quot;</code>再也无法通过<code>names[1]</code>访问到了。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数组</p>
<ul>
<li>二维数组就是数组的数组，三维数组就是二维数组的数组；</li>
<li>多维数组的每个数组元素长度都不要求相同；</li>
<li>打印多维数组可以使用<code>Arrays.deepToString()</code>；</li>
</ul>
</li>
</ul>
<ul>
<li>命令行参数<ul>
<li>命令行参数类型是<code>String[]</code>数组；</li>
<li>命令行参数由JVM接收用户输入并传给<code>main</code>方法；</li>
<li>如何解析命令行参数需要由程序自己实现。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul>
<li><p>重载</p>
<ul>
<li>方法重载是指多个方法的方法名相同，但各自的参数不同；</li>
<li>重载方法应该完成类似的功能，参考<code>String</code>的<code>indexOf()</code>；</li>
<li>重载方法返回值类型应该相同。</li>
</ul>
</li>
<li><p>继承</p>
<ul>
<li><p>如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法</p>
</li>
<li><p>向上转型：</p>
<ul>
<li><p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">Person p = s; <span class="comment">// upcasting, ok</span></span><br><span class="line">Object o1 = p; <span class="comment">// upcasting, ok</span></span><br><span class="line">Object o2 = s; <span class="comment">// upcasting, ok</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>向下转型：父类类型强制转型为子类类型</p>
<ul>
<li><pre><code>Person p1 = new Student(); // upcasting, ok
Person p2 = new Person();
Student s1 = (Student) p1; // ok
Student s2 = (Student) p2; // runtime error! ClassCastException!
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  测试上面的代码，可以发现：</span><br><span class="line"></span><br><span class="line">  &#96;Person&#96;类型&#96;p1&#96;实际指向&#96;Student&#96;实例，&#96;Person&#96;类型变量&#96;p2&#96;实际指向&#96;Person&#96;实例。在向下转型的时候，把&#96;p1&#96;转型为&#96;Student&#96;会成功，因为&#96;p1&#96;确实指向&#96;Student&#96;实例，把&#96;p2&#96;转型为&#96;Student&#96;会失败，因为&#96;p2&#96;的实际类型是&#96;Person&#96;，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。</span><br><span class="line"></span><br><span class="line">  因此，向下转型很可能会失败。失败的时候，Java虚拟机会报&#96;ClassCastException&#96;。</span><br><span class="line"></span><br><span class="line">- 利用&#96;instanceof&#96;，在向下转型前可以先判断：</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;java</span><br><span class="line">  Person p &#x3D; new Student();</span><br><span class="line">  if (p instanceof Student) &#123;</span><br><span class="line">      &#x2F;&#x2F; 只有判断成功才会向下转型:</span><br><span class="line">      Student s &#x3D; (Student) p; &#x2F;&#x2F; 一定会成功</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>多态：针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法</p>
<ul>
<li>允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码</li>
<li>子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；</li>
<li>Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；</li>
<li><code>final</code>修饰符有多种作用：<ul>
<li><code>final</code>修饰的方法可以阻止被覆写；</li>
<li><code>final</code>修饰的class可以阻止被继承；</li>
<li><code>final</code>修饰的field必须在创建对象时初始化，随后不可修改。</li>
</ul>
</li>
</ul>
</li>
<li><p>抽象</p>
<ul>
<li>通过<code>abstract</code>定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；</li>
<li>定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；</li>
<li>如果不实现抽象方法，则该子类仍是一个抽象类；</li>
<li>面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。</li>
</ul>
</li>
<li><p>接口</p>
<ul>
<li><p>Java的接口（interface）定义了纯抽象规范，一个类可以实现多个接口；</p>
</li>
<li><p>接口也是数据类型，适用于向上转型和向下转型；</p>
</li>
<li><p>接口的所有方法都是抽象方法，接口不能定义实例字段；</p>
</li>
<li><p><code>interface</code>的字段只能是<code>public static final</code>类型</p>
</li>
<li><p>接口可以定义<code>default</code>方法（JDK&gt;=1.8）</p>
<ul>
<li>实现类可以不必覆写<code>default</code>方法</li>
<li>新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法</li>
<li><code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</li>
</ul>
</li>
<li><p>接口与抽象区别</p>
<ul>
<li><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">abstract class</th>
<th align="center">interface</th>
</tr>
</thead>
<tbody><tr>
<td align="left">继承</td>
<td align="left">只能extends一个class</td>
<td align="center">可以implements多个interface</td>
</tr>
<tr>
<td align="left">字段</td>
<td align="left">可以定义实例字段</td>
<td align="center">不能定义实例字段</td>
</tr>
<tr>
<td align="left">抽象方法</td>
<td align="left">可以定义抽象方法</td>
<td align="center">可以定义抽象方法</td>
</tr>
<tr>
<td align="left">非抽象方法</td>
<td align="left">可以定义非抽象方法</td>
<td align="center">可以定义default方法</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><p>static关键字</p>
<ul>
<li>静态字段<ul>
<li>静态字段并不属于实例，而属于class，所有实例共享一个静态字段</li>
<li>实例对象能访问静态字段：编译器根据实例类型自动转换为<code>类名.静态字段</code>来访问静态对象（<strong>不推荐</strong>）</li>
</ul>
</li>
<li>静态方法<ul>
<li>调用静态方法不需要实例，无法访问<code>this</code>，但可以访问静态字段和其他静态方法；</li>
<li>常用作辅助方法：<ul>
<li>Arrays.sort()</li>
<li>Math.random()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>包</p>
<ul>
<li>Java内建的<code>package</code>机制是为了避免<code>class</code>命名冲突；- </li>
<li>JDK的核心类使用<code>java.lang</code>包，编译器会自动导入；</li>
<li>JDK的其它常用类定义在<code>java.util.*</code>，<code>java.math.*</code>，<code>java.text.*</code>，……；</li>
<li>包名推荐使用倒置的域名，例如<code>org.apache</code>。</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li>Java内建的访问权限包括<code>public</code>、<code>protected</code>、<code>private</code>和<code>package</code>权限；</li>
<li>Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束；</li>
<li><code>final</code>修饰符不是访问权限，它可以修饰<code>class</code>、<code>field</code>和<code>method</code>；<ul>
<li>用<code>final</code>修饰<code>class</code>可以阻止被继承</li>
<li>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写</li>
<li>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值</li>
<li>用<code>final</code>修饰局部变量可以阻止被重新赋值</li>
</ul>
</li>
<li>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="java核心类"><a href="#java核心类" class="headerlink" title="java核心类"></a>java核心类</h4><ul>
<li><p>String</p>
<ul>
<li><pre><code class="java">String`是一个引用类型，它本身也是一个`<span class="class"><span class="keyword">class</span></span>
<span class="class"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 字符串在&#96;String&#96;内部是通过一个&#96;char[]&#96;数组表示的，因此，按下面的写法也是可以的：</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;java</span><br><span class="line">  String s2 &#x3D; new String(new char[] &#123;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;!&#39;&#125;);</span><br></pre></td></tr></table></figure></span></code></pre>
</li>
<li><p><strong>字符串<em>不可变</em></strong>。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的。</p>
</li>
</ul>
</li>
<li><p>字符串比较</p>
<ul>
<li><p>比较是否相同：使用<code>equals()</code>方法而不能用<code>==</code></p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        String s1 = <span class="string">"hello"</span>;
        String s2 = <span class="string">"hello"</span>;
        System.out.println(s1 == s2);
        System.out.println(s1.equals(s2));
    }
}
&lt;!--￼<span class="number">11</span>--&gt;

而较新的JDK版本的`String`则以`<span class="keyword">byte</span>[]`存储：如果`String`仅包含ASCII字符，则每个`<span class="keyword">byte</span>`存储一个字符，否则，每两个`<span class="keyword">byte</span>`存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的`String`通常仅包含ASCII字符：

&lt;!--￼<span class="number">12</span>--&gt;

对于使用者来说，`String`内部的优化不影响任何已有代码，因为它的`<span class="keyword">public</span>`方法签名是不变的。</code></pre>
</li>
</ul>
</li>
<li><p>StringBuilder</p>
<ul>
<li><pre><code class="java">String s = <span class="string">""</span>;
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {
    s = s + <span class="string">","</span> + i;
}
&lt;!--￼<span class="number">13</span>--&gt;</code></pre>
</li>
<li><p>支持链式操作</p>
<ul>
<li>链式操作的关键是，定义的<code>append()</code>方法会返回<code>this</code></li>
</ul>
</li>
<li><p><code>StringBuffer</code>是<code>StringBuilder</code>的线程安全版本，现在很少使用</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>Java的异常是<code>class</code>，它的继承关系如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                     ┌───────────┐</span><br><span class="line">                     │  Object   │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                           │</span><br><span class="line">                     ┌───────────┐</span><br><span class="line">                     │ Throwable │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                 ┌─────────┴─────────┐</span><br><span class="line">                 │                   │</span><br><span class="line">           ┌───────────┐       ┌───────────┐</span><br><span class="line">           │   Error   │       │ Exception │</span><br><span class="line">           └───────────┘       └───────────┘</span><br><span class="line">                 ▲                   ▲</span><br><span class="line">         ┌───────┘              ┌────┴──────────┐</span><br><span class="line">         │                      │               │</span><br><span class="line">┌─────────────────┐    ┌─────────────────┐┌───────────┐</span><br><span class="line">│OutOfMemoryError │... │RuntimeException ││IOException│...</span><br><span class="line">└─────────────────┘    └─────────────────┘└───────────┘</span><br><span class="line">                                ▲</span><br><span class="line">                    ┌───────────┴─────────────┐</span><br><span class="line">                    │                         │</span><br><span class="line">         ┌─────────────────────┐ ┌─────────────────────────┐</span><br><span class="line">         │NullPointerException │ │IllegalArgumentException │...</span><br></pre></td></tr></table></figure>

<p>从继承关系可知：<code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p>
<ul>
<li><code>OutOfMemoryError</code>：内存耗尽</li>
<li><code>NoClassDefFoundError</code>：无法加载某个Class</li>
<li><code>StackOverflowError</code>：栈溢出</li>
</ul>
<p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p>
<p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p>
<ul>
<li><code>NumberFormatException</code>：数值类型的格式错误</li>
<li><code>FileNotFoundException</code>：未找到文件</li>
<li><code>SocketException</code>：读取网络失败</li>
</ul>
<p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p>
<ul>
<li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li>
<li><code>IndexOutOfBoundsException</code>：数组索引越界</li>
</ul>
<p><strong>java规定：</strong></p>
<ul>
<li>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为Checked Exception。</li>
<li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li>
</ul>
<p>抛出异常：</p>
<p>调用<code>printStackTrace()</code>可以打印异常的传播栈，对于调试非常有用；</p>
<p>捕获异常并再次抛出新的异常时，应该持有原始异常信息；</p>
<p>通常不要在<code>finally</code>中抛出异常。如果在<code>finally</code>中抛出异常，应该原始异常加入到原有异常中。调用方可通过<code>Throwable.getSuppressed()</code>获取所有添加的<code>Suppressed Exception</code>。</p>
<hr>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>def：反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息</p>
<p>targe：反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法</p>
<ul>
<li><p>class</p>
<ul>
<li><p>JVM为每个加载的<code>class</code>及<code>interface</code>创建了对应的<code>Class</code>实例来保存<code>class</code>及<code>interface</code>的所有信息</p>
<ul>
<li><p>除了基本类型（int）外，其他均为class</p>
</li>
<li><p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = <span class="keyword">new</span> Class(String);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>获取一个<code>class</code>对应的<code>Class</code>实例后，就可以获取该<code>class</code>的所有信息；</p>
<ul>
<li><p>一个<code>Class</code>实例包含了该<code>class</code>的所有完整信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = <span class="string">"java.lang.String"</span>  │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│<span class="keyword">package</span> = <span class="string">"java.lang"</span>      │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│<span class="keyword">super</span> = <span class="string">"java.lang.Object"</span> │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│<span class="class"><span class="keyword">interface</span> </span>= CharSequence...│</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│field = value[],hash,...   │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│method = indexOf()...      │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>通过Class实例获取<code>class</code>信息的方法称为反射（Reflection）；</p>
<ul>
<li><p>如何获取一个<code>class</code>的<code>Class</code>实例？有三个方法：</p>
<p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello"</span>;</span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></table></figure>

<p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>JVM总是动态加载<code>class</code>，可以在运行期根据条件来控制加载class</p>
</li>
<li><p>因为<code>Class</code>实例在JVM中是唯一的，所以，上述方法获取的<code>Class</code>实例是同一个实例。可以用<code>==</code>比较两个<code>Class</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class cls1 = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">String s = <span class="string">"Hello"</span>;</span><br><span class="line">Class cls2 = s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> sameClass = cls1 == cls2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JVM动态加载<code>class</code>的特性：jvm只有使用到某个类时才会加载到内存</p>
</li>
</ul>
</li>
<li><p>访问字段</p>
<ul>
<li><p>Java的反射API提供的<code>Field</code>类封装了字段的所有信息：</p>
</li>
<li><p>通过<code>Class</code>实例的方法可以获取<code>Field</code>实例：<code>getField()</code>，<code>getFields()</code>，<code>getDeclaredField()</code>，<code>getDeclaredFields()</code>；</p>
</li>
<li><p>通过Field实例可以获取字段信息：<code>getName()</code>，<code>getType()</code>，<code>getModifiers()</code>；</p>
</li>
<li><p>通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用<code>setAccessible(true)</code>来访问非<code>public</code>字段。</p>
</li>
<li><p>通过反射读写字段是一种非常规方法，它会破坏对象的封装。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”</p>
<p>Java的注解可以分为三类：</p>
<ul>
<li>第一类是由编译器使用的注解，例如：<ul>
<li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li>
<li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li>
<li>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</li>
</ul>
</li>
<li>第二类是由工具处理<code>.class</code>文件使用的注解，这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</li>
<li>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</li>
</ul>
<hr>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul>
<li><p>简介</p>
<ul>
<li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li>
<li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li>
<li><code>Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>接口与实现分离</li>
<li>支持泛型</li>
</ul>
</li>
<li><p>Java集合使用统一的<code>Iterator</code>遍历</p>
</li>
<li><p>list：顺序列表</p>
<ul>
<li><code>ArrayList</code><ul>
<li>在内部使用了数组来存储所有元素</li>
<li>数组已满，没有空闲位置的时候，<code>ArrayList</code>先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组</li>
<li>添加和删除的操作封装起来，让我们操作<code>List</code>类似于操作数组，却不用关心内部元素如何移动</li>
</ul>
</li>
<li>LinkedList<ul>
<li>链表形式</li>
</ul>
</li>
</ul>
</li>
<li><p>比较一下<code>ArrayList</code>和<code>LinkedList</code>：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">ArrayList</th>
<th align="left">LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取指定元素</td>
<td align="left">速度很快</td>
<td align="left">需要从头开始查找元素</td>
</tr>
<tr>
<td align="left">添加元素到末尾</td>
<td align="left">速度很快</td>
<td align="left">速度很快</td>
</tr>
<tr>
<td align="left">在指定位置添加/删除</td>
<td align="left">需要移动元素</td>
<td align="left">不需要移动元素</td>
</tr>
<tr>
<td align="left">内存占用</td>
<td align="left">少</td>
<td align="left">较大</td>
</tr>
</tbody></table>
</li>
<li><p>equals</p>
<ul>
<li><p><code>List</code>的实现类通过元素的<code>equals()</code>方法比较两个元素是否相等</p>
</li>
<li><p>Java标准库提供的<code>String</code>、<code>Integer</code>等已经覆写了<code>equals()</code>方法</p>
</li>
<li><p>自定义的对象需要覆写euquals方法</p>
<ul>
<li><p>如何正确编写<code>equals()</code>方法？<code>equals()</code>方法要求我们必须满足以下条件：</p>
<ul>
<li>自反性（Reflexive）：对于非<code>null</code>的<code>x</code>来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li>
<li>对称性（Symmetric）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li>
<li>传递性（Transitive）：对于非<code>null</code>的<code>x</code>、<code>y</code>和<code>z</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>；</li>
<li>一致性（Consistent）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，只要<code>x</code>和<code>y</code>状态不变，则<code>x.equals(y)</code>总是一致地返回<code>true</code>或者<code>false</code>；</li>
<li>对<code>null</code>的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li>
</ul>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>{
    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) {
        Person p = (Person) o;
        <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}
&lt;!--￼<span class="number">21</span>--&gt;


</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- **`entrySet()`集合**

  - ```java
    for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
                String key = entry.getKey();
                Integer value = entry.getValue();
                System.out.println(key + &quot; = &quot; + value);
            }
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 在&#96;Map&#96;的内部，对&#96;key&#96;做比较是通过&#96;equals()&#96;实现的</span><br><span class="line"></span><br><span class="line">    - 使用&#96;String&#96;作为&#96;key&#96;，因为&#96;String&#96;已经正确覆写了&#96;equals()&#96;方法</span><br><span class="line"></span><br><span class="line">    - 编写&#96;equals()&#96;和&#96;hashCode()&#96;遵循的原则是：</span><br><span class="line"></span><br><span class="line">      - &#96;equals()&#96;用到的用于比较的每一个字段，都必须在&#96;hashCode()&#96;中用于计算；</span><br><span class="line">      - &#96;equals()&#96;中没有使用到的字段，绝不可放在&#96;hashCode()&#96;中计算。</span><br><span class="line"></span><br><span class="line">      另外注意，对于放入&#96;HashMap&#96;的&#96;value&#96;对象，没有任何要求</span><br><span class="line"></span><br><span class="line">### 延伸阅读</span><br><span class="line"></span><br><span class="line">既然&#96;HashMap&#96;内部使用了数组，通过计算&#96;key&#96;的&#96;hashCode()&#96;直接定位&#96;value&#96;所在的索引，那么第一个问题来了：hashCode()返回的&#96;int&#96;范围高达±21亿，先不考虑负数，&#96;HashMap&#96;内部使用的数组得有多大？</span><br><span class="line"></span><br><span class="line">实际上&#96;HashMap&#96;初始化时默认的数组大小只有16，任何&#96;key&#96;，无论它的&#96;hashCode()&#96;有多大，都可以简单地通过：</span><br></pre></td></tr></table></figure></code></pre><p>int index = key.hashCode() &amp; 0xf; // 0xf = 15</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">把索引确定在0～15，即永远不会超出数组范围，上述算法只是一种最简单的实现。</span><br><span class="line"></span><br><span class="line">第二个问题：如果添加超过16个&#96;key-value&#96;到&#96;HashMap&#96;，数组不够用了怎么办？</span><br><span class="line"></span><br><span class="line">添加超过一定数量的&#96;key-value&#96;时，&#96;HashMap&#96;会在内部自动扩容，每次扩容一倍，即长度为16的数组扩展为长度32，相应地，需要重新确定&#96;hashCode()&#96;计算的索引位置。例如，对长度为32的数组计算&#96;hashCode()&#96;对应的索引，计算方式要改为：</span><br></pre></td></tr></table></figure>
<p>int index = key.hashCode() &amp; 0x1f; // 0x1f = 31</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">由于扩容会导致重新分布已有的&#96;key-value&#96;，所以，频繁扩容对&#96;HashMap&#96;的性能影响很大。如果我们确定要使用一个容量为&#96;10000&#96;个&#96;key-value&#96;的&#96;HashMap&#96;，更好的方式是创建&#96;HashMap&#96;时就指定容量：</span><br></pre></td></tr></table></figure>
<p>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(10000);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">虽然指定容量是&#96;10000&#96;，但&#96;HashMap&#96;内部的数组长度总是2n，因此，实际数组长度被初始化为比&#96;10000&#96;大的&#96;16384&#96;（214）。</span><br><span class="line"></span><br><span class="line">最后一个问题：如果不同的两个&#96;key&#96;，例如&#96;&quot;a&quot;&#96;和&#96;&quot;b&quot;&#96;，它们的&#96;hashCode()&#96;恰好是相同的（这种情况是完全可能的，因为不相等的两个实例，只要求&#96;hashCode()&#96;尽量不相等），那么，当我们放入：</span><br></pre></td></tr></table></figure>
<p>map.put(“a”, new Person(“Xiao Ming”));<br>map.put(“b”, new Person(“Xiao Hong”));</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">时，由于计算出的数组索引相同，后面放入的&#96;&quot;Xiao Hong&quot;&#96;会不会把&#96;&quot;Xiao Ming&quot;&#96;覆盖了？</span><br><span class="line"></span><br><span class="line">当然不会！使用&#96;Map&#96;的时候，只要&#96;key&#96;不相同，它们映射的&#96;value&#96;就互不干扰。但是，在&#96;HashMap&#96;内部，确实可能存在不同的&#96;key&#96;，映射到相同的&#96;hashCode()&#96;，即相同的数组索引上，肿么办？</span><br><span class="line"></span><br><span class="line">我们就假设&#96;&quot;a&quot;&#96;和&#96;&quot;b&quot;&#96;这两个&#96;key&#96;最终计算出的索引都是5，那么，在&#96;HashMap&#96;的数组中，实际存储的不是一个&#96;Person&#96;实例，而是一个&#96;List&#96;，它包含两个&#96;Entry&#96;，一个是&#96;&quot;a&quot;&#96;的映射，一个是&#96;&quot;b&quot;&#96;的映射：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;ascii</span><br><span class="line">  ┌───┐</span><br><span class="line">0 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">1 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">2 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">3 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">4 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">5 │ ●─┼───&gt; List&lt;Entry&lt;String, Person&gt;&gt;</span><br><span class="line">  ├───┤</span><br><span class="line">6 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">7 │   │</span><br><span class="line">  └───┘</span><br></pre></td></tr></table></figure>

<p>在查找的时候，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p &#x3D; map.get(&quot;a&quot;);</span><br></pre></td></tr></table></figure>

<p>HashMap内部通过<code>&quot;a&quot;</code>找到的实际上是<code>List&gt;</code>，它还需要遍历这个<code>List</code>，并找到一个<code>Entry</code>，它的<code>key</code>字段是<code>&quot;a&quot;</code>，才能返回对应的<code>Person</code>实例。</p>
<p>我们把不同的<code>key</code>具有相同的<code>hashCode()</code>的情况称之为哈希冲突。在冲突的时候，一种最简单的解决办法是用<code>List</code>存储<code>hashCode()</code>相同的<code>key-value</code>。显然，如果冲突的概率越大，这个<code>List</code>就越长，<code>Map</code>的<code>get()</code>方法效率就越低，这就是为什么要尽量满足条件二：</p>
<p> 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。</p>
<p><code>hashCode()</code>方法编写得越好，<code>HashMap</code>工作的效率就越高。</p>
<ul>
<li><h4 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h4><ul>
<li><p>如果<code>Map</code>的key是<code>enum</code>类型，推荐使用<code>EnumMap</code>，既保证速度，也不浪费空间</p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        Map&lt;DayOfWeek, String&gt; map = <span class="keyword">new</span> EnumMap&lt;&gt;(DayOfWeek<span class="class">.<span class="keyword">class</span>)</span>;
        map.put(DayOfWeek.MONDAY, <span class="string">"星期一"</span>);
        map.put(DayOfWeek.TUESDAY, <span class="string">"星期二"</span>);
        map.put(DayOfWeek.WEDNESDAY, <span class="string">"星期三"</span>);
        map.put(DayOfWeek.THURSDAY, <span class="string">"星期四"</span>);
        map.put(DayOfWeek.FRIDAY, <span class="string">"星期五"</span>);
        map.put(DayOfWeek.SATURDAY, <span class="string">"星期六"</span>);
        map.put(DayOfWeek.SUNDAY, <span class="string">"星期日"</span>);
        System.out.println(map);
        System.out.println(map.get(DayOfWeek.MONDAY));
    }
}
&lt;!--￼<span class="number">28</span>--&gt;</code></pre>
</li>
<li><p>Key必须实现<code>Comparable</code>接口,TreeMap<code>不使用</code>equals()<code>和</code>hashCode()</p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        Map&lt;Student, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() {
            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student p1, Student p2)</span> </span>{
                <span class="keyword">if</span> (p1.score == p2.score) {
                    <span class="keyword">return</span> <span class="number">0</span>;
                }
                <span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;
            }
        });
        map.put(<span class="keyword">new</span> Student(<span class="string">"Tom"</span>, <span class="number">77</span>), <span class="number">1</span>);
        map.put(<span class="keyword">new</span> Student(<span class="string">"Bob"</span>, <span class="number">66</span>), <span class="number">2</span>);
        map.put(<span class="keyword">new</span> Student(<span class="string">"Lily"</span>, <span class="number">99</span>), <span class="number">3</span>);
        <span class="keyword">for</span> (Student key : map.keySet()) {
            System.out.println(key);
        }
        System.out.println(map.get(<span class="keyword">new</span> Student(<span class="string">"Bob"</span>, <span class="number">66</span>))); <span class="comment">// 重写方法，相等为0</span>
    }
}
&lt;!--￼<span class="number">29</span>--&gt;</code></pre>
</li>
<li><pre><code class="ascii">       ┌───┐
       │Set│
       └───┘
         ▲
    ┌────┴─────┐
    │          │
┌───────┐ ┌─────────┐
│HashSet│ │SortedSet│
└───────┘ └─────────┘
               ▲
               │
          ┌─────────┐
          │ TreeSet │
          └─────────┘
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - &#96;HashSet&#96;是无序的，因为它实现了&#96;Set&#96;接口，并没有实现&#96;SortedSet&#96;接口；</span><br><span class="line"></span><br><span class="line">  - &#96;TreeSet&#96;是有序的，因为它实现了&#96;SortedSet&#96;接口。</span><br><span class="line"></span><br><span class="line">    - 添加的元素必须正确实现&#96;Comparable&#96;接口，如果没有实现&#96;Comparable&#96;接口，那么创建&#96;TreeSet&#96;时必须传入一个&#96;Comparator&#96;对象。</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">#### IO流</span><br><span class="line"></span><br><span class="line">IO流是一种流式的数据输入&#x2F;输出模型：</span><br><span class="line"></span><br><span class="line">- 二进制数据以&#96;byte&#96;为最小单位在&#96;InputStream&#96;&#x2F;&#96;OutputStream&#96;中单向流动；</span><br><span class="line">- 字符数据以&#96;char&#96;为最小单位在&#96;Reader&#96;&#x2F;&#96;Writer&#96;中单向流动。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**File**：Java标准库的&#96;java.io.File&#96;对象表示一个文件或者目录：</span><br><span class="line"></span><br><span class="line">- 创建&#96;File&#96;对象本身不涉及IO操作；</span><br><span class="line"></span><br><span class="line">- 可以获取路径／绝对路径／规范路径：&#96;getPath()&#96;&#x2F;&#96;getAbsolutePath()&#96;&#x2F;&#96;getCanonicalPath()&#96;；</span><br><span class="line"></span><br><span class="line">- 可以获取目录的文件和子目录：&#96;list()&#96;&#x2F;&#96;listFiles()&#96;；</span><br><span class="line"></span><br><span class="line">- 可以创建或删除文件和目录。</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;java</span><br><span class="line">  public class Main &#123;</span><br><span class="line">      public static void main(String[] args) throws IOException &#123;</span><br><span class="line">          File f &#x3D; new File(&quot;..&quot;);</span><br><span class="line">          System.out.println(f.getPath());</span><br><span class="line">          System.out.println(f.getAbsolutePath());</span><br><span class="line">          System.out.println(f.getCanonicalPath());</span><br><span class="line">          File file &#x3D; new File(&quot;&#x2F;path&#x2F;to&#x2F;file&quot;);</span><br><span class="line">          #-----------------------------------------</span><br><span class="line">          if (file.createNewFile()) &#123;</span><br><span class="line">              &#x2F;&#x2F; 文件创建成功:</span><br><span class="line">              &#x2F;&#x2F; TODO:</span><br><span class="line">              if (file.delete()) &#123;</span><br><span class="line">                  &#x2F;&#x2F; 删除文件成功:</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>inputsteam</strong>: 是一个抽象类，而不是接口，是所有输入流的超类（以字节为单位）</p>
<ul>
<li><p>面向抽象编程原则的应用：接受<code>InputStream</code>抽象类型，而不是具体的<code>FileInputStream</code>类型，从而使得代码可以处理<code>InputStream</code>的任意实现类</p>
</li>
<li><p>fileinputstream</p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{
    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>)) {
        <span class="comment">// 定义1000个字节大小的缓冲区:</span>
        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];
        <span class="keyword">int</span> n;
        <span class="keyword">while</span> ((n = input.read(buffer)) != -<span class="number">1</span>) { <span class="comment">// 读取到缓冲区</span>
            System.out.println(<span class="string">"read "</span> + n + <span class="string">" bytes."</span>);
        }
    }
}
&lt;!--￼<span class="number">31</span>--&gt;
<span class="number">1</span>.利用Java <span class="number">7</span>引入的新的<span class="keyword">try</span>(resource)的语法，只需要编写<span class="keyword">try</span>语句，让编译器自动为我们关闭资源
<span class="number">2</span>.编译器只看<span class="keyword">try</span>(resource = ...)中的对象是否实现了java.lang.AutoCloseable接口，如果实现了，就自动加上<span class="keyword">finally</span>语句并调用close()方法。
<span class="number">3</span>.read方法是阻塞的（返回后才能继续）
&lt;!--￼<span class="number">32</span>--&gt;


</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>装饰模式</strong>：运行时动态的增加功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">                 ┌─────────────┐</span><br><span class="line">                 │ InputStream │</span><br><span class="line">                 └─────────────┘</span><br><span class="line">                       ▲ ▲</span><br><span class="line">┌────────────────────┐ │ │ ┌─────────────────┐</span><br><span class="line">│  FileInputStream   │─┤ └─│FilterInputStream│</span><br><span class="line">└────────────────────┘ │   └─────────────────┘</span><br><span class="line">┌────────────────────┐ │     ▲ ┌───────────────────┐</span><br><span class="line">│ByteArrayInputStream│─┤     ├─│BufferedInputStream│</span><br><span class="line">└────────────────────┘ │     │ └───────────────────┘</span><br><span class="line">┌────────────────────┐ │     │ ┌───────────────────┐</span><br><span class="line">│ ServletInputStream │─┘     ├─│  DataInputStream  │</span><br><span class="line">└────────────────────┘       │ └───────────────────┘</span><br><span class="line">                             │ ┌───────────────────┐</span><br><span class="line">                             └─│CheckedInputStream │</span><br><span class="line">                               └───────────────────┘</span><br></pre></td></tr></table></figure>

<p>编写一个<code>CountInputStream</code>，它的作用是对输入的字节进行计数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="string">"hello, world!"</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">try</span> (CountInputStream input = <span class="keyword">new</span> CountInputStream(<span class="keyword">new</span> ByteArrayInputStream(data))) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Total read "</span> + input.getBytesRead() + <span class="string">" bytes"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CountInputStream(InputStream in) &#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBytesRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = in.read();</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = in.read(b, off, len);</span><br><span class="line">        <span class="keyword">this</span>.count += n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>classpath路径：</strong>避免不同环境下文件路径不一致的问题</p>
<p>调用<code>getResourceAsStream()</code>需要特别注意的一点是，如果资源文件不存在，它将返回<code>null</code>。因此，我们需要检查返回的<code>InputStream</code>是否为<code>null</code>，如果为<code>null</code>，表示资源文件在classpath中没有找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try (InputStream input &#x3D; getClass().getResourceAsStream(&quot;&#x2F;default.properties&quot;)) &#123;</span><br><span class="line">    if (input !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Properties props &#x3D; new Properties();</span><br><span class="line">props.load(inputStreamFromClassPath(&quot;&#x2F;default.properties&quot;));</span><br><span class="line">props.load(inputStreamFromFile(&quot;.&#x2F;conf.properties&quot;));</span><br></pre></td></tr></table></figure>

<p>这样读取配置文件，应用程序启动就更加灵活</p>
<p><strong>序列化</strong></p>
<p><strong>Reader</strong></p>
<table>
<thead>
<tr>
<th align="left">InputStream</th>
<th align="left">Reader</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字节流，以<code>byte</code>为单位</td>
<td align="left">字符流，以<code>char</code>为单位</td>
</tr>
<tr>
<td align="left">读取字节（-1，0~255）：<code>int read()</code></td>
<td align="left">读取字符（-1，0~65535）：<code>int read()</code></td>
</tr>
<tr>
<td align="left">读到字节数组：<code>int read(byte[] b)</code></td>
<td align="left">读到字符数组：<code>int read(char[] c)</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"src/readme.txt"</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"read "</span> + n + <span class="string">" chars."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Reader</code>是基于<code>InputStream</code>构造的：可以通过<code>InputStreamReader</code>在指定编码的同时将任何<code>InputStream</code>转换为<code>Reader</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 持有InputStream:</span></span><br><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>);</span><br><span class="line"><span class="comment">// 变换为Reader:</span></span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(input, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>



<p><strong>write</strong></p>
<table>
<thead>
<tr>
<th align="left">OutputStream</th>
<th align="left">Writer</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字节流，以<code>byte</code>为单位</td>
<td align="left">字符流，以<code>char</code>为单位</td>
</tr>
<tr>
<td align="left">写入字节（0~255）：<code>void write(int b)</code></td>
<td align="left">写入字符（0~65535）：<code>void write(int c)</code></td>
</tr>
<tr>
<td align="left">写入字节数组：<code>void write(byte[] b)</code></td>
<td align="left">写入字符数组：<code>void write(char[] c)</code></td>
</tr>
<tr>
<td align="left">无对应方法</td>
<td align="left">写入String：<code>void write(String s)</code></td>
</tr>
</tbody></table>
<h3 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h3><p><code>FileWriter</code>就是向文件中写入字符流的<code>Writer</code>。它的使用方法和<code>FileReader</code>类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"readme.txt"</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(<span class="string">'H'</span>); <span class="comment">// 写入单个字符</span></span><br><span class="line">    writer.write(<span class="string">"Hello"</span>.toCharArray()); <span class="comment">// 写入char[]</span></span><br><span class="line">    writer.write(<span class="string">"Hello"</span>); <span class="comment">// 写入String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Writer</code>是基于<code>OutputStream</code>构造的，可以通过<code>OutputStreamWriter</code>将<code>OutputStream</code>转换为<code>Writer</code>，转换时需要指定编码</p>
<p><code>PrintStream</code>是一种能接收各种数据类型的输出，打印数据时比较方便：</p>
<ul>
<li><code>System.out</code>是标准输出；</li>
<li><code>System.err</code>是标准错误输出。</li>
</ul>
<p><code>PrintWriter</code>是基于<code>Writer</code>的输出</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MRZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MRZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/26/%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-26 14:45:45" itemprop="dateCreated datePublished" datetime="2020-03-26T14:45:45+08:00">2020-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-24 22:42:42" itemprop="dateModified" datetime="2020-03-24T22:42:42+08:00">2020-03-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- TOC -->

<ul>
<li><a href="#一-osi与tcpip各层的结构与功能都有哪些协议">一 OSI与TCP/IP各层的结构与功能,都有哪些协议?</a><ul>
<li><a href="#11-应用层">1.1 应用层</a></li>
<li><a href="#12-运输层">1.2 运输层</a></li>
<li><a href="#13-网络层">1.3 网络层</a></li>
<li><a href="#14-数据链路层">1.4 数据链路层</a></li>
<li><a href="#15-物理层">1.5 物理层</a></li>
<li><a href="#16-总结一下">1.6 总结一下</a></li>
</ul>
</li>
<li><a href="#二-tcp-三次握手和四次挥手面试常客">二 TCP 三次握手和四次挥手(面试常客)</a><ul>
<li><a href="#21-tcp-三次握手漫画图解">2.1 TCP 三次握手漫画图解</a></li>
<li><a href="#22-为什么要三次握手">2.2 为什么要三次握手</a></li>
<li><a href="#23-为什么要传回-syn">2.3 为什么要传回 SYN</a></li>
<li><a href="#24-传了-syn为啥还要传-ack">2.4 传了 SYN,为啥还要传 ACK</a></li>
<li><a href="#25-为什么要四次挥手">2.5 为什么要四次挥手</a></li>
</ul>
</li>
<li><a href="#三-tcpudp-协议的区别">三 TCP,UDP 协议的区别</a></li>
<li><a href="#四-tcp-协议如何保证可靠传输">四 TCP 协议如何保证可靠传输</a><ul>
<li><a href="#41-arq协议">4.1 ARQ协议</a><ul>
<li><a href="#停止等待arq协议">停止等待ARQ协议</a></li>
<li><a href="#连续arq协议">连续ARQ协议</a></li>
</ul>
</li>
<li><a href="#42-滑动窗口和流量控制">4.2 滑动窗口和流量控制</a></li>
<li><a href="#43-拥塞控制">4.3 拥塞控制</a></li>
</ul>
</li>
<li><a href="#五--在浏览器中输入url地址---显示主页的过程面试常客">五  在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)</a></li>
<li><a href="#六-状态码">六 状态码</a></li>
<li><a href="#七-各种协议与http协议之间的关系">七 各种协议与HTTP协议之间的关系</a></li>
<li><a href="#八--http长连接短连接">八  HTTP长连接,短连接</a></li>
<li><a href="#九-http是不保存状态的协议如何保存用户状态">九 HTTP是不保存状态的协议,如何保存用户状态?</a></li>
<li><a href="#十-cookie的作用是什么和session有什么区别">十 Cookie的作用是什么?和Session有什么区别？</a></li>
<li><a href="#十一-http-10和http-11的主要区别是什么">十一 HTTP 1.0和HTTP 1.1的主要区别是什么?</a></li>
<li><a href="#十二-uri和url的区别是什么">十二 URI和URL的区别是什么?</a></li>
<li><a href="#十三-http-和-https-的区别">十三 HTTP 和 HTTPS 的区别？</a></li>
<li><a href="#建议">建议</a></li>
<li><a href="#参考">参考</a></li>
</ul>
<!-- /TOC -->

<h2 id="一-OSI与TCP-IP各层的结构与功能-都有哪些协议"><a href="#一-OSI与TCP-IP各层的结构与功能-都有哪些协议" class="headerlink" title="一 OSI与TCP/IP各层的结构与功能,都有哪些协议?"></a>一 OSI与TCP/IP各层的结构与功能,都有哪些协议?</h2><p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="五层体系结构"></p>
<p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。</p>
<h3 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h3><p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。</strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如<strong>域名系统DNS</strong>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p>
<p><strong>域名系统</strong></p>
<blockquote>
<p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.com、Oracle" target="_blank" rel="noopener">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.com、Cisco公司的域名是" target="_blank" rel="noopener">www.oracle.com、Cisco公司的域名是</a> <a href="http://www.cisco.com" target="_blank" rel="noopener">www.cisco.com</a> 等。</p>
</blockquote>
<p><strong>HTTP协议</strong></p>
<blockquote>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p>
</blockquote>
<h3 id="1-2-运输层"><a href="#1-2-运输层" class="headerlink" title="1.2 运输层"></a>1.2 运输层</h3><p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<p><strong>运输层主要使用以下两种协议:</strong></p>
<ol>
<li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li>
<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li>
</ol>
<p><strong>TCP 与 UDP 的对比见问题三。</strong></p>
<h3 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3 网络层"></a>1.3 网络层</h3><p><strong>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p>
<p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p>
<h3 id="1-4-数据链路层"><a href="#1-4-数据链路层" class="headerlink" title="1.4 数据链路层"></a>1.4 数据链路层</h3><p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。<br>控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<h3 id="1-5-物理层"><a href="#1-5-物理层" class="headerlink" title="1.5 物理层"></a>1.5 物理层</h3><p>在物理层上所传送的数据单位是比特。<br> <strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p>
<h3 id="1-6-总结一下"><a href="#1-6-总结一下" class="headerlink" title="1.6 总结一下"></a>1.6 总结一下</h3><p>上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下。图片来源：<a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869" target="_blank" rel="noopener">https://blog.csdn.net/yaopeng_2005/article/details/7064869</a></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%83%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="七层体系结构图"></p>
<h2 id="二-TCP-三次握手和四次挥手-面试常客"><a href="#二-TCP-三次握手和四次挥手-面试常客" class="headerlink" title="二 TCP 三次握手和四次挥手(面试常客)"></a>二 TCP 三次握手和四次挥手(面试常客)</h2><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p>
<h3 id="2-1-TCP-三次握手漫画图解"><a href="#2-1-TCP-三次握手漫画图解" class="headerlink" title="2.1 TCP 三次握手漫画图解"></a>2.1 TCP 三次握手漫画图解</h3><p>如下图所示，下面的两个机器人通过3次握手确定了对方能正确接收和发送消息(图片来源：《图解HTTP》)。<br><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP三次握手"></p>
<p><strong>简单示意图：</strong><br><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png" alt="TCP三次握手"></p>
<ul>
<li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li>
<li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li>
<li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li>
</ul>
<h3 id="2-2-为什么要三次握手"><a href="#2-2-为什么要三次握手" class="headerlink" title="2.2 为什么要三次握手"></a>2.2 为什么要三次握手</h3><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<h3 id="2-3-为什么要传回-SYN"><a href="#2-3-为什么要传回-SYN" class="headerlink" title="2.3 为什么要传回 SYN"></a>2.3 为什么要传回 SYN</h3><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<blockquote>
<p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h3 id="2-4-传了-SYN-为啥还要传-ACK"><a href="#2-4-传了-SYN-为啥还要传-ACK" class="headerlink" title="2.4 传了 SYN,为啥还要传 ACK"></a>2.4 传了 SYN,为啥还要传 ACK</h3><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="TCP四次挥手"></p>
<p>断开一个 TCP 连接则需要“四次挥手”：</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<h3 id="2-5-为什么要四次挥手"><a href="#2-5-为什么要四次挥手" class="headerlink" title="2.5 为什么要四次挥手"></a>2.5 为什么要四次挥手</h3><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>
<h2 id="三-TCP-UDP-协议的区别"><a href="#三-TCP-UDP-协议的区别" class="headerlink" title="三 TCP,UDP 协议的区别"></a>三 TCP,UDP 协议的区别</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg" alt="TCP、UDP协议的区别"></p>
<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<h2 id="四-TCP-协议如何保证可靠传输"><a href="#四-TCP-协议如何保证可靠传输" class="headerlink" title="四 TCP 协议如何保证可靠传输"></a>四 TCP 协议如何保证可靠传输</h2><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。 </li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 </li>
<li>TCP 的接收端会丢弃重复的数据。 </li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </li>
</ol>
<h3 id="4-1-ARQ协议"><a href="#4-1-ARQ协议" class="headerlink" title="4.1 ARQ协议"></a>4.1 ARQ协议</h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p>
<h4 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h4><ul>
<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li>
<li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li>
</ul>
<p><strong>优点：</strong> 简单</p>
<p><strong>缺点：</strong> 信道利用率低，等待时间长</p>
<p><strong>1) 无差错情况:</strong></p>
<p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>
<p><strong>2) 出现差错情况（超时重传）:</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<p><strong>3) 确认丢失和确认迟到</strong></p>
<ul>
<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li>
</ul>
<h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h3 id="4-2-滑动窗口和流量控制"><a href="#4-2-滑动窗口和流量控制" class="headerlink" title="4.2 滑动窗口和流量控制"></a>4.2 滑动窗口和流量控制</h3><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h3 id="4-3-拥塞控制"><a href="#4-3-拥塞控制" class="headerlink" title="4.3 拥塞控制"></a>4.3 拥塞控制</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li>
<li><strong>快重传与快恢复：</strong><br>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
<h2 id="五-在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客"><a href="#五-在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客" class="headerlink" title="五  在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)"></a>五  在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)</h2><p>百度好像最喜欢问这个问题。</p>
<blockquote>
<p>打开一个网页，整个过程会使用哪些协议</p>
</blockquote>
<p>图解（图片来源：《图解HTTP》）：</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url输入到展示出来的过程.jpg" style="zoom:50%;" />

<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>具体可以参考下面这篇文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a></li>
</ul>
<h2 id="六-状态码"><a href="#六-状态码" class="headerlink" title="六 状态码"></a>六 状态码</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="状态码"></p>
<h2 id="七-各种协议与HTTP协议之间的关系"><a href="#七-各种协议与HTTP协议之间的关系" class="headerlink" title="七 各种协议与HTTP协议之间的关系"></a>七 各种协议与HTTP协议之间的关系</h2><p>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。</p>
<p>图片来源：《图解HTTP》</p>
<p> <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="各种协议与HTTP协议之间的关系"></p>
<h2 id="八-HTTP长连接-短连接"><a href="#八-HTTP长连接-短连接" class="headerlink" title="八  HTTP长连接,短连接"></a>八  HTTP长连接,短连接</h2><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong> </p>
<p>—— <a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener">《HTTP长连接、短连接究竟是什么？》</a></p>
<h2 id="九-HTTP是不保存状态的协议-如何保存用户状态"><a href="#九-HTTP是不保存状态的协议-如何保存用户状态" class="headerlink" title="九 HTTP是不保存状态的协议,如何保存用户状态?"></a>九 HTTP是不保存状态的协议,如何保存用户状态?</h2><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP  协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p><strong>Cookie 被禁用怎么办?</strong></p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HTTP%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84.png" alt="HTTP是无状态协议"></p>
<h2 id="十-Cookie的作用是什么-和Session有什么区别？"><a href="#十-Cookie的作用是什么-和Session有什么区别？" class="headerlink" title="十 Cookie的作用是什么?和Session有什么区别？"></a>十 Cookie的作用是什么?和Session有什么区别？</h2><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p> <strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<h2 id="十一-HTTP-1-0和HTTP-1-1的主要区别是什么"><a href="#十一-HTTP-1-0和HTTP-1-1的主要区别是什么" class="headerlink" title="十一 HTTP 1.0和HTTP 1.1的主要区别是什么?"></a>十一 HTTP 1.0和HTTP 1.1的主要区别是什么?</h2><blockquote>
<p>这部分回答引用这篇文章 <a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?</a> 的一些内容。</p>
</blockquote>
<p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>
<ol>
<li><strong>长连接</strong> : <strong>在HTTP/1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 <strong>HTTP/1.1的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li>
<li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
</ol>
<h2 id="十二-URI和URL的区别是什么"><a href="#十二-URI和URL的区别是什么" class="headerlink" title="十二 URI和URL的区别是什么?"></a>十二 URI和URL的区别是什么?</h2><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="十三-HTTP-和-HTTPS-的区别？"><a href="#十三-HTTP-和-HTTPS-的区别？" class="headerlink" title="十三 HTTP 和 HTTPS 的区别？"></a>十三 HTTP 和 HTTPS 的区别？</h2><ol>
<li><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li>
<li><strong>安全性和资源消耗：</strong> HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>
</ul>
</li>
</ol>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>非常推荐大家看一下 《图解HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/qq_16209077/article/details/52718250" target="_blank" rel="noopener">https://blog.csdn.net/qq_16209077/article/details/52718250</a></li>
<li><a href="https://blog.csdn.net/zixiaomuwu/article/details/60965466" target="_blank" rel="noopener">https://blog.csdn.net/zixiaomuwu/article/details/60965466</a></li>
<li><a href="https://blog.csdn.net/turn__back/article/details/73743641" target="_blank" rel="noopener">https://blog.csdn.net/turn__back/article/details/73743641</a></li>
<li><a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/%E5%89%91%E6%8C%87offer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MRZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MRZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/26/%E5%89%91%E6%8C%87offer/" class="post-title-link" itemprop="url">剑指offer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-26 13:28:02 / Modified: 11:59:42" itemprop="dateCreated datePublished" datetime="2020-03-26T13:28:02+08:00">2020-03-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>剑指offer</p>
<h4 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">描述：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组&#123;2,3,1,0,2,5,3&#125;，那么对应的输出是第一个重复的数字2</span><br></pre></td></tr></table></figure>

<ul>
<li><p>它考察的是程序员的沟通能力，先问面试官要时间/空间需求！！！<br>只是时间优先就用字典，<br>还有空间要求，就用指针+原地排序数组，<br>如果面试官要求空间O(1)并且不能修改原数组，还得写成二分法！！！</p>
</li>
<li><p>方法一：可以数组排序，从头遍历数组找到与下标不同的元素输出 ： O（nlogn）</p>
</li>
<li><p>方法二：可以使用哈希表的方法：没有元素则加入，已经存在则输出</p>
<ul>
<li><pre><code class="python">help = []
<span class="keyword">for</span> i <span class="keyword">in</span> arr:
    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> help:
        help.append(i)
    <span class="keyword">else</span>:
        print(i)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 时间复杂度为O（n）,但是空间复杂度为O（n）：维护一个hash表</span><br><span class="line"></span><br><span class="line">- 方法三：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;python</span><br><span class="line">    def duplicate(number, duplication):</span><br><span class="line">    	if number is None and len(number) &lt;&#x3D; 0: #边界条件不为空</span><br><span class="line">    		return False</span><br><span class="line">    	for n in number:    # 边界条件不为无效输入用例</span><br><span class="line">    		if n &lt; 0 or n &gt; len(number) - 1:</span><br><span class="line">    			return False</span><br><span class="line">    	for i in range(len(number)):   #依次进行扫描</span><br><span class="line">    		while number[i] !&#x3D; i:   #如果数字与下标不等</span><br><span class="line">    			if number[i] &#x3D;&#x3D; number[number[i]]: #判断该数字正确下标是否是该数</span><br><span class="line">    				# print(arr[i])</span><br><span class="line">    				duplication &#x3D; number[i]   #是的话  找到重复数字</span><br><span class="line">    				return True</span><br><span class="line">    			else:                #不是的话，该数字交换到正确的位置</span><br><span class="line">    				temp &#x3D; number[i]</span><br><span class="line">    				number[i] &#x3D; number[temp]</span><br><span class="line">    				number[temp] &#x3D; temp</span><br><span class="line">    	return False</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>尽管有两个循环，但是每个数字最多交换两次就能找到属于他们的位置，总的时间复杂度为O（n）</p>
</li>
<li><p>空间复杂度为O(1)</p>
</li>
</ul>
</li>
<li><p>该题的边界条件：</p>
<ul>
<li>数组为空</li>
<li>数组中的数字为0-n-1以外的数字</li>
<li>数组中不包含重复的数字</li>
</ul>
</li>
</ul>
<hr>
<h4 id="不修改数组找出重复的数字"><a href="#不修改数组找出重复的数字" class="headerlink" title="不修改数组找出重复的数字"></a>不修改数组找出重复的数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">长度为n+1的数组中，所有的数字在1-n的范围内，至少一个数字是重复的，找出任意重复数字，并不修改数组</span><br></pre></td></tr></table></figure>

<ul>
<li>方法一：<ul>
<li>再来一个数组，依次把元素放入新的数组（下标为该数字）中，很容易找到重复数字</li>
<li>时间空间复杂度都是O（n）</li>
</ul>
</li>
<li>方法二：二分法<ul>
<li>把数字1-n从中间的数字m分成两份，如果1-m的数字个数大于m则在1-m中，反之在m+1-n中</li>
<li>code</li>
<li>缺点：不能保证找出全部的重复数字</li>
</ul>
</li>
<li>边界：<ul>
<li>空指针</li>
<li>没有重复的数字</li>
<li>无效测试用例</li>
</ul>
</li>
</ul>
<hr>
<h4 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>思路：从左下角或者右上角开始查找，如果小于则向下找，大于向左找，每次剔除一行一列</p>
<ul>
<li>1 2 8 9</li>
<li>2 4 9 12</li>
<li>4 7 10 13</li>
</ul>
</li>
<li><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span>
    <span class="comment"># write code here</span>
    i = <span class="number">0</span>
    j = len(array[<span class="number">0</span>])<span class="number">-1</span>
    <span class="comment"># 边界问题：</span>
    max(i)=len(arr)<span class="number">-1</span> ,min(j)=<span class="number">0</span>
    <span class="keyword">if</span> target&gt;max(i) <span class="keyword">or</span> target&lt;min(i):
        <span class="keyword">return</span> <span class="literal">False</span>
    <span class="keyword">while</span> i&lt;len(array) <span class="keyword">and</span> j&gt;=<span class="number">0</span>: 
        value = array[i][j]
        <span class="keyword">if</span> value == target:
            <span class="keyword">return</span> <span class="literal">True</span>
        <span class="keyword">elif</span> value&gt;target:
            j -=<span class="number">1</span>
        <span class="keyword">else</span>:
            i+=<span class="number">1</span>
    <span class="keyword">return</span> <span class="literal">False</span>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 边界值：</span><br><span class="line"></span><br><span class="line">  - 二维数组中要有查找的数字，数字范围在最大值和最小值之间</span><br><span class="line">  - 数字范围在最大值和最小值之间，但数组中没有</span><br><span class="line">  - 空指针</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">#### 替换空格</span><br></pre></td></tr></table></figure>
请实现一个函数，将一个字符串中的每个空格替换成“%<span class="number">20</span>”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%<span class="number">20</span>Are%<span class="number">20</span>Happy。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 方法一：数组操作，从头往后移动，每个元素移动次数较多 O（n）</span><br><span class="line"></span><br><span class="line">- 方法二：空间换时间</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">     public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">        	 StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">            for (int i &#x3D; 0;i&lt;str.length();i++)&#123;</span><br><span class="line">                char c &#x3D; str.charAt(i);</span><br><span class="line">                if(c &#x3D;&#x3D; &#39; &#39;)&#123;</span><br><span class="line">                    sb.append(&quot;%20&quot;);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return sb.toString();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>方法三：双指针分别指向，从尾向头遍历，首先确定空格数量，开辟字符串空间</p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>{
        <span class="comment">//计算空格的数量</span>
        <span class="keyword">int</span> blankNum=<span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++){
            <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>){
                blankNum++;
            }
        }
        <span class="comment">//记录初始的字符串、插入后的字符串的长度</span>
        <span class="keyword">int</span> originalStringLength=str.length();
        <span class="keyword">int</span> newStringLength=originalStringLength+<span class="number">2</span>*blankNum;
        <span class="comment">//重新设置str的长度</span>
        str.setLength(newStringLength);
        <span class="comment">//定义两个指针，分别指向新旧字符串的末尾</span>
        <span class="keyword">int</span> indexOfOriginalString=originalStringLength-<span class="number">1</span>;
        <span class="keyword">int</span> indexOfNewString=newStringLength-<span class="number">1</span>;
        <span class="comment">//结束条件及确保是否越界</span>
        <span class="keyword">while</span>(indexOfOriginalString&gt;=<span class="number">0</span>&amp;&amp;indexOfNewString&gt;indexOfOriginalString){
            <span class="keyword">if</span>(str.charAt(indexOfOriginalString)==<span class="string">' '</span>){
                <span class="comment">//插入语%20</span>
                str.setCharAt(indexOfNewString--,<span class="string">'0'</span>);
                str.setCharAt(indexOfNewString--,<span class="string">'2'</span>);
                str.setCharAt(indexOfNewString--,<span class="string">'%'</span>);
        }<span class="keyword">else</span>{
              str.setCharAt(indexOfNewString--,str.charAt(indexOfOriginalString));
            }
            indexOfOriginalString--;
        }
        <span class="keyword">return</span> str.toString();
    }
&lt;!--￼<span class="number">6</span>--&gt;
输入一个链表，按链表从尾到头的顺序返回一个ArrayList
&lt;!--￼<span class="number">7</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>当链表很长时，容易栈溢出，栈基于循环实现更加鲁棒</p>
</li>
<li><p>使用反转链表</p>
</li>
</ul>
<hr>
<h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;，则重建二叉树并返回</span><br></pre></td></tr></table></figure>

<ul>
<li><p>老题目了</p>
<ul>
<li>找到先序的第一个位置为根节点</li>
<li>用根节点去中序划分左右子树</li>
<li>左右递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[<span class="number">0</span>], rootIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootVal) &#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        rootIndex =Arrays.binarySearch(inorder,rootVal);</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        root.left = buildTree(Arrays.copyOfRange(preorder, <span class="number">1</span>, <span class="number">1</span> + rootIndex), Arrays.copyOfRange(inorder, <span class="number">0</span>, rootIndex));</span><br><span class="line">        root.right = buildTree(Arrays.copyOfRange(preorder, <span class="number">1</span> + rootIndex, n), Arrays.copyOfRange(inorder, rootIndex + <span class="number">1</span>, n));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(pre) != len(tin):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 取出pre 的第一个值  就是根节点</span></span><br><span class="line">        root = pre[<span class="number">0</span>]</span><br><span class="line">        rootNode = TreeNode(root)</span><br><span class="line">        <span class="comment"># 找到在 tin  中序遍历中的根节点 所在的索引位置</span></span><br><span class="line">        pos = tin.index(root)</span><br><span class="line">        <span class="comment"># 中序遍历的 列表的左右节点 分开 切片 成两个列表</span></span><br><span class="line">        tinLeft = tin[<span class="number">0</span>:pos]</span><br><span class="line">        tinRight = tin[pos + <span class="number">1</span>:]</span><br><span class="line">        <span class="comment"># 前序遍历的 列表的左右节点 分开 切片 成两个列表</span></span><br><span class="line">        preLeft = pre[<span class="number">1</span>:pos + <span class="number">1</span>]</span><br><span class="line">        preRight = pre[pos + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        leftNode = self.reConstructBinaryTree(preLeft, tinLeft)</span><br><span class="line">        rightNode = self.reConstructBinaryTree(preRight, tinRight)</span><br><span class="line"></span><br><span class="line">        rootNode.left = leftNode</span><br><span class="line">        rootNode.right = rightNode</span><br><span class="line">        <span class="keyword">return</span> rootNode</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一定要画图分析</p>
<ul>
<li>节点有右子树：下一个节点为就是右子树最左节点</li>
<li>节点没有右子树：找父节点，该节点为父节点的左孩子，则为所求</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pNode.right:<span class="comment">#如果有右子树</span></span><br><span class="line">            p = pNode.right</span><br><span class="line">            <span class="keyword">while</span> p.left:</span><br><span class="line">                p = p.left</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">while</span> pNode.next:<span class="comment">#无右子树则找第一个当前节点是父节点左孩子的节点</span></span><br><span class="line">            <span class="keyword">if</span> pNode.next.left == pNode:</span><br><span class="line">                <span class="keyword">return</span> pNode.next</span><br><span class="line">            pNode = pNode.next</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<hr>
<h4 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型</span><br></pre></td></tr></table></figure>

<ul>
<li>stack1 为进栈  stack2为出栈</li>
<li>当stack2不为空时，进行出栈，为空时：stack1全部进stack2</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两个队列实现一个栈<ul>
<li>进队正常进队</li>
<li>出队时，队列除了最后一个元素全部进入help队列，删除队列最后一个元素出队</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：两个栈 queue栈进元素，当要出队时，queue元素全部进入help队列，出队，交换队列引用</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoQueuesStack</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">		<span class="keyword">private</span> Queue&lt;Integer&gt; help;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">TwoQueuesStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">			help = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> pushInt)</span> </span>&#123;</span><br><span class="line">			queue.add(pushInt);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stack is empty!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//queue队列全部转移</span></span><br><span class="line">			<span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">				help.add(queue.poll());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> res = queue.poll();</span><br><span class="line">			swap();</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 十分重要***</span></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			Queue&lt;Integer&gt; tmp = help;</span><br><span class="line">			help = queue;</span><br><span class="line">			queue = tmp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）</span><br></pre></td></tr></table></figure>

<p>F(N) = F(N-1)+F(N+2)    N&gt;1     0  N = 0  1N = 1</p>
<ul>
<li><p>递归方法</p>
<ul>
<li><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(n)</span>:</span>
    <span class="keyword">if</span> n&lt;=<span class="number">0</span>:
        <span class="keyword">return</span> <span class="number">0</span>
    <span class="keyword">if</span> n == <span class="number">1</span> :
        <span class="keyword">return</span> <span class="number">1</span>
    <span class="keyword">return</span> solution(n<span class="number">-1</span>)+solution(n<span class="number">-2</span>)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 递归的过程中有很多重复计算，效率较低</span><br><span class="line"></span><br><span class="line">- 面试官期待的实用算法</span><br><span class="line"></span><br><span class="line">  - 避免重复计算，把得到的中间项保存起来</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;python</span><br><span class="line">    def solution(n):</span><br><span class="line">    	if n&lt;&#x3D;0:</span><br><span class="line">            return 0</span><br><span class="line">        if n &#x3D;&#x3D; 1 :</span><br><span class="line">            return 1</span><br><span class="line">        a &#x3D; 0,b &#x3D; 1</span><br><span class="line">        result &#x3D; 0</span><br><span class="line">        for i in range(2,n+1):</span><br><span class="line">            result &#x3D; a + b</span><br><span class="line">            a &#x3D; b</span><br><span class="line">            b &#x3D; result</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>再次优化</p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{
        <span class="keyword">if</span>(n == <span class="number">0</span>){
            <span class="keyword">return</span> <span class="number">0</span>;
        }<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>){
            <span class="keyword">return</span> <span class="number">1</span>;
        }
        <span class="keyword">int</span> sum = <span class="number">1</span>;
        <span class="keyword">int</span> one = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++){
            sum = sum + one;
            one = sum - one;
        }
        <span class="keyword">return</span> sum;
    }
}
&lt;!--￼<span class="number">18</span>--&gt;
一只青蛙一次可以跳上<span class="number">1</span>级台阶，也可以跳上<span class="number">2</span>级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果
&lt;!--￼<span class="number">19</span>--&gt;
一只青蛙一次可以跳上<span class="number">1</span>级台阶，也可以跳上<span class="number">2</span>级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
&lt;!--￼<span class="number">20</span>--&gt;</code></pre>
</li>
<li><p>矩形覆盖</p>
</li>
<li><pre><code>可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">#### 旋转数组中的最小数字</span><br></pre></td></tr></table></figure>
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 这是类似的一个排序数组分成两半：一般情况下，第一个元素大于或者等于最后一个元素， 使用二分查找</span><br><span class="line">  </span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    public int minArray(int[] numbers) &#123;</span><br><span class="line">            int i &#x3D; 0;</span><br><span class="line">            int j &#x3D; numbers.length-1;</span><br><span class="line">            while (i&lt;j)&#123;</span><br><span class="line">                int mid &#x3D; (i+j)&gt;&gt;1;</span><br><span class="line">                if(numbers[mid] &gt;numbers[j])&#123;</span><br><span class="line">                    i &#x3D; mid+1;</span><br><span class="line">                &#125;else if(numbers[mid]&lt;numbers[j])&#123;</span><br><span class="line">                    j &#x3D; mid;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return numbers[i];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


</code></pre></li>
</ul>
</li>
</ul>
<hr>
<h4 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>回溯 </p>
<p>  基本思想： </p>
<p>  0.根据给定数组，初始化一个标志位数组，初始化为false，表示未走过，true表示已经走过，不能走第二次 </p>
<p>  1.根据行数和列数，遍历数组，先找到一个与str字符串的第一个元素相匹配的矩阵元素，进入judge </p>
<p>  2.根据i和j先确定一维数组的位置，因为给定的matrix是一个一维数组 </p>
<p>  3.确定递归终止条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的，这三类情况，都直接false，说明这条路不通 </p>
<p>  4.若k，就是待判定的字符串str的索引已经判断到了最后一位，此时说明是匹配成功的 </p>
<p>  5.下面就是本题的精髓，递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。 </p>
<p>  6.走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。</p>
</li>
<li><p>自己的话：</p>
<ul>
<li>先找到对应元素，置为true，查找周围元素，没找到，该元素不是解集，返回false</li>
<li>边界条件：<ul>
<li>越界</li>
<li>不是对应元素</li>
<li>已经走过了</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//标志位，初始化为false</span></span><br><span class="line">        <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                 <span class="comment">//循环遍历二维数组，找到起点等于str第一个元素的值，再递归判断四周是否有符合条件的----回溯法</span></span><br><span class="line">                 <span class="keyword">if</span>(judge(matrix,i,j,rows,cols,flag,str,<span class="number">0</span>))&#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//judge(初始矩阵，索引行坐标i，索引纵坐标j，矩阵行数，矩阵列数，待判断的字符串，字符串索引初始为0即先判断字符串的第一位)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span>[] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">boolean</span>[] flag,<span class="keyword">char</span>[] str,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先根据i和j计算匹配的第一个元素转为一维数组的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = i*cols+j;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=rows || j&gt;=cols || matrix[index] != str[k] || flag[index] == <span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//若k已经到达str末尾了，说明之前的都已经匹配成功了，直接返回true即可</span></span><br><span class="line">        <span class="keyword">if</span>(k == str.length-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//要走的第一个位置置为true，表示已经走过了</span></span><br><span class="line">        flag[index] = <span class="keyword">true</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//回溯，递归寻找，每次找到了就给k加一，找不到，还原</span></span><br><span class="line">        <span class="keyword">if</span>(judge(matrix,i-<span class="number">1</span>,j,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i+<span class="number">1</span>,j,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i,j-<span class="number">1</span>,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i,j+<span class="number">1</span>,rows,cols,flag,str,k+<span class="number">1</span>)  )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这，说明这一条路不通，还原，再试其他的路径</span></span><br><span class="line">        flag[index] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 &#x3D; 18。但是，它不能进入方格（35,38），因为3+5+3+8 &#x3D; 19。请问该机器人能够达到多少个格子？</span><br></pre></td></tr></table></figure>

<ul>
<li><p>同样是回溯法</p>
<ul>
<li>访问位</li>
<li>边界条件：越界  ， 不满足题意  ， 访问过</li>
<li>回溯前后左右格子数目</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> flag[][] = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols]; <span class="comment">//记录是否已经走过</span></span><br><span class="line">       <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, rows, cols, flag, threshold);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span>[][] flag, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || numSum(i) + numSum(j)  &gt; threshold || flag[i][j] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       flag[i][j] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> helper(i - <span class="number">1</span>, j, rows, cols, flag, threshold)</span><br><span class="line">               + helper(i + <span class="number">1</span>, j, rows, cols, flag, threshold)</span><br><span class="line">               + helper(i, j - <span class="number">1</span>, rows, cols, flag, threshold)</span><br><span class="line">               + helper(i, j + <span class="number">1</span>, rows, cols, flag, threshold)</span><br><span class="line">               + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 数字位数相加</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">numSum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           sum += i%<span class="number">10</span>;</span><br><span class="line">           i = i/<span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h4 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">动态规划求解问题的四个特征： </span><br><span class="line">①求一个问题的最优解； </span><br><span class="line">②整体的问题的最优解是依赖于各个子问题的最优解； </span><br><span class="line">③小问题之间还有相互重叠的更小的子问题； </span><br><span class="line">④从上往下分析问题，从下往上求解问题；</span><br></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// n&lt;=3的情况，m&gt;1必须要分段，例如：3必须分成1、2；1、1、1 ，n=3最大分段乘积是2,</span></span><br><span class="line">    	<span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        下面3行是n&gt;=4的情况，跟n&lt;=3不同，4可以分很多段，比如分成1、3，</span></span><br><span class="line"><span class="comment">        这里的3可以不需要再分了，因为3分段最大才2，不分就是3。记录最大的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;<span class="comment">//记录最大的</span></span><br><span class="line">    	<span class="comment">//j&lt;=i/2是因为1*3和3*1是一样的，没必要计算在内，只要计算到1*3和2*2就好了。然后就是取最大，1*3最大是3,2*2最大是4，那么dp[4]=res就是4。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=i/<span class="number">2</span> ; j++) &#123; <span class="comment">//  i/2 只需算一半</span></span><br><span class="line">                res=Math.max(res,dp[j]*dp[i-j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]=res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>贪婪法</p>
<ul>
<li>每次争取剪长度为三  </li>
<li>2 * 2&gt;3 * 1</li>
</ul>
</li>
<li><pre><code class="java">
<span class="comment">// 不断的切分3</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{
        <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>){
            <span class="keyword">return</span> <span class="number">1</span>;
        }
        <span class="keyword">if</span>(n==<span class="number">3</span>){
            <span class="keyword">return</span> <span class="number">2</span>;
        }
        <span class="keyword">int</span> sum = <span class="number">1</span>;
        <span class="keyword">while</span>(n&gt;<span class="number">4</span>){
            sum*=<span class="number">3</span>;
            n-=<span class="number">3</span>;
        }
        <span class="keyword">return</span> sum*n;

    }
&lt;!--￼<span class="number">30</span>--&gt;


</code></pre>
</li>
</ul>
<hr>
<h4 id="二进制中1的位数"><a href="#二进制中1的位数" class="headerlink" title="二进制中1的位数"></a>二进制中1的位数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>普通做法:按位依次与1，循环左移1，比较次数为32（int）</p>
</li>
<li><p>根据 与运算 定义，设二进制数字 nn ，则有：<br>若 n &amp; 1 = 0n&amp;1=0 ，则 nn 二进制 最右一位 为 00 ；<br>若 n &amp; 1 = 1n&amp;1=1 ，则 nn 二进制 最右一位 为 11 。</p>
</li>
</ul>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{
        <span class="keyword">int</span> count = <span class="number">0</span>;
        <span class="keyword">int</span> flag = <span class="number">1</span>;
        <span class="keyword">while</span>(flag!=<span class="number">0</span>){
            <span class="keyword">if</span>((n&amp;flag)!=<span class="number">0</span>){
                count++;
            }
            flag = flag&lt;&lt;<span class="number">1</span>;
        }
        <span class="keyword">return</span> count;
    }
&lt;!--￼<span class="number">32</span>--&gt;


</code></pre>
</li>
</ul>
<hr>
<h4 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该题看起来比较简单，但是需要考虑多种情况</p>
<ul>
<li>指数是不是为0 或者 负数</li>
<li>基数为0</li>
<li>快速幂的方法</li>
</ul>
<p>普通方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> base == <span class="number">0</span>: <span class="comment">#base为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> exponent == <span class="number">0</span>: <span class="comment">#指数为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> exponent &lt; <span class="number">0</span>: <span class="comment">#指数为负数</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(-exponent):</span><br><span class="line">                result = result * base</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/result</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(exponent):</span><br><span class="line">            result = result * base</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>快速幂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">       <span class="keyword">int</span> exp = Math.abs(n);</span><br><span class="line">       <span class="keyword">while</span>(exp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>((exp&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">               res*=x;</span><br><span class="line">           &#125;</span><br><span class="line">           x*=x;</span><br><span class="line">           exp = exp&gt;&gt;<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> n&gt;<span class="number">0</span>?res:<span class="number">1.0</span>/res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 递归法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> n=Math.abs(exponent);</span><br><span class="line">          <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">              <span class="keyword">return</span> base;</span><br><span class="line">          <span class="keyword">double</span>  result=Power(base,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">          result*=result;</span><br><span class="line">          <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">              result*=base;</span><br><span class="line">          <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">              result=<span class="number">1</span>/result;</span><br><span class="line">          <span class="keyword">return</span> result;            </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<hr>
<h4 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h4><hr>
<h4 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目一：在O（1）时间内删除链表节点</span><br></pre></td></tr></table></figure>

<ul>
<li>平常的删除节点是需要找到要删除的上一个节点，更改指针，删除需要删除的节点，O(N)</li>
<li>该题时间为O（1）<ul>
<li>我们考虑，该节点的下一个节点容易找到，将next节点的值赋值给该节点，删除next节点，更改指针</li>
</ul>
</li>
<li>边界问题<ul>
<li>delete节点位于中间</li>
<li>delete节点位于头尾节点:普通方法</li>
<li>链表只有一个节点</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">       ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       dummy.next = head;</span><br><span class="line">       ListNode cur = dummy;</span><br><span class="line">       <span class="keyword">while</span> (cur.next!=<span class="keyword">null</span>)&#123;  <span class="comment">// 取下一个值，判断next是否为空</span></span><br><span class="line">           <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">               ListNode del = cur.next;</span><br><span class="line">               cur.next = del.next;</span><br><span class="line">               del.next = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目二：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>

<ul>
<li>由于是排序链表，重复节点必相邻</li>
<li>pre，next指针 pre指针指向确定的节点，next指针相当于工作节点，一直指向不为重复的值</li>
<li>增加头节点，为了防止头节点就是重复节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pHead==<span class="keyword">null</span> || pHead.next==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> pHead;&#125;</span><br><span class="line">ListNode Head = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//创建新的头节点</span></span><br><span class="line">Head.next = pHead;</span><br><span class="line">ListNode pre  = Head;</span><br><span class="line">ListNode last = Head.next;</span><br><span class="line"><span class="keyword">while</span> (last!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(last.next!=<span class="keyword">null</span> &amp;&amp; last.val == last.next.val)&#123;</span><br><span class="line">        <span class="comment">// 找到最后的一个相同节点</span></span><br><span class="line">        <span class="keyword">while</span> (last.next!=<span class="keyword">null</span> &amp;&amp; last.val == last.next.val)&#123;</span><br><span class="line">            last = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = last.next;</span><br><span class="line">        last = last.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        last = last.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Head.next;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="调整数组的顺序使奇数位于偶数的前面"><a href="#调整数组的顺序使奇数位于偶数的前面" class="headerlink" title="调整数组的顺序使奇数位于偶数的前面"></a>调整数组的顺序使奇数位于偶数的前面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变</span><br></pre></td></tr></table></figure>

<ul>
<li>比较简单，类似快排中的partition</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j&amp;&amp;(nums[i]%<span class="number">2</span>)!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j&amp;&amp;(nums[j]%<span class="number">2</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="链表环的入口"><a href="#链表环的入口" class="headerlink" title="链表环的入口"></a>链表环的入口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</span><br></pre></td></tr></table></figure>

<ul>
<li>判断是否有环：快慢指针，一个跑两格，一个跑一格，相遇则为有环</li>
<li>找出入口节点：快指针回到头节点，两个一起跑相遇为入口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="comment">// 单节点或者无节点返回错误</span></span><br><span class="line">        <span class="keyword">if</span>(pHead ==<span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义快慢指针</span></span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; slow !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;  <span class="comment">//相遇，链表有环</span></span><br><span class="line">                fast = pHead;  <span class="comment">//快指针回头节点</span></span><br><span class="line">                <span class="keyword">while</span>(fast != slow)&#123;  <span class="comment">//两个一起走</span></span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span>(fast == slow)&#123;  <span class="comment">//再次相遇为环的入口节点</span></span><br><span class="line">                    <span class="keyword">return</span> slow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个链表，反转链表后，输出新链表的表头</span><br></pre></td></tr></table></figure>

<ul>
<li>传统的递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode node = ReverseList(head.next);</span><br><span class="line">                head.next.next = head;</span><br><span class="line">                head.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>三指针 ，断链的话需要保存后一个节点，当前节点指向前一个节点</li>
<li><img src="C:%5CUsers%5C%E5%8D%97%E5%A4%A7%E5%AE%8B%E4%BB%B2%E5%9F%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200227175142167.png" alt="image-20200227175142167"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则</span><br></pre></td></tr></table></figure>

<ul>
<li><p>增加头节点</p>
</li>
<li><pre><code class="java"> <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{
        ListNode head0 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);
        ListNode cur = head0;
        ListNode a = l1;
        ListNode b = l2;
        <span class="keyword">while</span> (a!=<span class="keyword">null</span>&amp;&amp;b!=<span class="keyword">null</span>){
            <span class="keyword">if</span> (a.val&lt;=b.val){
                cur.next = a;
                cur = a;
                a = a.next;
            }<span class="keyword">else</span> {
                cur.next = b;
                cur = b;
                b = b.next;
            }
        }
        <span class="keyword">if</span>(a==<span class="keyword">null</span>){
            cur.next = b;
        }
        <span class="keyword">if</span>(b==<span class="keyword">null</span>){
            cur.next = a;
        }
        <span class="keyword">return</span> head0.next;
    }
&lt;!--￼<span class="number">49</span>--&gt;</code></pre>
</li>
<li><p>非递归实现：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        head = ListNode(<span class="number">0</span>)  //额外头节点</span><br><span class="line">        tmp = head</span><br><span class="line">        <span class="keyword">while</span> pHead1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> pHead2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> pHead1.val &lt;= pHead2.val:</span><br><span class="line">                tmp.next = pHead1</span><br><span class="line">                pHead1 = pHead1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp.next = pHead2</span><br><span class="line">                pHead2 = pHead2.next</span><br><span class="line">            tmp = tmp.next  //这里需要注意</span><br><span class="line">        <span class="keyword">if</span> pHead1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            tmp.next = pHead2</span><br><span class="line">        <span class="keyword">elif</span> pHead2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            tmp.next = pHead1</span><br><span class="line">        <span class="keyword">return</span> head.next   //返回为额外头节点的下一个</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</span><br></pre></td></tr></table></figure>

<ul>
<li>首先在A中找B的根节点</li>
<li>找到后判断其子树</li>
<li>注意的是：与二叉树相关有大量的指针操作，判断是否为空</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span>||B ==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(A.val == B.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> isSub(A,B);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSubStructure(A.left, B)||isSubStructure(A.right, B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSub</span><span class="params">(TreeNode x,TreeNode y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="keyword">null</span>)&#123; <span class="comment">//  y搜索完了 未找到匹配项</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123; <span class="comment">// x 搜索完了 出错</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x.val!=y.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSub(x.left,y.left)&amp;&amp;isSub(x.right,y.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="树的镜像"><a href="#树的镜像" class="headerlink" title="树的镜像"></a>树的镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作给定的二叉树，将其变换为源二叉树的镜像。</span><br></pre></td></tr></table></figure>

<ul>
<li>交换根节点的左右子节点</li>
<li>递归子树</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>||(root.left == <span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        mirrorTree(root.left);</span><br><span class="line">        mirrorTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非递归，自定义栈实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 空树</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右均为空</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用来遍历的栈</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line"> </span><br><span class="line">    stack.push(root);</span><br><span class="line"> </span><br><span class="line">    TreeNode curNode;</span><br><span class="line">    TreeNode tempNode;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 深度优先</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      curNode = stack.pop();</span><br><span class="line">      <span class="keyword">if</span>(curNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(curNode.left == <span class="keyword">null</span> &amp;&amp; curNode.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 交换</span></span><br><span class="line">      tempNode = curNode.left;</span><br><span class="line">      curNode.left = curNode.right;</span><br><span class="line">      curNode.right = tempNode;</span><br><span class="line">      stack.push(curNode.left);</span><br><span class="line">      stack.push(curNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</span><br></pre></td></tr></table></figure>

<ul>
<li>比较左右子树的值，递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSym(pRoot.left,pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSym</span><span class="params">(TreeNode left,TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSym(left.left,right.right)&amp;&amp; isSym(left.right,right.left);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> down = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 最上面一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=left;col&lt;=right;col++)&#123;</span><br><span class="line">                list.add(matrix[up][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向下逼近</span></span><br><span class="line">            up++;</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(up &gt; down)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最右边一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=up;row&lt;=down;row++)&#123;</span><br><span class="line">                list.add(matrix[row][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向左逼近</span></span><br><span class="line">            right--;</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最下面一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=right;col&gt;=left;col--)&#123;</span><br><span class="line">                list.add(matrix[down][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向上逼近</span></span><br><span class="line">            down--;</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(up &gt; down)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最左边一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=down;row&gt;=up;row--)&#123;</span><br><span class="line">                list.add(matrix[row][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向右逼近</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="包含min函数的最小栈"><a href="#包含min函数的最小栈" class="headerlink" title="包含min函数的最小栈"></a>包含min函数的最小栈</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</span><br><span class="line">注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。</span><br></pre></td></tr></table></figure>

<ul>
<li>维护一个辅助栈，栈容量与原始栈相同：每次加元素，辅助栈始终添加最小值到栈顶，出栈一起出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty() || node &lt; stack2.peek())&#123;</span><br><span class="line">            stack2.push(node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack2.push(stack2.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1.pop();</span><br><span class="line">        stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>每次遇到最小的元素在压辅助栈</p>
</li>
<li><pre><code class="java">Stack&lt;Integer&gt; A, B;
    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>{
        A = <span class="keyword">new</span> Stack&lt;&gt;();
        B = <span class="keyword">new</span> Stack&lt;&gt;();
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
        A.add(x);
        <span class="keyword">if</span>(B.empty() || B.peek() &gt;= x)
            B.add(x);
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{
        <span class="keyword">if</span>(A.pop().equals(B.peek()))
            B.pop();
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> A.peek();
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> B.peek();
    }

&lt;!--￼<span class="number">62</span>--&gt;
输入两组整数序列，判断是否为压栈和弹出序列
&lt;!--￼<span class="number">63</span>--&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a>从上到下打印二叉树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从上往下打印出二叉树的每个节点，同层节点从左至右打印  （层次遍历）</span><br></pre></td></tr></table></figure>

<ul>
<li>利用队列，每次取出顶端元素打印</li>
<li>每次打印一个节点得时候，如果有子节点，则把子节点放入队列末尾，头部取出打印</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.add(root);</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">           TreeNode node = queue.poll();</span><br><span class="line">           res.add(node.val);</span><br><span class="line">           <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.add(node.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.add(node.right);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (Integer n :</span><br><span class="line">               res) &#123;</span><br><span class="line">           r[index++] = n;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        treeNodeTmp = [root]</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">while</span> treeNodeTmp:</span><br><span class="line">            tmpNode = treeNodeTmp[<span class="number">0</span>]</span><br><span class="line">            ret.append(tmpNode.val)</span><br><span class="line">            <span class="keyword">if</span> tmpNode.left:</span><br><span class="line">                treeNodeTmp.append(tmpNode.left)</span><br><span class="line">            <span class="keyword">if</span> tmpNode.right:</span><br><span class="line">                treeNodeTmp.append(tmpNode.right)</span><br><span class="line">            <span class="keyword">del</span> treeNodeTmp[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="多行打印二叉树"><a href="#多行打印二叉树" class="headerlink" title="多行打印二叉树"></a>多行打印二叉树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行</span><br></pre></td></tr></table></figure>

<ul>
<li>因为每层都是独立的，所以建立两个栈，一层节点的子节点全部放入一个栈交替进行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 注意这里每次循环size()，发生变化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self,pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nodeStack = [pRoot]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> nodeStack:</span><br><span class="line">            res = []</span><br><span class="line">            nextStack = [] <span class="comment"># 辅助栈存放下一层结点</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nodeStack:</span><br><span class="line">                res.append(i.val)</span><br><span class="line">                <span class="keyword">if</span> i.left:</span><br><span class="line">                    nextStack.append(i.left)</span><br><span class="line">                <span class="keyword">if</span> i.right:</span><br><span class="line">                    nextStack.append(i.right)</span><br><span class="line">            nodeStack = nextStack <span class="comment">#辅助栈存为主栈</span></span><br><span class="line">            result.append(res) <span class="comment">#添加该层结点</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="按之字形打印二叉树"><a href="#按之字形打印二叉树" class="headerlink" title="按之字形打印二叉树"></a>按之字形打印二叉树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</span><br></pre></td></tr></table></figure>

<ul>
<li>奇数反转</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">           List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">               TreeNode node = queue.poll();</span><br><span class="line">               tmp.add(node.val);</span><br><span class="line">               <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">               <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">1</span>) Collections.reverse(tmp);</span><br><span class="line">           res.add(tmp);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两个栈：一个奇数栈 一个偶数栈</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        <span class="keyword">int</span> layer = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//s1存奇数层节点</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s1 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        s1.push(pRoot);</span><br><span class="line">        <span class="comment">//s2存偶数层节点</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s2 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">         </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> (!s1.empty() || !s2.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layer%<span class="number">2</span> != <span class="number">0</span>) &#123;   <span class="comment">//  n &amp; 1 == 0，则n为偶数</span></span><br><span class="line">                ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">while</span> (!s1.empty()) &#123;</span><br><span class="line">                    TreeNode node = s1.pop();</span><br><span class="line">                    <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        temp.add(node.val);</span><br><span class="line">                        System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">                        s2.push(node.left);</span><br><span class="line">                        s2.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!temp.isEmpty()) &#123;</span><br><span class="line">                    list.add(temp);</span><br><span class="line">                    layer++;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">while</span> (!s2.empty()) &#123;</span><br><span class="line">                    TreeNode node = s2.pop();</span><br><span class="line">                    <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        temp.add(node.val);</span><br><span class="line">                        System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">                        s1.push(node.right);</span><br><span class="line">                        s1.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!temp.isEmpty()) &#123;</span><br><span class="line">                    list.add(temp);</span><br><span class="line">                    layer++;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</span><br></pre></td></tr></table></figure>

<ul>
<li>首先找到右子树开始的节点</li>
<li>然后对右子树节点依次进行判断</li>
<li>依次遍历左右子树</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = sequence.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> root = sequence[len-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i]&gt;root) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;len-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[j]&lt;root) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> left=<span class="keyword">true</span>,right=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>) left=VerifySquenceOfBST(Arrays.copyOfRange(sequence,<span class="number">0</span>,i));<span class="comment">//左闭右开</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len-<span class="number">1</span>)  right=VerifySquenceOfBST(Arrays.copyOfRange(sequence,i,len-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>DFS</p>
</li>
<li><pre><code class="java">LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();
    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;(); 
    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) {
        recur(root, sum);
        <span class="keyword">return</span> res;
    }
    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root, <span class="keyword">int</span> tar)</span> </span>{
        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;
        path.add(root.val);
        tar -= root.val;
        <span class="keyword">if</span>(tar == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)
            res.add(<span class="keyword">new</span> LinkedList(path));
        recur(root.left, tar);
        recur(root.right, tar);
        path.removeLast();
    }

&lt;!--￼<span class="number">76</span>--&gt;
</code></pre>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        self.sums = expectNumber</span><br><span class="line">        self.DFS(root, result, [root.val])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self, root, result, path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span> <span class="keyword">and</span> sum(path) == self.sums:</span><br><span class="line">            result.append(path)</span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">            self.DFS(root.left, result, path+[root.left.val])</span><br><span class="line">        <span class="keyword">if</span> root.right !=<span class="literal">None</span>:</span><br><span class="line">            self.DFS(root.right,result,path+[root.right.val])</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="将二叉树转化为双向循环链表"><a href="#将二叉树转化为双向循环链表" class="headerlink" title="将二叉树转化为双向循环链表"></a>将二叉树转化为双向循环链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Node pre,head,tail;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       inOrder(root.left);</span><br><span class="line">       root.left = pre;</span><br><span class="line">       <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">           head = root;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           pre.right = root;</span><br><span class="line">       &#125;</span><br><span class="line">       pre = root;</span><br><span class="line">       tail = root;</span><br><span class="line">       inOrder(root.right);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       inOrder(root);</span><br><span class="line">       tail.right = head;</span><br><span class="line">       head.left = tail;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</span><br></pre></td></tr></table></figure>

<ul>
<li><p>投机取巧</p>
</li>
<li><pre><code class="java">mport java.util.HashMap;
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span>
<span class="function">    </span>{
        HashMap&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;RandomListNode, RandomListNode&gt;();
        RandomListNode cur = pHead;
        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {
            map.put(cur, <span class="keyword">new</span> RandomListNode(cur.label));
            cur = cur.next;
        }
        cur = pHead;
        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        <span class="keyword">return</span> map.get(pHead);
    }
}
&lt;!--￼<span class="number">80</span>--&gt;
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
&lt;!--￼<span class="number">81</span>--&gt;




</code></pre>
</li>
</ul>
<h4 id="数组中超过一半的数字"><a href="#数组中超过一半的数字" class="headerlink" title="数组中超过一半的数字"></a>数组中超过一半的数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>排序取中间</p>
</li>
<li><p>hash表</p>
</li>
<li><p>patition（改变数组）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">if</span>(array.length&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">int</span> end  = length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = length&gt;&gt;<span class="number">1</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> index = Partition(array,start,end);</span><br><span class="line">        <span class="keyword">while</span>(index!=middle)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index&gt;middle)&#123;</span><br><span class="line">                index = Partition(array,start,index-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                index = Partition(array,index+<span class="number">1</span>,end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = array[middle];</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == result)</span><br><span class="line">                times++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(times*<span class="number">2</span>&lt;length)&#123;</span><br><span class="line">            System.out.println(times);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = (array[start]+array[end])/<span class="number">2</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">while</span>(array[end]&gt;flag)&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array,start,end);</span><br><span class="line">            <span class="keyword">while</span>(array[start]&lt;=flag)&#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp =array[num1];</span><br><span class="line">        array[num1] =array[num2];</span><br><span class="line">        array[num2] =temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>根据数组特点</p>
<ul>
<li>方法：我们在遍历数组的时候，保存两个值，一个是数组中的数字，另一个是次数，当遍历到下一个数字的时候，如果和上一次的数字一样则次数加1，如果不一样次数减一(相当于抵消了)，如果次数为0了，那就保存下一个数字，并把次数设置为1，因为我们要找的数字如果存在最后一定是把次数设置为1的那个数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers.empty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//[1,2,3,2,4,2,5,2,3]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;numbers.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">0</span>)&#123;</span><br><span class="line">            temp = numbers[i];</span><br><span class="line">            time = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp == numbers[i])&#123;</span><br><span class="line">            ++time;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            --time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 temp 是否符合要求</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp == numbers[i])&#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; numbers.<span class="built_in">size</span>()/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
</li>
</ul>
<h4 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,</span><br></pre></td></tr></table></figure>

<ul>
<li>维护一个最大堆，每次加入元素判断是否小于根节点，最终输出整个最大堆</li>
<li>java中使用优先队列来实现堆，此时重写优先队列中的比较函数</li>
<li>该方法常用于海量数据的获取  topk问题   <strong>O（nlogk</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> len = input.length;</span><br><span class="line">       <span class="keyword">if</span>(k&gt;len||k==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list;</span><br><span class="line">       &#125;</span><br><span class="line">       PriorityQueue&lt;Integer&gt; maxheap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> o2-o1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(maxheap.size()!=k)&#123;  <span class="comment">//maxheap不为k时不断的放入元素</span></span><br><span class="line">               maxheap.offer(input[i]);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (maxheap.peek()&gt;input[i])&#123;  <span class="comment">//等于k时 判断堆顶元素</span></span><br><span class="line">               maxheap.poll();</span><br><span class="line">             </span><br><span class="line">               maxheap.offer(input[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(Integer n:maxheap)&#123; <span class="comment">//遍历取出</span></span><br><span class="line">           list.add(n);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于快速排序（会改变原数组值）</li>
<li>思想：patition使得第k个元素的左边比他下，右边比他大    <strong>O（N）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = partition(input,start,end);</span><br><span class="line">        <span class="keyword">while</span>(index!=k-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;k-<span class="number">1</span>)&#123;</span><br><span class="line">        	end = index - <span class="number">1</span>;</span><br><span class="line">        	index = partition(input,start,end);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">            index = partition(input,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//输出前k个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数</span><br></pre></td></tr></table></figure>

<ul>
<li><p>问题在于该数据流是一直变化的</p>
</li>
<li><p>数据流排好序的</p>
</li>
<li><p>采用最大堆+最小堆的方式   堆中插入数据效率为O（logn）得到堆顶元素为O（1）</p>
</li>
<li><p>因为要求的是中位数，那么这两个堆，<strong>大顶堆用来存较小的数，从大到小排列</strong>；</p>
<p><strong>小顶堆存较大的数，从小到大的顺序排序</strong>，显然中位数就是大顶堆的根节点与小顶堆的根节点和的平均数。</p>
</li>
<li><p>实现细节：为了公平，规定偶数插入大顶堆，奇数插入小顶堆。再把相应最大最小的数添加到彼此的堆中</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小顶堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//大顶堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="number">15</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//记录偶数个还是奇数个</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每次插入小顶堆的是当前大顶堆中最大的数</span></span><br><span class="line">    <span class="comment">//每次插入大顶堆的是当前小顶堆中最小的数</span></span><br><span class="line">    <span class="comment">//这样保证小顶堆中的数永远大于等于大顶堆中的数</span></span><br><span class="line">    <span class="comment">//中位数就可以方便地从两者的根结点中获取了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//个数为偶数的话，则先插入到大顶堆，然后将大顶堆中最大的数插入小顶堆中</span></span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">            <span class="keyword">int</span> max = maxHeap.poll();</span><br><span class="line">            minHeap.offer(max);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//个数为奇数的话，则先插入到小顶堆，然后将小顶堆中最小的数插入大顶堆中</span></span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">            <span class="keyword">int</span> min = minHeap.poll();</span><br><span class="line">            maxHeap.offer(min);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前为偶数个，则取小顶堆和大顶堆的堆顶元素求平均</span></span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek() + maxHeap.peek())/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前为奇数个，则直接从小顶堆中取元素即可</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如:&#123;6,-3,-2,7,-15,1,2,2&#125;,连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</span><br></pre></td></tr></table></figure>

<ul>
<li>动态规划三步走</li>
</ul>
<ol>
<li>确定dp[]数组含义：截止这个数字为止，连续子数组最大的值</li>
<li>状态转移方程：dp[i] = max(dp[i-1]+array[i],array[i]) <ul>
<li>前一个数字的最大和与该处数字比较，取最大值</li>
</ul>
</li>
<li>base case：好像没啥，注意结果定义为数组第一个值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i] = math.max(dp[i-<span class="number">1</span>]+array[i],array[i])</span><br><span class="line">              max = math.max(max,dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1–n整数中1出现的次数"><a href="#1–n整数中1出现的次数" class="headerlink" title="1–n整数中1出现的次数"></a>1–n整数中1出现的次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个 m*n 的棋盘中的每一个格都放一个礼物，每个礼物都有一定的价值（价值大于0）.你可以从棋盘的左上角开始拿各种里的礼物，并每次向左或者向下移动一格，直到到达棋盘的右下角。给定一个棋盘及上面个的礼物，请计算你最多能拿走多少价值的礼物？</span><br></pre></td></tr></table></figure>

<img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20200303214920868.png" alt="image-20200303214920868" style="zoom:50%;" />

<ol>
<li><p>dp[]数组含义：该格子的最大价值</p>
</li>
<li><p>转移方程：f(i,j) = max(f(i-1,j), f(i,j-1)) + gift[i,j]；</p>
</li>
<li><p>base case：可以初始化第一行，第一列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxValue1</span><span class="params">(<span class="keyword">int</span>[][] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> rows = arr.length; <span class="comment">//行</span></span><br><span class="line">		<span class="keyword">int</span> cols = arr[<span class="number">0</span>].length; <span class="comment">//列</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span>[][] maxValue = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">					up = maxValue[i-<span class="number">1</span>][j];</span><br><span class="line">				<span class="keyword">if</span>(j&gt;<span class="number">0</span>)</span><br><span class="line">					left = maxValue[i][j-<span class="number">1</span>];</span><br><span class="line">			maxValue[i][j] = Math.max(up, left) + arr[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> maxValue[rows-<span class="number">1</span>][cols-<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ul>
<li><p>优化：二维数组转为一维数组</p>
</li>
<li><p>只保留相邻行</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxValue2</span><span class="params">(<span class="keyword">int</span>[][] arr)</span> </span>{
        <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length==<span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">0</span>;

        <span class="keyword">int</span> rows = arr.length;
        <span class="keyword">int</span> cols = arr[<span class="number">0</span>].length;
        <span class="keyword">int</span>[] maxValue = <span class="keyword">new</span> <span class="keyword">int</span>[cols];
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++) {
            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++) {
                <span class="keyword">int</span> left = <span class="number">0</span>;
                <span class="keyword">int</span> up = <span class="number">0</span>;
                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)
                    up = maxValue[j];
                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)
                    left = maxValue[j-<span class="number">1</span>];
                maxValue[j] = Math.max(up, left)+arr[i][j];
            }
        }
        <span class="keyword">return</span> maxValue[cols-<span class="number">1</span>];
    }
&lt;!--￼<span class="number">95</span>--&gt;
请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。例如，在字符串中”arabcacfr”，最长非重复子字符串为”acfr”，长度为<span class="number">4</span>。
&lt;!--￼<span class="number">96</span>--&gt;</code></pre>
</li>
<li><p><img src="https://pic4.zhimg.com/80/v2-ec6f1e5c8bd7902a4d6b2ffdf024e54f_1440w.jpg" alt="img"></p>
</li>
<li><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span>
        <span class="comment"># 保存每个字符上一次出现的位置索引</span>
        pos = {}
        l = <span class="number">0</span>
        maxlen = <span class="number">0</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):
            <span class="keyword">if</span> pos.get(s[i]) <span class="keyword">is</span> <span class="literal">None</span>:                
                l += <span class="number">1</span>                
            <span class="keyword">else</span>:
                maxlen = max(l, maxlen)
                d = i - pos[s[i]]
                l = d <span class="keyword">if</span> d&lt;=l <span class="keyword">else</span> l+<span class="number">1</span>
            pos[s[i]] = i       
        <span class="keyword">return</span> max(l, maxlen)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 借用arraylist</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;java</span><br><span class="line">  public static int lengthOfLongestSubstring(String str) &#123;</span><br><span class="line">  		if(str.length()&#x3D;&#x3D;0)</span><br><span class="line">  			return 0;</span><br><span class="line">  		</span><br><span class="line">  		int maxLength&#x3D;1;</span><br><span class="line">  		List&lt;Character&gt; list &#x3D; new ArrayList&lt;Character&gt;();</span><br><span class="line">  		list.add(str.charAt(0));</span><br><span class="line">  		for(int i&#x3D;1;i&lt;str.length();i++) &#123;</span><br><span class="line">  			if(list.contains(str.charAt(i))) &#123;</span><br><span class="line">  				&#x2F;&#x2F;返回与当前字符相同字符的索引</span><br><span class="line">  				int index &#x3D; list.indexOf(str.charAt(i)); </span><br><span class="line">  				list &#x3D; list.subList(index+1, list.size());</span><br><span class="line">  				list.add(str.charAt(i));</span><br><span class="line">  				maxLength &#x3D; Math.max(maxLength, list.size());</span><br><span class="line">  			&#125;else &#123;</span><br><span class="line">  				list.add(str.charAt(i));</span><br><span class="line">  				maxLength &#x3D; Math.max(maxLength, list.size());</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		return maxLength;</span><br><span class="line">  	&#125;</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
<hr>
<h4 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在字符串中找出第一个只出现一次的字符</span><br></pre></td></tr></table></figure>

<ul>
<li><p>笨办法：从头开始遍历，比较每次元素在后续是否有相同 为O（n^2）</p>
</li>
<li><p>hash表：java hashmap忽略</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">findFirstNoRepeatChar</span><span class="params">(String str)</span></span>{
        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.trim().length()==<span class="number">0</span>){
            <span class="keyword">return</span> <span class="string">'0'</span>;
        }
        <span class="keyword">int</span> []counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];
        str = str.toLowerCase(); <span class="comment">//防止出现大小写混乱的情况</span>
        <span class="keyword">int</span> len = str.length();
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++){
            counts[str.charAt(i) - <span class="string">'a'</span>]++;
        }
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++){
            <span class="keyword">if</span>(counts[str.charAt(i) - <span class="string">'a'</span>] == <span class="number">1</span>){
                <span class="keyword">return</span> str.charAt(i);
            }
        }
        <span class="keyword">return</span> <span class="string">'0'</span>;
    }
&lt;!--￼<span class="number">99</span>--&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</span><br></pre></td></tr></table></figure>

<ul>
<li>归并排序的思想 时间复杂度为O（nlogn）</li>
<li>外部排序，需要额外O（n）空间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 使用递归</span></span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end)<span class="keyword">return</span>; <span class="comment">//结束边界</span></span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">        MergeSort(array, start, mid);</span><br><span class="line">        MergeSort(array, mid+<span class="number">1</span>, end);</span><br><span class="line">        MergeOne(array, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MergeOne</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end-start+<span class="number">1</span>];  <span class="comment">//引入额外空间</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,i=start,j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;= end)&#123;</span><br><span class="line"><span class="comment">//如果前面的元素小于后面的不能构成逆序对</span></span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt;= array[j])</span><br><span class="line">                temp[k++] = array[i++];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果前面的元素大于后面的，那么在前面元素之后的元素都能和后面的元素构成逆序对</span></span><br><span class="line">                temp[k++] = array[j++];</span><br><span class="line">                cnt = (cnt + (mid-i+<span class="number">1</span>))%<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;= mid)</span><br><span class="line">            temp[k++] = array[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=end)</span><br><span class="line">            temp[k++] = array[j++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;k; l++)&#123;</span><br><span class="line">            array[start+l] = temp[l];  <span class="comment">//辅助数组存入原数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        MergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</span><br></pre></td></tr></table></figure>

<ol>
<li>可以使用两个栈，依次弹出元素直到元素不相同     时间复杂度为O(M+N)</li>
<li>长的链表先走k步，两个链表在从头走    时间复杂度为O(M+N)</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">     <span class="comment"># write code here</span></span><br><span class="line">     pTmp1 = pHead1</span><br><span class="line">     pTmp2 = pHead2</span><br><span class="line">     <span class="comment">#当链表1 和链表2 同时存在的时候</span></span><br><span class="line">     <span class="keyword">while</span> pTmp1 <span class="keyword">and</span> pTmp2:</span><br><span class="line">         <span class="comment">#当两个链表移动到值相同的时候，这个位置就是结点，直接返回pTmp1或pTmp2</span></span><br><span class="line">         <span class="keyword">if</span> pTmp1 == pTmp2:</span><br><span class="line">             <span class="keyword">return</span> pTmp1</span><br><span class="line">         <span class="comment">#移动指针的位置，两个同时移动，</span></span><br><span class="line">         pTmp1 = pTmp1.next</span><br><span class="line">         pTmp2 = pTmp2.next</span><br><span class="line"></span><br><span class="line">     <span class="comment">#第一个参数给比较短的那个链表的值</span></span><br><span class="line">     <span class="comment">#第二个参数给比较长的链表的值</span></span><br><span class="line">     <span class="comment">#第三个参数是比较短的那个链表头</span></span><br><span class="line">     <span class="comment">#第四个参数是比较长的那个链表头</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">findEqual</span><span class="params">(longPointer, shorPointer, longHead, shortHead)</span>:</span></span><br><span class="line">         k = <span class="number">0</span></span><br><span class="line">         <span class="comment"># 寻找出链表长度之间的差值，让长的链表继续走，直到链表走完为止，走了多少步，就说明，两个链表之间的差值是多少。</span></span><br><span class="line">         <span class="keyword">while</span> longPointer:</span><br><span class="line">             longPointer = longPointer.next</span><br><span class="line">             k += <span class="number">1</span></span><br><span class="line">         <span class="comment">#然后：</span></span><br><span class="line">         <span class="comment"># 先让长的那个去走k步</span></span><br><span class="line">         longPointer = longHead</span><br><span class="line">         shortPointer = shortHead</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">             longPointer = longPointer.next</span><br><span class="line">         <span class="comment">#长的走k步之后，再让两个链表一起移动，直到两个链表移动的位置的值相等为止，那么这个点就是 两个链表的第一个公共结点。</span></span><br><span class="line">         <span class="keyword">while</span> longPointer != shortPointer:</span><br><span class="line">             longPointer = longPointer.next</span><br><span class="line">             shortPointer = shortPointer.next</span><br><span class="line">         <span class="keyword">return</span> shortPointer</span><br><span class="line">     <span class="comment">#如果两个链表不一样的长度，那么假设是 第一个链表长度长，第二个链表已经走完了，结束了，那么第一个链表还没有走完，那么就调用我们封装好的函数，或者是看下面注释的代码。</span></span><br><span class="line">     <span class="keyword">if</span> pTmp1:</span><br><span class="line">         <span class="keyword">return</span> findEqual(pTmp1,pTmp2,pHead1,pHead2)</span><br><span class="line">     <span class="keyword">if</span> pTmp2:</span><br><span class="line">         <span class="keyword">return</span> findEqual(pTmp2, pTmp1, pHead2, pHead1)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="在排序数组中查找数字"><a href="#在排序数组中查找数字" class="headerlink" title="在排序数组中查找数字"></a>在排序数组中查找数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目一：统计一个数字在排序数组中出现的次数。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>hash法   O（n）</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>{
         Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();
        <span class="comment">//常用的map赋值</span>
        <span class="keyword">int</span> length = array.length;
        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;length;i++){
            <span class="keyword">if</span>(!map.containsKey(array[i])){
                map.put(array[i],<span class="number">1</span>);
            }<span class="keyword">else</span> {
                map.put(array[i],map.get(array[i])+<span class="number">1</span>);
            }
        }
        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {
            <span class="keyword">if</span>(entry.getKey()==k)
                <span class="keyword">return</span> entry.getValue();
        }
        <span class="keyword">return</span> <span class="number">0</span>;
    }
&lt;!--￼<span class="number">105</span>--&gt;
</code></pre>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目二：0-n-1中缺失的数字，数组排序</span><br></pre></td></tr></table></figure>

<ul>
<li><p>题目转化为排序数组中第一个与下标不一致的元素</p>
</li>
<li><p>二分法：</p>
<ul>
<li>当下标一样，说明该值左边排好序，找右边</li>
<li>不一样：<ul>
<li>如果前一个数字为一致元素，则该下标为查找值</li>
<li>如果前一个不为一致元素，则查找左半边</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMissNumber</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num.length() == <span class="number">0</span> || num == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = num.length();</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[mid]!=mid)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid == <span class="number">0</span>||num[mid-<span class="number">1</span>]==mid-<span class="number">1</span>)&#123;<span class="comment">//mid为0无左值</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == length)&#123;<span class="comment">//找到最右边</span></span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目三：找出单调递增数组中数值和下标相等的元素</span><br></pre></td></tr></table></figure>

<ul>
<li>二分</li>
<li>mid  &gt;  下标：后半边全部大于</li>
<li>mid  &lt;  下标：左半边全部小于</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumSameAsIndex</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = num.length();</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = num.length();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid == num[mid])&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid &gt; num[mid])&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a>二叉搜索树的第k大节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>二叉树的中序遍历为顺序</p>
</li>
<li><p>一个额外空间存放二叉树的中序遍历</p>
</li>
<li><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span>
        <span class="comment"># write code here</span>
        res = []
        <span class="comment">#中序遍历</span>
        <span class="function"><span class="keyword">def</span> <span class="title">preOrder</span><span class="params">(pRoot)</span>:</span>
            <span class="keyword">if</span> pRoot == <span class="literal">None</span>:
                <span class="keyword">return</span> <span class="literal">None</span>
            preOrder(pRoot.left)
            res.append(pRoot)
            preOrder(pRoot.right)

        preOrder(pRoot)
        <span class="keyword">if</span> len(res)&lt;k <span class="keyword">or</span> k&lt;<span class="number">1</span>:
            <span class="keyword">return</span> <span class="literal">None</span>
        <span class="keyword">return</span> res[k<span class="number">-1</span>]
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 非递归中序</span><br><span class="line"></span><br><span class="line">- 把左节点依次压栈，弹出节点找右子树</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;java</span><br><span class="line">  TreeNode KthNode(TreeNode root, int k) &#123;</span><br><span class="line">          if(root &#x3D;&#x3D; null || k &#x3D;&#x3D; 0) return null;</span><br><span class="line">          int count &#x3D; 0;</span><br><span class="line">          Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">          while (root !&#x3D; null || ! stack.isEmpty()) &#123;</span><br><span class="line">              while (root !&#x3D; null) &#123;</span><br><span class="line">                  stack.push(root);</span><br><span class="line">                  root &#x3D; root.left;</span><br><span class="line">              &#125;</span><br><span class="line">              root &#x3D; stack.pop();</span><br><span class="line">              count ++;</span><br><span class="line">              if(count &#x3D;&#x3D; k) return root;</span><br><span class="line">              root &#x3D; root.right;</span><br><span class="line">          &#125;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<hr>
<h4 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最大深度等于   max(left,right)+1</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>{
        <span class="keyword">if</span>(root==<span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="number">0</span>;
        }<span class="keyword">else</span> {
            <span class="keyword">int</span> left = TreeDepth(root.left);
            <span class="keyword">int</span> right = TreeDepth(root.right);
            <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;
        }
    }
&lt;!--￼<span class="number">113</span>--&gt;


</code></pre>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断是否平衡二叉树</span><br></pre></td></tr></table></figure>

<ul>
<li><p>普通方法存在大量重复</p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> classSolution {
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>{
        <span class="keyword">if</span>(root == <span class="keyword">null</span>) {
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="keyword">return</span> Math.abs(maxDepth(root.left) - maxDepth(root.right)) &lt;= <span class="number">1</span> &amp;&amp;
            IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>{
        <span class="keyword">if</span>(root == <span class="keyword">null</span>) {
            <span class="keyword">return</span> <span class="number">0</span>;
        }
        <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
}
&lt;!--￼<span class="number">115</span>--&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="数组中出现的数字"><a href="#数组中出现的数字" class="headerlink" title="数组中出现的数字"></a>数组中出现的数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目一：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字</span><br></pre></td></tr></table></figure>

<ul>
<li><p>无聊的hash法</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>{
        <span class="keyword">int</span> length = array.length;
        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();
        <span class="comment">//常用的map赋值</span>
        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;length;i++){
            <span class="keyword">if</span>(!map.containsKey(array[i])){
                map.put(array[i],<span class="number">1</span>);
            }<span class="keyword">else</span> {
                map.put(array[i],map.get(array[i])+<span class="number">1</span>);
            }
        }
        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];
        <span class="keyword">int</span> k =<span class="number">0</span>;
        <span class="comment">//取出map集合中的key value 注意方法map.entryset()</span>
        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {
            <span class="keyword">if</span>(entry.getValue() == <span class="number">1</span>){
                num[k] = entry.getKey();
                k++;
            }
        }
        num1[<span class="number">0</span>]=num[<span class="number">0</span>];
        num2[<span class="number">0</span>]=num[<span class="number">1</span>];
    }
&lt;!--￼<span class="number">117</span>--&gt;


</code></pre>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目二：一个整型数组里除了一个数字之外，其他的数字都出现了三次。请写程序找出这一个只出现一次的数字</span><br></pre></td></tr></table></figure>

<ol>
<li>计算数组中所有数字对应的二进制数各个位置的和，即就是计算数组中所有数字对应的二进制数各个位置出现1的次数</li>
<li>若某一位上的数不能被3整除，则证明目标数字的这一位肯定为1</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindNumberApperingOnce</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number.size() &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bitSum[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//数组长度固定为O（1）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> bitmask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;=<span class="number">0</span>; j--)<span class="comment">//从低位开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitmask&amp;number[i])bitSum[j]++;</span><br><span class="line">            bitmask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)<span class="comment">//0是高位</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = result &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        result += bitSum[i] % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="和为s的数字"><a href="#和为s的数字" class="headerlink" title="和为s的数字"></a>和为s的数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>排序数组  二分</p>
</li>
<li><pre><code class="java"> <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>{
         ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();
        <span class="keyword">if</span> (array == <span class="keyword">null</span> )
            <span class="keyword">return</span> list;
        <span class="keyword">int</span> left = <span class="number">0</span>;
        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;
        <span class="keyword">while</span> (left &lt; right) {
            <span class="keyword">int</span> s = array[left] + array[right];
            <span class="keyword">if</span> (s == sum) {
                list.add(array[left]);
                list.add(array[right]);
                <span class="keyword">return</span> list;
            }<span class="keyword">else</span> {
                <span class="keyword">if</span> (s &gt; sum) {
                    right--;
                }<span class="keyword">else</span> {
                    left++;
                }
            }
        }
        <span class="keyword">return</span> list;
    }
&lt;!--￼<span class="number">121</span>--&gt;
输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
&lt;!--￼<span class="number">122</span>--&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目一：反转单词顺序</span><br></pre></td></tr></table></figure>

<ol>
<li>反转句子所有单词</li>
<li>反转每个单词</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">char</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || start &lt; <span class="number">0</span> || end &gt; array.Length - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = array[start];</span><br><span class="line">            array[start] = array[end];</span><br><span class="line">            array[end] = temp;</span><br><span class="line"></span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> string <span class="title">ReverseSentense</span><span class="params">(string sentense)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (string.IsNullOrEmpty(sentense))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] array = sentense.ToCharArray();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.Length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step1.先翻转整个句子</span></span><br><span class="line">        Reverse(array, start, end);</span><br><span class="line">        <span class="comment">// Step2.再翻转句中的每个单词</span></span><br><span class="line">        start = end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; array.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[start] == <span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                start++;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (end == array.Length || array[end] == <span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Reverse(array, start, --end);</span><br><span class="line">                start = end + <span class="number">1</span>;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> string(array);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目二:汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S&#x3D;”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</span><br></pre></td></tr></table></figure>

<ul>
<li><p>三次反转</p>
<ul>
<li>1.反转前面n个字符</li>
<li>2.反转后面n个字符</li>
<li>3.反转所有</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> len = chars.length;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(chars,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">    reverse(chars,n,len-<span class="number">1</span>);</span><br><span class="line">    reverse(chars,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer(len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c:chars)&#123;</span><br><span class="line">        sb.append(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h4 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a>队列的最大值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组&#123;2,3,4,2,6,2,5,1&#125;及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为&#123;4,4,6,6,6,5&#125;； 针对数组&#123;2,3,4,2,6,2,5,1&#125;的滑动窗口有以下6个： &#123;[2,3,4],2,6,2,5,1&#125;， &#123;2,[3,4,2],6,2,5,1&#125;， &#123;2,3,[4,2,6],2,5,1&#125;， &#123;2,3,4,[2,6,2],5,1&#125;， &#123;2,3,4,2,[6,2,5],1&#125;， &#123;2,3,4,2,6,[2,5,1]&#125;。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>蛮力法，从头到尾滑动窗口 时间复杂度O（Nk）</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span>{
        ArrayList&lt;Integer&gt; list  = <span class="keyword">new</span> ArrayList&lt;Integer&gt; ();
        <span class="keyword">if</span>(size&gt;num.length||size==<span class="number">0</span>)
            <span class="keyword">return</span> list;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=num.length-size;i++){
            <span class="keyword">int</span> max = num[i];
            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;i+size;j++){
                <span class="keyword">if</span>(num[j]&gt;max){
                    max = num[j];
                }
            }
            list.add(max);
        }
        <span class="keyword">return</span> list;
    }
&lt;!--￼<span class="number">129</span>--&gt;












</code></pre>
</li>
</ul>
<h4 id="圆圈中最后的数字（约瑟夫问题）"><a href="#圆圈中最后的数字（约瑟夫问题）" class="headerlink" title="圆圈中最后的数字（约瑟夫问题）"></a>圆圈中最后的数字（约瑟夫问题）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</span><br><span class="line"></span><br><span class="line">如果没有小朋友，请返回-1</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法一：模仿整个过程</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{
    <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{
        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) {
            list.add(i);
        }
        <span class="keyword">int</span> bt = <span class="number">0</span>;
        <span class="keyword">while</span> (list.size() &gt; <span class="number">1</span>) {
            bt = (bt + m - <span class="number">1</span>) % list.size();<span class="comment">//类似循环队列</span>
            list.remove(bt);
        }
        <span class="keyword">return</span> list.size() == <span class="number">1</span> ? list.get(<span class="number">0</span>) : -<span class="number">1</span>;
    }
}
&lt;!--￼<span class="number">131</span>--&gt;
假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可获得的最大利润是多少？
&lt;!--￼<span class="number">132</span>--&gt;


</code></pre>
</li>
</ul>
<hr>
<h4 id="树的公共祖先"><a href="#树的公共祖先" class="headerlink" title="树的公共祖先"></a>树的公共祖先</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">树中两个结点的最低公共祖先。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法一：假设是二叉搜索树（二叉搜索树是一个排序的二叉树，左子树的结点小于根结点，右子树的结点大于根结点），故找到一个结点，使其大于左子结点小于右子结点即可。</p>
</li>
<li><pre><code>public static TreeNode getLastCommonNode(TreeNode pRoot, TreeNode pLeft, TreeNode pRight){
    TreeNode treeNode = null;
    if(pRoot == null || pLeft.val &gt; pRight.val){
        return null;
    }
    if(pRoot.val &gt;= pRight.val){
        treeNode = getLastCommonNode(pRoot.left, pLeft, pRight);
    }
    if(pRoot.val &lt;= pLeft.val){
        treeNode = getLastCommonNode(pRoot.right, pLeft, pRight);
    }
    if(pRoot.val &gt;= pLeft.val &amp;&amp; pRoot.val &lt;= pRight.val){
        return pRoot;
    }
    return treeNode;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 方法二：假设是普通的树，但是每个子结点都有指向父结点的指针，这样的话类似与前面的链表找公共结点一样。</span><br><span class="line"></span><br><span class="line">- 方法三：假设就是一棵普通的树，子结点没有指向父结点的指针。</span><br><span class="line"></span><br><span class="line">  - 定义两个数组，存放根节点分别到目标节点的路径，问题转化为查找两个数组第一个出现的相同值</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;java</span><br><span class="line">  public static TreeNode getLastCommonParent(TreeNode pRoot, TreeNode p1, TreeNode p2)&#123;</span><br><span class="line">  	&#x2F;&#x2F;保存p1的路径</span><br><span class="line">  	ArrayList&lt;TreeNode&gt; path1 &#x3D; new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">  	&#x2F;&#x2F;保存p2的路径</span><br><span class="line">  	ArrayList&lt;TreeNode&gt; path2 &#x3D; new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">  	ArrayList&lt;TreeNode&gt; tmpList &#x3D; new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">  	getNodePath(pRoot, p1, tmpList, path1);</span><br><span class="line">  	getNodePath(pRoot, p2, tmpList, path2);</span><br><span class="line">  	&#x2F;&#x2F;如果路径不存在，返回空</span><br><span class="line">  	if(path1.size() &#x3D;&#x3D; 0 || path2.size() &#x3D;&#x3D; 0)&#123;</span><br><span class="line">  		return null;</span><br><span class="line">  	&#125;</span><br><span class="line">  	return getLastCommonParent(path1, path2);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  &#x2F;&#x2F;获取根节点到目标节点的路径</span><br><span class="line">  public static void getNodePath(TreeNode pRoot, TreeNode pNode, ArrayList&lt;TreeNode&gt; tmpList, ArrayList&lt;TreeNode&gt; path)&#123;</span><br><span class="line">  	if(pRoot &#x3D;&#x3D; pNode || pRoot &#x3D;&#x3D; null)&#123;</span><br><span class="line">  		return ;</span><br><span class="line">  	&#125;</span><br><span class="line">  	tmpList.add(pRoot);</span><br><span class="line">  	ArrayList&lt;TreeNode&gt; childs &#x3D; pRoot.children;</span><br><span class="line">  	for(TreeNode node : childs)&#123;</span><br><span class="line">  		if(node &#x3D;&#x3D; pNode)&#123;</span><br><span class="line">  			path.addAll(tmpList);</span><br><span class="line">  			break;</span><br><span class="line">  		&#125;</span><br><span class="line">  		getNodePath(node, pNode, tmpList, path);</span><br><span class="line">  	&#125;</span><br><span class="line">  	tmpList.remove(tmpList.size()-1); &#x2F;&#x2F;清空集合</span><br><span class="line">  &#125;</span><br><span class="line">  	</span><br><span class="line">  private static TreeNode getLastCommonParent(ArrayList&lt;TreeNode&gt; path1, ArrayList&lt;TreeNode&gt; path2) &#123;</span><br><span class="line">  	TreeNode tmpNode &#x3D; null;</span><br><span class="line">  	for(int i &#x3D; 0; i &lt; path1.size(); i++)&#123;</span><br><span class="line">  		if(path1.get(i)!&#x3D;path2.get(i))&#123;</span><br><span class="line">  			break;</span><br><span class="line">  		&#125;</span><br><span class="line">  	    &#x2F;&#x2F;循环结束时tmpNode即为最后一个共同结点</span><br><span class="line">  		tmpNode &#x3D; path1.get(i);</span><br><span class="line">  	&#125;</span><br><span class="line">  	return tmpNode;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</code></pre></li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MRZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MRZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/26/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-26 13:11:50" itemprop="dateCreated datePublished" datetime="2020-03-26T13:11:50+08:00">2020-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-12 18:45:31" itemprop="dateModified" datetime="2020-03-12T18:45:31+08:00">2020-03-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h4 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h4><ul>
<li><pre><code class="java"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span>
<span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>{
    <span class="comment">/** The value is used for character storage. */</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];
} 
&lt;!--￼<span class="number">0</span>--&gt;</code></pre>
</li>
<li><p>唯一的解决办法，就是在所有需要用到编码的地方，都统一使用 UTF-8</p>
</li>
<li><p>getBytes 和 new String 两个方法都会使用到编码，我们把这两处的编码替换成 UTF-8 后，打印出的结果就正常了</p>
<ul>
<li><pre><code>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 相等判断</span><br><span class="line"></span><br><span class="line">- equals 和 equalsIgnoreCase。后者判断相等时，会忽略大小写，近期看见一些面试题在问：如果让你写判断两个 String 相等的逻辑，应该如何写</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;java</span><br><span class="line">  public boolean equals(Object anObject) &#123;</span><br><span class="line">      &#x2F;&#x2F; 判断内存地址是否相同</span><br><span class="line">      if (this &#x3D;&#x3D; anObject) &#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 待比较的对象是否是 String，如果不是 String，直接返回不相等</span><br><span class="line">      if (anObject instanceof String) &#123;</span><br><span class="line">          String anotherString &#x3D; (String)anObject;</span><br><span class="line">          int n &#x3D; value.length;</span><br><span class="line">          &#x2F;&#x2F; 两个字符串的长度是否相等，不等则直接返回不相等</span><br><span class="line">          if (n &#x3D;&#x3D; anotherString.value.length) &#123;</span><br><span class="line">              char v1[] &#x3D; value;</span><br><span class="line">              char v2[] &#x3D; anotherString.value;</span><br><span class="line">              int i &#x3D; 0;</span><br><span class="line">              &#x2F;&#x2F; 依次比较每个字符是否相等，若有一个不等，直接返回不相等</span><br><span class="line">              while (n-- !&#x3D; 0) &#123;</span><br><span class="line">                  if (v1[i] !&#x3D; v2[i])</span><br><span class="line">                      return false;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">              return true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li>
<li><p>判断内存地址</p>
</li>
<li><p>转为比较string内部char数组：相同长度，字符匹配</p>
</li>
</ul>
</li>
</ul>
<h2 id="long"><a href="#long" class="headerlink" title="long"></a>long</h2><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul>
<li><p>Long 自己实现了一种缓存机制，缓存了从 -128 到 127 内的所有 Long 值，如果是这个范围内的 Long 值，就不会初始化，而是从缓存中拿</p>
</li>
<li><pre><code class="java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LongCache</span> </span>{
    <span class="function"><span class="keyword">private</span> <span class="title">LongCache</span><span class="params">()</span></span>{}
    <span class="comment">// 缓存，范围从 -128 到 127，+1 是因为有个 0</span>
    <span class="keyword">static</span> <span class="keyword">final</span> Long cache[] = <span class="keyword">new</span> Long[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];

    <span class="comment">// 容器初始化时，进行加载</span>
    <span class="keyword">static</span> {
        <span class="comment">// 缓存 Long 值，注意这里是 i - 128 ，所以再拿的时候就需要 + 128</span>
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)
            cache[i] = <span class="keyword">new</span> Long(i - <span class="number">128</span>);
    }
}
&lt;!--￼<span class="number">2</span>--&gt;
</code></pre>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//确保容积足够</span></span><br><span class="line">  ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//记录数组被修改</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">// 如果我们期望的最小容量大于目前数组的长度，那么就扩容</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩容，并把现有数据拷贝到新的数组里面去</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="comment">// oldCapacity &gt;&gt; 1 是把 oldCapacity 除以 2 的意思</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// newCapacity 本次扩容的大小，minCapacity 我们期望的数组最小大小</span></span><br><span class="line">  <span class="comment">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就用 Integer 的最大值</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 通过复制进行扩容</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意的地方：</strong></p>
<ul>
<li>扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是原来容量的 1.5 倍；</li>
<li>ArrayList 中的数组的最大值是 Integer.MAX_VALUE，超过这个值，JVM 就不会给数组分配内存空间了。</li>
<li>新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 null 值的。</li>
</ul>
<p><strong>扩容的本质</strong>：</p>
<ul>
<li>扩容是通过这行代码来实现的：<code>Arrays.copyOf(elementData, newCapacity);</code>，这行代码描述的本质是数组之间的拷贝，扩容是会先新建一个符合我们预期容量的新数组，然后把老数组的数据拷贝过去，我们通过 System.arraycopy 方法进行拷贝，此方法是 native 的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(elementData,<span class="number">0</span>,newElementData,<span class="number">0</span>,Math.min(elementData.length,newCapacity))</span><br></pre></td></tr></table></figure>

<h5 id="扩容值得借鉴的地方？"><a href="#扩容值得借鉴的地方？" class="headerlink" title="扩容值得借鉴的地方？"></a>扩容值得借鉴的地方？</h5><p>答：有两点：</p>
<ul>
<li>是扩容的思想值得学习，通过自动扩容的方式，让使用者不用关心底层数据结构的变化，封装得很好，1.5 倍的扩容速度，可以让扩容速度在前期缓慢上升，在后期增速较快，大部分工作中要求数组的值并不是很大，所以前期增长缓慢有利于节省资源，在后期增速较快时，也可快速扩容。</li>
<li>扩容过程中，有数组大小溢出的意识，比如要求扩容后的数组大小，不能小于 0，不能大于 Integer 的最大值。</li>
</ul>
<p><strong>删除</strong>：</p>
<ul>
<li>新增的时候是没有对 null 进行校验的，所以删除的时候也是允许删除 null 值的；</li>
<li>找到值在数组中的索引位置，是通过 equals 来判断的，如果数组元素不是基本类型，需要我们关注 equals 的具体实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果要删除的值是 null，找到第一个值是 null 的删除</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">      <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        fastRemove(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果要删除的值不为 null，找到第一个和要删除的值相等的删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">      <span class="comment">// 这里是根据  equals 来判断值相等的，相等后再根据索引位置进行删除</span></span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">        fastRemove(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程安全：</strong></p>
<ul>
<li>ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。</li>
<li>类注释中推荐我们使用 Collections#synchronizedList 来保证线程安全，SynchronizedList 是通过在每个方法上面加上锁来实现，虽然实现了线程安全，但是性能大大降低</li>
</ul>
<h5 id="ArrayList-数组，我们通过增强-for-循环进行删除，可以么？"><a href="#ArrayList-数组，我们通过增强-for-循环进行删除，可以么？" class="headerlink" title="ArrayList 数组，我们通过增强 for 循环进行删除，可以么？"></a>ArrayList 数组，我们通过增强 for 循环进行删除，可以么？</h5><p>答：不可以，会报错。因为增强 for 循环过程其实调用的就是迭代器的 next () 方法，当你调用 list#remove () 方法进行删除时，modCount 的值会 +1，而这时候迭代器中的 expectedModCount 的值却没有变，导致在迭代器下次执行 next () 方法时，expectedModCount != modCount 就会报 ConcurrentModificationException 的错误</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="*LinkedList *"></a>*<em>LinkedList *</em></h2><h4 id="1-追加"><a href="#1-追加" class="headerlink" title="1.追加"></a>1.追加</h4><ul>
<li>追加节点时，我们可以选择追加到链表头部，还是追加到链表尾部，add 方法默认是从尾部开始追加，addFirst 方法是从头部开始追加</li>
</ul>
<p><strong>从尾部追加</strong></p>
<ul>
<li><p>保存尾部节点</p>
</li>
<li><p>创建新的节点，前指针指向尾部</p>
</li>
<li><p>尾部节点转为新节点</p>
</li>
<li><p>尾部节点指向新的last</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把尾节点数据暂存</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 新建新的节点，初始化入参含义：</span></span><br><span class="line">    <span class="comment">// l 是新节点的前一个节点，当前值是尾节点值</span></span><br><span class="line">    <span class="comment">// e 表示当前新增节点，当前新增节点后一个节点是 null</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 新建节点追加到尾部</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果链表为空（l 是尾节点，尾节点为空，链表即空），头部和尾部是同一个节点，都是新建的节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;![图片描述](<span class="comment">//img1.sycdn.imooc.com/5d5fc69600013e4803600240.gif)</span></span><br><span class="line">    <span class="comment">//否则把前尾节点的下一个节点，指向当前尾节点。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">//大小和版本更改</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从头部追加</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/ 从头部追加</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头节点赋值给临时变量</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 新建节点，前一个节点指向null，e 是新建节点，f 是新建节点的下一个节点，目前值是头节点的值</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">// 新建节点成为头节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">// 头节点为空，就是链表为空，头尾节点是一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="comment">//上一个头节点的前一个节点指向当前节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-节点删除"><a href="#2-节点删除" class="headerlink" title="2 节点删除"></a>2 节点删除</h4><p>节点删除的方式和追加类似，我们可以选择从头部删除，也可以选择从尾部删除，删除操作会把节点的值，前后指向节点都置为 null，帮助 GC 进行回收。</p>
<p><strong>从头部删除</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从头删除节点 f 是链表头节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿出头节点的值，作为方法的返回值</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">// 拿出头节点的下一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">//帮助 GC 回收头节点</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 头节点的下一个节点成为头节点</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="comment">//如果 next 为空，表明链表为空</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//链表不为空，头节点的前一个节点指向 null</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//修改链表大小和版本</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-节点查询"><a href="#3-节点查询" class="headerlink" title="3.节点查询"></a>3.节点查询</h4><p>链表查询某一个节点是比较慢的，需要挨个循环查找才行，我们看看 LinkedList 的源码是如何寻找节点的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据链表索引位置查询节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 index 处于队列的前半部分，从头开始找，size &gt;&gt; 1 是 size 除以 2 的意思。</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="comment">// 直到 for 循环到 index 的前一个 node 停止</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果 index 处于队列的后半部分，从尾开始找</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="comment">// 直到 for 循环到 index 的后一个 node 停止</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以发现，LinkedList 并没有采用从头循环到尾的做法，而是采取了简单二分法，首先看看 index 是在链表的前半部分，还是后半部分。如果是前半部分，就从头开始寻找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，这种思想值得我们借鉴。</p>
<hr>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h4 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h4><ul>
<li>提供了一种框架，自定义了先进先出的同步队列，让获取不到锁的线程能进入同步队列中排队</li>
<li>子类可以通过给状态 CAS 赋值来决定能否拿到锁，可以定义那些状态可以获得锁，哪些状态表示获取不到锁（比如定义状态值是 0 可以获得锁，状态值是 1 就获取不到锁）</li>
<li>子类用内部类来继承 AQS，从而实现锁的功能</li>
<li>AQS 提供了排它模式和共享模式两种锁模式。排它模式下：只有一个线程可以获得锁，共享模式可以让多个线程获得锁，子类 ReadWriteLock 实现了两种模式</li>
<li>AQS 同步队列和条件队列，获取不到锁的节点在入队时是先进先出，但被唤醒时，可能并不会按照先进先出的顺序执行</li>
</ul>
<h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><ol>
<li><p>简单属性：</p>
<ul>
<li><p>state</p>
</li>
<li><pre><code class="java"><span class="comment">// 同步器的状态，子类会根据状态字段进行判断是否可以获得锁</span>
<span class="comment">// 比如 CAS 成功给 state 赋值 1 算得到锁，赋值失败为得不到锁， CAS 成功给 state 赋值 0 算释放锁，赋值失败为释放失败</span>
<span class="comment">// 可重入锁，每次获得锁 +1，每次释放锁 -1</span>
<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;

<span class="comment">// 自旋超时阀值，单位纳秒</span>
<span class="comment">// 当设置等待时间时才会用到这个属性</span>
<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;
&lt;!--￼<span class="number">10</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MRZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MRZ的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/26/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-26 00:48:48" itemprop="dateCreated datePublished" datetime="2020-03-26T00:48:48+08:00">2020-03-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MRZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MRZ</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>MRZ de 博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录自己生活与学习的点点滴滴">
<meta property="og:type" content="website">
<meta property="og:title" content="MRZ de 博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="MRZ de 博客">
<meta property="og:description" content="记录自己生活与学习的点点滴滴">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="MRZ">
<meta property="article:tag" content="程序员，工程师，南京大学，java">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="MRZ de 博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MRZ de 博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">write something to the future!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-redis原理知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/redis%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86/" class="article-date">
  <time datetime="2020-03-26T07:05:54.663Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/redis%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86/">redis原理知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html>
<head>
<title>数据结构 - 幕布</title>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="renderer" content="webkit"/>
<meta name="author" content="mubu.com"/>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="MRZ de 博客" type="application/atom+xml">
</head>
<body style="margin: 50px 20px;color: #333;font-family: SourceSansPro,-apple-system,BlinkMacSystemFont,'PingFang SC',Helvetica,Arial,'Microsoft YaHei',微软雅黑,黑体,Heiti,sans-serif,SimSun,宋体,serif">
<div class="export-wrapper"><div style="font-size: 22px; padding: 0 15px 0;"></div><ul style="list-style: disc outside;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">数据结构</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">String——字符串</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在Redis内部，String类型通过 int、SDS(simple dynamic string)作为结构存储，int用来存放整型数据，sds存放字 节/字符串和浮点型数据</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">定义SDS对象，此对象中包含三个属性：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">len buf中已经占有的长度(表示此字符串的实际长度)</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">free buf中未使用的缓冲区长度</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">buf[] 实际保存字符串数据的地方</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%222a3170fd82d23007-6082657%22%2C%22oh%22%3A694%2C%22ow%22%3A1098%2C%22uri%22%3A%22document_image%2F33433c31-426b-4b52-960b-b8fe609c8183-6082657.jpg%22%2C%22w%22%3A604%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/33433c31-426b-4b52-960b-b8fe609c8183-6082657.jpg" style="max-width: 720px; width: 604px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Hash——字典</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">redis的散列可以存储多个键 值 对之间的映射，散列存储的值既可以是字符串又可以是数字值，并且用户同样可以对散列存储的数字值执行自增操作或者自减操作。散列可以看作是一个文档或关系数据库里的一行。hash底层的数据结构实现有两种：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一种是ziplist，上面已经提到过。当存储的数据超过配置的阀值时就是转用hashtable的结构。这种转换比较消耗性能，所以应该尽量避免这种转换操作。同时满足以下两个条件时才会使用这种结构：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当键的个数小于hash-max-ziplist-entries（默认512）</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当所有值都小于hash-max-ziplist-value（默认64）</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">另一种就是hashtable。这种结构的时间复杂度为O(1)，但是会消耗比较多的内存空间。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22305170fd8e2877063-6082657%22%2C%22oh%22%3A638%2C%22ow%22%3A1239%2C%22uri%22%3A%22document_image%2F3cb374c2-aa8b-4682-b516-71d78fa0e97f-6082657.jpg%22%2C%22w%22%3A780%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/3cb374c2-aa8b-4682-b516-71d78fa0e97f-6082657.jpg" style="max-width: 720px; width: 780px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">List——列表</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">列表类型内部使用双向链表实现，所以向列表两端添加元素的时间复杂度为O(1), 获取越接近两端的元素速度就越 快。</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是很快的</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">内部数据结构</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">redis3.2之前，List类型的value对象内部以linkedlist或者ziplist来实现, 当list的元素个数和单个元素的长度比较小 的时候，Redis会采用ziplist（压缩列表）来实现来减少内存占用。否则就会采用linkedlist（双向链表）结构。</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">这两种存储方式都有优缺点，双向链表在链表两端进行push和pop操作，在插入节点上复杂度比较低，但是内存开 销比较大； ziplist存储在一段连续的内存上，所以存储效率很高，但是插入和删除都需要频繁申请和释放内存；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">redis3.2之后，采用的一种叫quicklist的数据结构来存储list，列表的底层都由quicklist实现。&nbsp;</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">quicklist仍然是一个双向链表，只是列表的每个节点都是一个ziplist，其实就是linkedlist和ziplist的结合，quicklist 中每个节点ziplist都能够存储多个数据元素，在源码中的文件为【quicklist.c】，在源码第一行中有解释为：A doubly linked list of ziplists意思为一个由ziplist组成的双向链表；</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22280170fd8b88de0e-6082657%22%2C%22oh%22%3A922%2C%22ow%22%3A1332%2C%22uri%22%3A%22document_image%2Ffb878b98-c965-4566-a17c-d93fc114bb11-6082657.jpg%22%2C%22w%22%3A842%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/fb878b98-c965-4566-a17c-d93fc114bb11-6082657.jpg" style="max-width: 720px; width: 842px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Set——集合</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">集合类型中，每个元素都是不同的，也就是不能有重复数据，同时集合类型中的数据是无序的。一个集合类型键可 以存储至多232-1个 。集合类型和列表类型的最大的区别是有序性和唯一性 集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在。由于集合类型在redis内部是使用的值 为空的散列表(hash table)，所以这些操作的时间复杂度都是O(1).</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">数据结构</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Set在的底层数据结构以intset或者hashtable来存储。当set中只包含整数型的元素时，采用intset来存储，否则， 采用hashtable存储，但是对于set来说，该hashtable的value值用于为NULL。通过key来存储元素</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22174170fd8fe2d3162-6082657%22%2C%22oh%22%3A263%2C%22ow%22%3A1323%2C%22uri%22%3A%22document_image%2F9e827dbc-a924-4b10-bd62-9dc8b4e969d0-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/9e827dbc-a924-4b10-bd62-9dc8b4e969d0-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Sorted Set——有序集合</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member),每个成员都是各不相同的。有序集合的值则被称为分值（score），分值必须为浮点数。有序集合是redis里面唯一一个既可以根据成员访问元素(这一点和散列一样),又可以根据分值以及分值的排列顺序访问元素的结构。它的存储方式也有两种：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">是ziplist结构。</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">与上面的hash中的ziplist类似，member和score顺序存放并按score的顺序排列</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">另一种是skiplist与dict的结合。</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%2213c170fd9285ca089-6082657%22%2C%22oh%22%3A568%2C%22ow%22%3A1224%2C%22uri%22%3A%22document_image%2F74daf6b3-00bd-4c02-b877-e553e085ca4d-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/74daf6b3-00bd-4c02-b877-e553e085ca4d-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">BITMAP(位图)</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">HYPERLOG（）</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">GEOSPATIAL</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">原理分析</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">过期删除原理</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">消极方法（passive way）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在主键被访问时如果发现它已经失效，那么就删除它</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">数据量较大时，容易不及时清理，占据内存</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> 积极方法（active way）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">周期性地从设置了失效时间的主键中选择一部分失效的主键删除</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">对于那些从未被查询的key，即便它们已经过期，被动方式也无法清除。因此Redis会周期性地随机测试一些key， 已过期的key将会被删掉。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis每秒会进行10次操作，具体的流程：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 随机测试 20 个带有timeout信息的key；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> \2. 删除其中已经过期的key；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\3. 如果超过25%的key被删除，则重复执行步骤1； </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">这是一个简单的概率算法（trivial probabilistic algorithm），基于假设我们随机抽取的key代表了全部的key空 间。</span></li></ul></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis的数据是如何持久化的？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一种是RDB方式（redis database）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">根据指定的规则“定时”将内存中的数据存储在硬盘上</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当符合一定条件时，Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，等 到持久化过程都结束了，再用这个临时文件替换上次持久化好的文件</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">优缺点：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">优点：大规模数据的恢复，且对于数据恢复的完整性不是非常敏感</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缺点：后一次持久化后的数据可能丢失</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一种是AOF（append-only-ﬁle）方式</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在每次执行命令后将（更改）命令本身记录下来</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis存储非临时数据时，一般需要打开AOF持久化来降低进程终止导致的数据丢失。AOF可以将Redis执行 的每一条写命令追加到硬盘文件中，这一过程会降低Redis的性能，但大部分情况下这个影响是能够接受的，另外 使用较快的硬盘可以提高AOF的性能&nbsp;</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在启动时，Redis会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，载入的速度相对于RDB会慢一些&nbsp;</span></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">AOF的重写原理</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">什么时候启动重写？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前 数据集所需的小命令集合。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">重写流程？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">重写的流程是这样，主进程会fork一个子进程出来进行AOF重写，这个重写过程并不是基于原有的aof文件来做 的，而是有点类似于快照的方式，全量遍历内存中的数据，然后逐个序列到aof文件中。在fork子进程这个过程 中，服务端仍然可以对外提供服务，那这个时候重写的aof文件的数据和redis内存数据不一致了怎么办？不用担 心，这个过程中，主进程的数据更新操作，会缓存到aof_rewrite_buf中，也就是单独开辟一块缓存来存储重写期间 收到的命令，当子进程重写完以后再把缓存中的数据追加到新的aof文件。 当所有的数据全部追加到新的aof文件中后，把新的aof文件重命名为，此后所有的操作都会被写入新的aof文件。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">中途故障？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">如果在rewrite过程中出现故障，不会影响原来aof文件的正常工作，只有当rewrite完成后才会切换文件。因此这个 rewrite过程是比较可靠的</span></li></ul></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis内存回收策略？</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">并不是真正的LRU，全局扫描的代价过于大，redis又是单线程基于采样的LRU，也就是放弃了从所有数据中搜索解改为采样空间搜索优解。</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">默认的策略为noeviction策略，当内存使用达到阈值的时候，所有引起申请内存的命令会报错</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">allkeys-lru：从数据集（server.db[i].dict）中挑选近少使用的数据淘汰 </span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">适合的场景： 如果我们的应用对缓存的访问都是相对热点数据，那么可以选择这个策略</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">allkeys-random：随机移除某个key。 适合的场景：如果我们的应用对于缓存key的访问概率相等，则可以使用这个策略</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选近少使用的数据淘汰。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">适合场景：这种策略使得我们可以向Redis提示哪些key更适合被淘汰，我们可以自己控制</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis是单进程单线程？性能为什么这么快&nbsp;？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">官方的解释是，CPU并不是Redis的瓶颈所在，Redis的瓶颈主要在机器的内存和网络的带宽</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">单进程单线程好处</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">代码更清晰，处理逻辑更简单</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">不存在多进程或者多线程导致的切换而消耗CPU</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">单进程单线程弊端</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis快的主要原因是：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">完全基于内存</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">数据结构简单，对数据操作也简单</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">使用多路 I/O 复用模型</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">多路 I/O 复用模型是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</span></li></ul></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">集群</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">主从模式（可以实现读写分离）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">复制的作用是把redis的数据库复制多个副本部署在不同的服务器上，如果其中一台服务器出现故障，也能快速迁 移到其他服务器上提供服务。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">复制功能可以实现当一台redis服务器的数据更新后，自动将新的数据同步到其他服 务器上</span></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22302170faecf75e147-6082657%22%2C%22oh%22%3A349%2C%22ow%22%3A854%2C%22uri%22%3A%22document_image%2Ffb194f47-3b85-4bc4-b99a-0d1f1cb5d384-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/fb194f47-3b85-4bc4-b99a-0d1f1cb5d384-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">原理：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">全量复制</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份</span></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%2210b170fb1ef512136-6082657%22%2C%22oh%22%3A831%2C%22ow%22%3A1362%2C%22uri%22%3A%22document_image%2F05f0e158-ab86-4d73-ac78-8e96a238acce-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/05f0e158-ab86-4d73-ac78-8e96a238acce-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">复制策略：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">master/slave 复制策略是采用乐观复制，也就是说可以容忍在一定时间内master/slave数据的内容是不同的，但是 两者的数据会最终同步。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">具体来说，redis的主从同步过程本身是异步的，意味着master执行完客户端请求的命令 后会立即返回结果给客户端，然后异步的方式把命令同步给slave。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">这一特征保证启用master/slave后 master的性能不会受到影响。&nbsp;</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">问题：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">如果在这个数据不一致的窗口期间，master/slave因为网络问题断开连接，而这个时候，master 是无法得知某个命令最终同步给了多少个slave数据库</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">解决方案：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">min-slaves-to-write 3 表示只有当3个或以上的slave连接到master，master才是可写的</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">min-slaves-max-lag 10 表示允许slave最长失去连接的时间，如果10秒还没收到slave的响应，则master认为该 slave以断开</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">增量复制</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">从redis 2.8开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的 地方，继续复制下去，而不是从头开始复制一份</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">master node会在内存中创建一个backlog，master和slave都会保存一个replica oﬀset还有一个master id，oﬀset 就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次的replica oﬀset开始继续 复制</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">但是如果没有找到对应的oﬀset，那么就会执行一次全量同步</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">无硬盘复制&nbsp;</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">问题引入：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis复制的工作原理基于RDB方式的持久化实现的，也就是master在后台保存RDB快照，slave接 收到rdb文件并载入</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 当master禁用RDB时，如果执行了复制初始化操作，Redis依然会生成RDB快照，当master下次启动时执行该 RDB文件的恢复，但是因为复制发生的时间点不确定，所以恢复的数据可能是任何时间点的。就会造成数据出现问 题</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\2. 当硬盘性能比较慢的情况下（网络硬盘），那初始化复制过程会对性能产生影响</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">因此2.8.18以后的版本，Redis引入了无硬盘复制选项，可以不需要通过RDB文件去同步，直接发送数据</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">master**在内存中直接创建rdb，然后发送给slave，不会在自己本地落地磁盘了&nbsp;</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">哨兵机制</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">哨兵的作用就是监控Redis系统的运行状况，它的功能包括两个</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> \1. 监控master和slave是否正常运行</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> \2. master出现故障时自动将slave数据库升级为master</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">引入问题：哨兵的可用性如何解决？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">使用多个哨兵进行监控任务以保证系统足够稳定。此时哨兵不仅会监控master和slave，同时还会互相监 控；这种方式称为哨兵集群</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">哨兵集群需要解决故障发现、和master决策的协商机制问题&nbsp;</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">哨兵之间如何感知彼此存在？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">sentinel节点之间会因为共同监视同一个master从而产生了关联，一个新加入的sentinel节点需要和其他监视相同 master节点的sentinel相互感知</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">步骤：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 需要相互感知的sentinel都向他们共同监视的master节点订阅channel:sentinel:hello</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\2. 新加入的sentinel节点向这个channel发布一条消息，包含自己本身的信息，这样订阅了这个channel的sentinel 就可以发现这个新的sentinel</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\3. 新加入得sentinel和其他sentinel节点建立长连接</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">master 的故障发现？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">主观不可用：sentinel节点会定期向master节点发送心跳包来判断存活状态，一旦master节点没有正确响应，sentinel会把 master设置为“主观不可用状态”，然后它会把“主观不可用”发送给其他所有的sentinel节点去确认</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">客观不可用：当确认的 sentinel节点数大于&gt;quorum时，则会认为master是“客观不可用”，接着就开始进入选举新的master流程</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一致性算法Raft（决定新的master）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一个 Raft 集群包含若干个服务器节点；通常是 5 个，这允许整个系统容忍 2 个节点的失效，每个节点处于以下三种状态之一：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">follower（跟随者）&nbsp;：所有结点都以&nbsp;follower&nbsp;的状态开始。如果没收到&nbsp;leader消息则会变成&nbsp;candidate状态。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">candidate（候选人）：会向其他结点“拉选票”，如果得到大部分的票则成为leader。这个过程就叫做Leader选举(Leader Election)。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">leader（领导者）：所有对系统的修改都会先经过leader。</span></li></ul></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%2216f170fb26f66205e-6082657%22%2C%22oh%22%3A597%2C%22ow%22%3A1190%2C%22uri%22%3A%22document_image%2F0c386e08-6bc9-4c01-bb4d-b5be57ceb51f-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/0c386e08-6bc9-4c01-bb4d-b5be57ceb51f-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">集群</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">哨兵和集群是两个独立的功能，当不需要对数据进行分片使用哨兵就够了，如果要进行水平扩容，集群是一个比较好的方式</span></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">结构：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一个Redis Cluster由多个Redis节点组构成</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">节点组中仅有一个master，以及0-n个slaver</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">只有master节点对用户提供写服务，读服务可以由master或者slave提供&nbsp;</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis的数据分区</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis Cluster采用哈希分区规则,采用虚拟槽分区</span></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22389170fb48f7e013a-6082657%22%2C%22oh%22%3A625%2C%22ow%22%3A1383%2C%22uri%22%3A%22document_image%2Fef375ec9-a995-4efd-9dad-ab1bece3b4d6-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/ef375ec9-a995-4efd-9dad-ab1bece3b4d6-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">HashTags</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">问题引入：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">某些时候要求某些相关联的key分配到相同机器</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">解决：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">引入了HashTag的概念，可以使得数据分布算法可以根据key的某一个部分进行计算，然后 让相关的key落到同一个数据分片</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">举个简单的例子</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">加入对于用户的信息进行存储， user:user1:id、user:user1:name/ 那么通过hashtag的方式</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> user:{user1}:id、user:{user1}.name; 表示 当一个key包含 {} 的时候，就不对整个key做hash，而仅对 {} 包括的字符串做hash。&nbsp;</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">重定向客户端</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis Cluster并不会代理查询，那么如果客户端访问了一个key并不存在的节点，这个节点是怎么处理的呢？</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">比如 我想获取key为msg的值，msg计算出来的槽编号为254，当前节点正好不负责编号为254的槽</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">那么就会返回客户 端下面信息：-MOVED 254 127.0.0.1:6381</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">表示客户端想要的254槽由运行在IP为127.0.0.1，端口为6381的Master实例服务。如果根据key计算得出的槽恰好由当前节点负责，则当期节点会立即返回结果</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">分片迁移</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">问题引入：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在一个稳定的Redis cluster下，每一个slot对应的节点是确定的，但是在某些情况下，节点和分片对应的关系会发 生变更</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 新加入master节点</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\2. 某个节点宕机</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当动态添加或减少node节点时，需要将16384个槽做个再分配，槽中的键值也要迁移。当然，这一过程， 在目前实现中，还处于半自动状态，需要人工介入。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">新增一个主节点</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">新增一个节点D，redis cluster的这种做法是从各个节点的前面各拿取一部分slot到D上。大致就会变成这样： </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">节点A覆盖1365-5460     节点B覆盖6827-10922     节点C覆盖12288-16383</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">节点D覆盖0-1364,5461-6826,10923-12287</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">删除一个主节点</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">先将节点的数据移动到其他节点上，然后才能执行删除</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">槽迁移的过程</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">为了保证slot数据的一致性，MasterA此时 对于slot内部数据提供读写服务的行为和通常状态下是有区别的</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">MIGRATING状态</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 如果客户端访问的Key还没有迁移出去，则正常处理这个key </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\2. 如果key已经迁移或者根本就不存在这个key，则回复客户端ASK信息让它跳转到MasterB去执行</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">IMPORTING状态</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 当来自客户端的正常访问不是从ASK跳转过来的，说明客户端还不知道迁移正在进行，很有可能操作了一个目前 还没迁移完成的并且还存在于MasterA上的key，如果此时这个key在A上已经被修改了，那么B和A的修改则会发生 冲突。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">对于MasterB上的slot上的所有非ASK跳转过来的操作，MasterB都不会去护理，而是通过MOVED 命令让客户端跳转到MasterA上去执行</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22290170fc0191fe15f-6082657%22%2C%22oh%22%3A494%2C%22ow%22%3A1312%2C%22uri%22%3A%22document_image%2F3e0d6470-8921-4651-b140-97751414fbe2-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/3e0d6470-8921-4651-b140-97751414fbe2-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">实战场景</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">分布式锁</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">什么是分布式锁呢？或者 为什么我们需要通过Redis来构建分布式锁？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">其实最根本原因就是Score（范围），因为在分布式架构中，所有的应用都是进程隔离的，在多进程访问共享资源的时候我们需要满足互斥性，就需要设定一个所有进程都能看得到的范 围，而这个范围就是Redis本身。所以我们才需要把锁构建到Redis中。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis里面提供了一些比较具有能够实现锁特性的命令</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">比如SETEX(在键不存在的情况下为键设置值)，那么我们可以基于这个命令来去实现一些简单的锁的操作&nbsp;</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">管道模式</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">管道技术：可以做到服务端未及时响应的时候，客户端也可以继续发送命令请求，做到客户 端和服务端互不影响，服务端并最终返回所有服务端的响应，大大提高了C/S模型交互的响应速度上有了质的提高&nbsp;</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">使用方法：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%2236d170fc7779070f6-6082657%22%2C%22oh%22%3A248%2C%22ow%22%3A739%2C%22uri%22%3A%22document_image%2F0a033b46-91c7-4d7b-b6fc-d8567f1f10ef-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/0a033b46-91c7-4d7b-b6fc-d8567f1f10ef-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis的应用架构</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">对于读多写少的高并发场景，我们会经常使用缓存来进行优化</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">比如说支付宝的余额展示功能，实际上99%的时候 都是查询，1%的请求是变更</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%221fb170fc79500b118-6082657%22%2C%22oh%22%3A821%2C%22ow%22%3A680%2C%22uri%22%3A%22document_image%2F0e699483-32a6-494d-b4ba-50c7a016e05b-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/0e699483-32a6-494d-b4ba-50c7a016e05b-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">数据一致性问题</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">如何更新缓存中的数据？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 我是先更新缓存中的数据再更新数据库的数据；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\2. 还是修改数据库中的数据再更新缓存中的数据</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">redis中的数据和数据库中的数据不可能保证事务性达到统一的，这个是毫无疑问的</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">基于当前的场景进行权衡降低出现不一致问题的出现概率</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">更新缓存还是让缓存失效</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> \1. 如果更新缓存的代价很小，那么可以先更新缓存，这个代价很小的意思是我不需要很复杂的计算去获得最新的 余额数字。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\2. 如果是更新缓存的代价很大，意味着需要通过多个接口调用和数据查询才能获得最新的结果，那么可以先淘汰 缓存。淘汰缓存以后后续的请求如果在缓存中找不到，自然去数据库中检索。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%221b2170fc82bf97143-6082657%22%2C%22oh%22%3A969%2C%22ow%22%3A1314%2C%22uri%22%3A%22document_image%2F8b69012a-097f-4aa0-ac52-0f10bbd69d5e-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/8b69012a-097f-4aa0-ac52-0f10bbd69d5e-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存常见问题：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存预热</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">用户请求数据之前，就把数据加载到缓存系统中</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">系统启动加载</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">定时加载</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存更新</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">定时更新</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">过期更新</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">写请求更新</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">先写数据库再写缓存：缓存数据库具有强一致性的要求</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">读请求更新</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存雪崩</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">原因：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">指设置缓存时采用了相同的过期时间，导致缓存在某一个时刻同时失效</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存服务器宕机宕机导致 缓存全面失效</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">请求全部转发到了DB层面，DB由于瞬间压力增大而导致崩溃。缓存失效导致的雪崩效应对底层系 统的冲击是很大的</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">解决方案：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 对缓存的访问，如果发现从缓存中取不到值，那么通过加锁或者队列的方式保证缓存的单进程操作，从而避免 失效时并发请求全部落到底层的存储系统上；但是这种方式会带来性能上的损耗</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\2. 将缓存失效的时间分散，降低每一个缓存过期时间的重复率 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\3. 如果是因为缓存服务器故障导致的问题</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一方面需要保证缓存服务器的高可用</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">另一方面，应用程序中可以采 用多级缓存</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存降级</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">访问量剧增时，导致服务出现问题，优先保证核心业务的运行，减少关闭非核心业务堆资源的使用</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">写降级</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">只进行cache的更新，然后异步更新到数据库中，保证最终的一致性</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">读降级</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存穿透</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存穿透是指查询一个根本不存在的数据，缓存和数据源都不会命中。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">危害：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存穿透问题可能会使后端数据源负载加大，由于很多后端数据源不具备高并发性，甚至可能造成后端数据源宕掉</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">解决方案：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访 问数据库，这种办法最简单粗暴。比如，”key” , “&amp;&amp;”。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\2. 根据缓存数据Key的设计规则，将不符合规则的key进行过滤 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的BitSet中，不存在的数据将会被拦截掉，从而避免了对底层存储系统的查询压力</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">布隆过滤器</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">简介：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一种空间效率极高的概率型算法和数据结构，主要用来 判断一个元素是否在集合中存在</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">是一个概率型的算法，所以会存在一定的误差，如果传入一个值去布隆过 滤器中检索，可能会出现检测存在的结果但是实际上可能是不存在的，但是肯定不会出现实际上不存在然后反馈存 在的结果</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter 通过极少的错误换取了存储空间的极大节省</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">原理：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。首先将位数组进行初始化，将里面每个位都设置位0。对于 集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数 组上面的一个点，然后将位数组对应的位置标记为1</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询：W通过哈希映射到位数组上的3个点。如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">至于k个哈希函数的取值为多少，能够最大化的降低错误率（因为哈希函数越多，映射冲突会越少），这个地方就 会涉及到最优的哈希函数个数的一个算法逻辑</span></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22bc170fc9a80f6092-6082657%22%2C%22oh%22%3A383%2C%22ow%22%3A1621%2C%22uri%22%3A%22document_image%2F7150f6c1-fc0b-4766-8c59-aaf6d9686d1d-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/7150f6c1-fc0b-4766-8c59-aaf6d9686d1d-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22e4170fc9abbd517-6082657%22%2C%22oh%22%3A324%2C%22ow%22%3A1446%2C%22uri%22%3A%22document_image%2F3783083b-e46c-41a9-8c99-8a5d1860a81f-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/3783083b-e46c-41a9-8c99-8a5d1860a81f-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li></ul></li></ul></li></ul></div>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>
</html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/redis%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86/" data-id="ck9lj0kbf000b9sva2f2x3vyu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-英语翻译" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91/" class="article-date">
  <time datetime="2020-03-26T06:54:40.055Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91/">英语翻译</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="英语翻译"><a href="#英语翻译" class="headerlink" title="英语翻译"></a>英语翻译</h2><p>翻译句子主要三种：简单句，并列句，复合句</p>
<ul>
<li>简单句：干掉修饰语，翻译主谓宾，然后修饰语一层一层的往上加<ul>
<li>简单句只有中心句+修饰语</li>
<li><strong>I will love  you</strong> ==for the rest of my life==</li>
</ul>
</li>
<li>并列句：找到并列连词，前一句简单句，后一句简单词，逐句翻译</li>
<li>复合句：找到关联词，劈开，先找主干：先主谓宾，再加修饰语，最后翻译从句<ul>
<li>从句主要有两大种：定语从句，同位语从句，其他从句均可视为修饰语<ul>
<li>关联词删除，==判断从句是否缺成分==（也就是是不是完整的一句话），缺的话就是定语，否则为同位语</li>
</ul>
</li>
<li>对于复合句而言，只要翻译对了主干就可以得到一部分的分</li>
</ul>
</li>
<li>关联词：<strong>关联词划分主，从句</strong><ul>
<li>that   which  ：定语，同位语从句</li>
<li>when why where who ：引导时间，原因，地点状语从句</li>
<li>and  while  but: 一般表示并列结构</li>
</ul>
</li>
</ul>
<p>翻译：完整，准确，通顺</p>
<ul>
<li><p>完整：简单句翻译主谓宾，并列句翻译每个句子的主谓宾，复合句翻译主干句</p>
</li>
<li><p>准确：单词句子翻译准确，无错误</p>
</li>
<li><p>通顺：语句通顺，符合中文阅读习惯</p>
</li>
<li><p>英文的嵌套思维转为中文思维</p>
</li>
</ul>
<p>下面举一个同位语的栗子</p>
<p>例句：But even as the number of English speakers expands further ,there are signs that the  predominance of the language may fade within the foreseeable future.</p>
<ul>
<li>逗号分隔的两个并列句，分别翻译</li>
<li>But even as the number of English speakers expands further <ul>
<li>as 和 with 一样 ，可以翻译为  随着。。。</li>
<li>但是，即使随着说英语的人数进一步增加</li>
</ul>
</li>
<li>there are signs ==that== the  predominance of the language may fade within the foreseeable future.<ul>
<li>去掉that后，从句仍然为一个独立的句子，所以为同位语</li>
<li>同位语的作用是为了对前文的补充说明的作用，所以翻译时“迹象表明：…”或者“迹象表明—”</li>
<li>先翻译前面：there are signs ：有迹象表明，该语言的优势在可预见的将来可能会消失。</li>
<li>再翻译后面： the  predominance of the language may fade within the foreseeable future.<ul>
<li><strong>the</strong>  predominance <strong>of</strong> the language ：<strong>a of b：这种类型 :翻译为：b的a</strong><ul>
<li>语言的优势</li>
</ul>
</li>
<li>句子比较简单：该语言的优势在可预见的将来可能会消失</li>
</ul>
</li>
<li>综合：迹象表明：该语言的优势在可预见的将来可能会消失。</li>
</ul>
</li>
<li>全句：但是，即使随着说英语的人数进一步增加，有迹象表明：该语言的优势在可预见的将来可能会消失。</li>
</ul>
<p>例句：Chomsky`s grammar should show pattens of language change <strong>that</strong> are indepent of the family tree.</p>
<ul>
<li>注意到这里的that引导的是定语从句（从句非完整的话），定语从句翻译时，从句要加主语：一般为:它，这</li>
<li>先翻译主句：Chomsky`s grammar should show pattens of language change<ul>
<li>乔姆斯基的语法应该显示了语言变化模式。</li>
</ul>
</li>
<li>从句，that翻译为 ：这  ：这独立于家谱</li>
<li>整合：乔姆斯基的语法应该显示了语言变化模式，这种模式独立于家谱</li>
<li>更好的翻译：乔姆斯基的语法应该显示独立于家谱的语言变化模式。</li>
</ul>
<p>例句：the virgin forest with its richness ==and== variety of trees was a real treasure-house ==which== extended from Maine all the way down to Georgia.</p>
<p>解析：</p>
<ul>
<li>这是一个复合句：which引导的定于从句</li>
<li>找主句：the virgin forest with its richness and variety of trees was a real treasure-house<ul>
<li>主句中的主谓宾：the virgin forest was a real treasure-house ：原始森林是一个真正的宝库</li>
<li>加修饰语：with its richness and variety of trees：丰富多样的树木</li>
<li>结合：拥有丰富且多样树木的原始森林是一个真正的宝库</li>
</ul>
</li>
<li>从句：which extended from <strong>Maine</strong> all the way down to <strong>Georgia</strong>.（大写的单词通常为人名，地名）<ul>
<li>which引导定语从句，这里直接翻译为  它</li>
<li>从缅因州一直延伸到佐治亚州</li>
</ul>
</li>
<li>整合：拥有丰富且多样树木的原始森林是一个真正的宝库，它从缅因州一直延伸到佐治亚州</li>
<li>注：这里的and前后为两个单词，并不构成句子</li>
</ul>
<hr>
<h4 id="英语二真题"><a href="#英语二真题" class="headerlink" title="英语二真题"></a>英语二真题</h4><ol start="19">
<li>It is easy to underestimate English writer James Herriot. He had such a pleasant, readable style that are might think that anyone could imitate it. How many times have I heard people say, “I could write a book, I just haven’t the time” Easily said. Not so easily done. James Herriot, contrary to popular opinion did not find it easy in his early days of, as he put it, “having a go at the writing game”. While he obviously had an abundance of natural talent, the final polished work that he have to the world was the result of years of practicing, re-writing and reading. Like the majority of authors, he had to suffer many disappointments and rejections along the way, but these made him all the more determined to succeed. Everything he achieved in life was earned the hard way and his success in the literacy field was no exception.</li>
</ol>
<ul>
<li>It is easy to underestimate English writer James Herriot. <ul>
<li>it is 。。。形式主语：这是很容易去低估英国作家家詹姆斯·赫里欧</li>
<li>形式主语在中文中是没有的，可以翻译为：詹姆斯·赫里欧是一位很容易让人低估的英国作家</li>
</ul>
</li>
<li>He had such a pleasant, readable style <strong>that</strong> are might think that anyone could imitate it.<ul>
<li>找到that将句子切开，这里是定语从句</li>
<li>他的作品有一种令人愉快、易读的风格，这种风格可能就让人以为任何人都能模仿他</li>
</ul>
</li>
<li>How many times have I heard people say     ,    “I could write a book, I just haven’t the time”<ul>
<li>逗号切开</li>
<li>How many times have I heard people say：我很多次（总是）听人说，</li>
<li>“I could write a book, I just haven’t the time” ：我也可以写书，也是没有时间</li>
</ul>
</li>
<li>Easily said. Not so easily done：容易说，但不容易做</li>
<li>James Herriot, <strong>contrary to popular opinion did not find it easy in his early days of,</strong> <strong>as he put it</strong>, “having a go at the writing game”. <ul>
<li>这种是属于插入语，在阅读理解中，逗号里面的句子都可以不用看：补充说明的作用，这里同样先跳过</li>
<li>James Herriot,as he put it, “having a go at the writing game”. ：詹姆斯·赫里欧，用他的话说，“在写作游戏中尝试”</li>
<li><strong>contrary to popular opinion did not find it easy in his early days of</strong> <ul>
<li><strong>contrary to popular opinion</strong> 与流行的观点相悖</li>
<li>did not find it easy in his early days of <ul>
<li>这句话少了主语，少了宾语</li>
<li>主语是James Herriot，宾语为“having a go at the writing game”</li>
<li>结合就是James Herriot did not find it easy <strong>in his early days</strong> of “having a go at the writing game”  ：詹姆斯·赫里欧在他早期，发现“在写作游戏中尝试”并不容易</li>
</ul>
</li>
</ul>
</li>
<li>整合：与大众的观点相反，詹姆斯·赫里欧在他早期发现，用他的话说，“在写作游戏中尝试”并不容易。</li>
</ul>
</li>
<li>While he obviously had an abundance of natural talent, the final polished work that he have to the world was the result of years of practicing, re-writing and reading.<ul>
<li>while 引导并列，前后两个句子分别翻译（while引导的是转折）</li>
<li>While he obviously had an abundance of natural talent：他显然极具天赋</li>
<li>the final polished work <strong>that</strong> he have to the world <strong>was</strong> the result of years of practicing, re-writing and reading<ul>
<li>that引导的定语从句，was谓语，切成三分</li>
<li>主：the final polished work，谓:was,宾：the result of years of practicing, re-writing and reading（a of b）：b的a   ：… 的结果 <ul>
<li>翻译：他最终出版的作品是多年练习、重写和阅读的结果</li>
</ul>
</li>
<li>最后加上修饰语（定语从句）： <strong>that</strong> he have to the world缺少的主语是出版的作品</li>
</ul>
</li>
<li>整合：但他留给世人的最终出版作品却是多年练习、重写和阅读的结果</li>
</ul>
</li>
<li>Like the majority of authors, he had to suffer many disappointments and rejections along the way, <strong>but</strong> these made him all the more determined to succeed<ul>
<li>并列的简单句，分别翻译</li>
<li>Like the majority of authors, he had to suffer many disappointments and rejections along the way,<ul>
<li>和大多数作家一样，他在写作过程中也遭受了许多失望和拒绝</li>
</ul>
</li>
<li><strong>but</strong> these made him all the more determined to succeed：但这些都使他更加坚定了成功的决心</li>
</ul>
</li>
<li>Everything he achieved in life <strong>was</strong> earned the hard way <strong>and</strong> his success in the literacy field <strong>was</strong> no exception.<ul>
<li>and引导的并列句，分别翻译</li>
<li>Everything he achieved in life <strong>was</strong> earned the hard way ：<ul>
<li>Everything he achieved in life 其实也是定语从句这里只是省略了that，因为句子过于简单</li>
<li>直译：他人生中取得的一切都是以一种困难的方式获得</li>
<li>意译：他人生中所取得的一切成就都是来之不易的</li>
</ul>
</li>
<li>his success in the literacy field <strong>was</strong> no exception：他在文学领域的成功也不例外</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91/" data-id="ck9lj0kap00059svabe0hes29" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法作业" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/" class="article-date">
  <time datetime="2020-03-26T06:54:23.728Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/">算法作业</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="算法作业"><a href="#算法作业" class="headerlink" title="算法作业"></a>算法作业</h2><h4 id="解决方案的整体描述"><a href="#解决方案的整体描述" class="headerlink" title="解决方案的整体描述"></a>解决方案的整体描述</h4><ul>
<li>库所(Place)、变迁(Transition)、弧线(Arc)创建统一的节点类：id ， name ， token等</li>
<li>实现接口方法<ul>
<li>导入jdom工具包，用于解析xml文件</li>
<li>遍历xml文件，提取出库所(Place)、变迁(Transition)、弧线(Arc)中的信息依次封装入节点对象</li>
<li>确定输入库所，输出库所</li>
<li>使用数组来存放每个节的令牌信息</li>
<li>从输入库所开始使用广度优先遍历<ul>
<li>如果是库所：确定其相邻的变迁是否可达，可达的话递归遍历该变迁</li>
<li>如果是变迁：确定其是否被重复遍历，最多只能遍历二次，前库所相应令牌减一，后库所加一，再依次对后库所进行递归</li>
</ul>
</li>
<li>对结果写入到文件中</li>
</ul>
</li>
</ul>
<h4 id="整体解决方案的伪代码"><a href="#整体解决方案的伪代码" class="headerlink" title="整体解决方案的伪代码"></a>整体解决方案的伪代码</h4><ul>
<li><pre><code class="伪代码">类 node{
    id  name  token
    出节点列表  入节点列表
}
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="deletion">-</span></span><br></pre></td></tr></table></figure>
 getLogOfModel(String modelFile, String logFile) 
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="deletion">-</span></span><br></pre></td></tr></table></figure>
placeChildren = xml解析出的place集合
transitionChildren = xml解析出的transition
ArcChildren = xml解析出的Arc集合
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="deletion">-</span></span><br></pre></td></tr></table></figure>
for _ in xml解析出的place集合
    Node node = new Node(id name tocken)
for _ in xml解析出的transition集合
    Node node = new Node(id name tocken)
for _ in xml解析出的Arc集合
    出节点，入节点
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="deletion">-</span></span><br></pre></td></tr></table></figure>
BFS:
    if 是库所：
  for next in 所有相邻的变迁
        for (Node pre : next.in)
                    if (toKen[pre]] &lt;= 0)
                        该next变得不可达;
        if next 可达：
            加入遍历队列
           for i in 遍历队列:
               remove(i)
               递归bfs
else 为变迁：
    if 变迁访问了三次：
        则该路不通
    for (Node preNode : cur.in)：//遍历其前节点
        tocken[prenode]-=1
    for (Node nextNode : cur.out)：//遍历其后节点
        tocken[nextnode]+=1
        if nextnode == end：
            return
    curBFSNode.addAll(cur.out);
    for (Node next : curBFSNode) ：
        remove(next)
        BFS递归
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="deletion">-</span></span><br></pre></td></tr></table></figure>
writeTxt(logFile, string) // 写入文件中
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 解决方案各个模块的描述</span><br><span class="line"></span><br><span class="line">- 创建类的节点</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
  类 node{ 
      id  name  token
      isplace //是否为库所
      出节点列表  入节点列表
  }
  <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-<span class="ruby"> 引用第三方解析xml库</span></span><br><span class="line"></span><br><span class="line"><span class="ruby">  -</span></span><br></pre></td></tr></table></figure>
  //1.创建SAXBuilder对象
  SAXBuilder saxBuilder = new SAXBuilder();
  //2.加载文件流
  Document document = saxBuilder.build(new FileInputStream(new File(modelFile));
  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 解析xml</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
  for _ in xml解析出的place集合
      Node node = new Node(id name tocken)
      map.put(id,node)
  for _ in xml解析出的transition集合
      Node node = new Node(id name tocken)
      map.put(id,node)
  for _ in xml解析出的Arc集合
      //设置出节点，入节点
      arc(2).innode.(arc(1))
      arc(1).outnode.add(arc(2))
  <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-<span class="ruby"> 确定输入，输出库所</span></span><br><span class="line"></span><br><span class="line"><span class="ruby">  -</span></span><br></pre></td></tr></table></figure>
  for node in map.values:
      if node.isplace == true &amp;&amp; node.innode.size==0&amp;&amp;node.outnode&gt;0:
          输入库所
      else if (node.isPlace==true &amp;&amp; node.inNode.size&gt;0 &amp;&amp; node.outNode.size 、== 0)
          输出库所
  <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-<span class="ruby"> BFS</span></span><br><span class="line"></span><br><span class="line"><span class="ruby">  -</span></span><br></pre></td></tr></table></figure>
  if 是库所：
      for next in 所有相邻的变迁
          for (Node pre : next.in)
                      if (toKen[pre]] &lt;= 0)
                          该next变得不可达;
          if next 可达：
              加入遍历队列
             for i in 遍历队列:
                 remove(i)
                 递归bfs
  else 为变迁：
      if 变迁访问了三次：
          则该路不通
      for (Node preNode : cur.in)：//遍历其前节点
          tocken[prenode]-=1
      for (Node nextNode : cur.out)：//遍历其后节点
          tocken[nextnode]+=1
          if nextnode == end：
              return
      curBFSNode.addAll(cur.out);
      for (Node next : curBFSNode) ：
          remove(next)
          BFS递归
  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 写入文件</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
      if (file.exists()) {
          file.createNewFile();
          }
        fileOutputStream = new FileOutputStream(file);
        fileOutputStream.write(content.getBytes());
        fileOutputStream.flush();
        fileOutputStream.close();</code></pre>
</li>
</ul>
<h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><ul>
<li>第一个</li>
</ul>
<p><img src="C:%5CUsers%5C%E5%8D%97%E5%A4%A7%E5%AE%8B%E4%BB%B2%E5%9F%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191228230942308.png" alt="image-20191228230942308"></p>
<ul>
<li><p>结果</p>
<ul>
<li><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191228231001428.png" alt="image-20191228231001428" style="zoom:100%;" />
</li>
</ul>
</li>
<li><p>第二个</p>
</li>
</ul>
<p><img src="C:%5CUsers%5C%E5%8D%97%E5%A4%A7%E5%AE%8B%E4%BB%B2%E5%9F%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191228231331612.png" alt="image-20191228231331612"></p>
<ul>
<li>结果<ul>
<li><img src="C:%5CUsers%5C%E5%8D%97%E5%A4%A7%E5%AE%8B%E4%BB%B2%E5%9F%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191228231307718.png" alt="image-20191228231307718"></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/" data-id="ck9lj0kam00039sva6qvs024n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time datetime="2020-03-26T06:54:07.935Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">java基础知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="javase"><a href="#javase" class="headerlink" title="javase"></a>javase</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>1.jdk与jre</p>
<ul>
<li>JDK：Java Development Kit</li>
<li>JRE：Java Runtime Environment</li>
</ul>
<p>简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ┌─    ┌──────────────────────────────────┐</span><br><span class="line"> │     │     Compiler, debugger, etc.     │</span><br><span class="line"> │     └──────────────────────────────────┘</span><br><span class="line">JDK ┌─ ┌──────────────────────────────────┐</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> │ JRE │      JVM + Runtime Library       │</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> └─ └─ └──────────────────────────────────┘</span><br><span class="line">       ┌───────┐┌───────┐┌───────┐┌───────┐</span><br><span class="line">       │Windows││ Linux ││ macOS ││others │</span><br><span class="line">       └───────┘└───────┘└───────┘└───────┘</span><br></pre></td></tr></table></figure>

<p>2.如何运行java文件？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────────┐</span><br><span class="line">│    Hello.java    │&lt;─── source code</span><br><span class="line">└──────────────────┘</span><br><span class="line">          │ compile</span><br><span class="line">          ▼</span><br><span class="line">┌──────────────────┐</span><br><span class="line">│   Hello.class    │&lt;─── byte code</span><br><span class="line">└──────────────────┘</span><br><span class="line">          │ execute</span><br><span class="line">          ▼</span><br><span class="line">┌──────────────────┐</span><br><span class="line">│    Run on JVM    │</span><br><span class="line">└──────────────────┘</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>javac</code>可以将<code>.java</code>源码编译成<code>.class</code>字节码；</li>
<li>使用<code>java</code>可以运行一个已编译的Java程序，参数是类名。</li>
</ul>
<hr>
<h4 id="java程序基础"><a href="#java程序基础" class="headerlink" title="java程序基础"></a>java程序基础</h4><ul>
<li><p>基本数据类型</p>
<ul>
<li>整数类型：byte，short，int，long</li>
<li>浮点数类型：float，double</li>
<li>字符类型：char</li>
<li>布尔类型：boolean</li>
</ul>
</li>
<li><p>占用字节数</p>
<ul>
<li><pre><code class="ascii">       ┌───┐
  byte │   │   1
       └───┘
       ┌───┬───┐
 short │   │   │ 2 
       └───┴───┘
       ┌───┬───┬───┬───┐
   int │   │   │   │   │ 4
       └───┴───┴───┴───┘
       ┌───┬───┬───┬───┬───┬───┬───┬───┐
  long │   │   │   │   │   │   │   │   │ 8
       └───┴───┴───┴───┴───┴───┴───┴───┘
       ┌───┬───┬───┬───┐
 float │   │   │   │   │ 4
       └───┴───┴───┴───┘
       ┌───┬───┬───┬───┬───┬───┬───┬───┐
double │   │   │   │   │   │   │   │   │ 8
       └───┴───┴───┴───┴───┴───┴───┴───┘
       ┌───┬───┐
  char │   │   │ 2
       └───┴───┘
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    `byte`恰好就是一个字节，而`long`和`<span class="built_in">double</span>`需要<span class="number">8</span>个字节。</span><br><span class="line"></span><br><span class="line">- 整型</span><br><span class="line"></span><br><span class="line">  - 对于整型类型，Java只定义了带符号的整型，因此，**最高位的bit表示符号位**（<span class="number">0</span>表示正数，<span class="number">1</span>表示负数）。各种整型能表示的最大范围如下：</span><br><span class="line"></span><br><span class="line">    - byte：<span class="number">-128</span> ~ <span class="number">127</span>      **<span class="number">2</span>^<span class="number">7</span>**</span><br><span class="line">    - short: <span class="number">-32768</span> ~ <span class="number">32767</span>    **<span class="number">2</span>^<span class="number">15</span>**</span><br><span class="line">    - <span class="built_in">int</span>: <span class="number">-2147483648</span> ~ <span class="number">2147483647</span>   **<span class="number">2</span>^<span class="number">31</span>**</span><br><span class="line">    - long: <span class="number">-9223372036854775808</span> ~ <span class="number">9223372036854775807</span></span><br><span class="line"></span><br><span class="line">  - 通常**JVM内部会把`<span class="built_in">bool</span>ean`表示为<span class="number">4</span>字节整数。**</span><br><span class="line"></span><br><span class="line">  - 整性运算</span><br><span class="line"></span><br><span class="line">    - 整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分</span><br><span class="line">    - 特别注意：**整数的除法对于除数为<span class="number">0</span>时运行时将报错，但编译不会报错。**</span><br><span class="line"></span><br><span class="line">  - 溢出</span><br><span class="line"></span><br><span class="line">    - 要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出*不会出错*，却会得到一个奇怪的结果</span><br><span class="line"></span><br><span class="line">    - eg</span><br><span class="line"></span><br><span class="line">      - 要解释上述结果，我们把整数`<span class="number">2147483640</span>`和`<span class="number">15</span>`换成二进制做加法：</span><br><span class="line"></span><br><span class="line">        ```ascii</span><br><span class="line">          <span class="number">0111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1000</span></span><br><span class="line">        + <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span></span><br><span class="line">        -----------------------------------------</span><br><span class="line">          <span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span></span><br></pre></td></tr></table></figure>

    由于最高位计算结果为`1`，因此，加法结果变成了一个负数</code></pre>
</li>
<li><p>类型自动提升和强制转型</p>
<ul>
<li>在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型（<strong>自动提升</strong>）</li>
<li>将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用<code>(类型)</code><ul>
<li>超出范围的强制转型会得到错误的结果，原因是int转型short，<code>int</code>的两个高位字节直接被扔掉，仅保留了低位的两个字节</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>浮点型</p>
<ul>
<li><p>只能进行加减乘除这些数值计算，不能做位运算和移位运算</p>
</li>
<li><p><strong>浮点数无法精确表示</strong>，比如十进制的<code>0.1</code>换算成二进制是一个无限循环小数</p>
</li>
<li><p><strong>正确的比较方法</strong>：判断两个浮点数之差的绝对值是否小于一个很小的数</p>
</li>
<li><p><strong>自动类型提升</strong>：整性与浮点型运算时，自动转化为浮点型</p>
</li>
<li><p><strong>强制转型</strong>：可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉</p>
</li>
<li><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>整数运算在除数为<code>0</code>时会报错，而浮点数运算在除数为<code>0</code>时，不会报错，但会返回几个特殊值：</p>
<ul>
<li><code>NaN</code>表示Not a Number</li>
<li><code>Infinity</code>表示无穷大</li>
<li><code>-Infinity</code>表示负无穷大</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>字符串</p>
<ul>
<li><p>字符串的不可变性</p>
<ul>
<li><p>执行<code>String s = &quot;hello&quot;;</code>时，JVM虚拟机先创建字符串<code>&quot;hello&quot;</code>，然后，把字符串变量<code>s</code>指向它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      s</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌───┬───────────┬───┐</span><br><span class="line">│   │  &quot;hello&quot;  │   │</span><br><span class="line">└───┴───────────┴───┘</span><br></pre></td></tr></table></figure>

<p>紧接着，执行<code>s = &quot;world&quot;;</code>时，JVM虚拟机先创建字符串<code>&quot;world&quot;</code>，然后，把字符串变量<code>s</code>指向它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      s ──────────────┐</span><br><span class="line">                      │</span><br><span class="line">                      ▼</span><br><span class="line">┌───┬───────────┬───┬───────────┬───┐</span><br><span class="line">│   │  &quot;hello&quot;  │   │  &quot;world&quot;  │   │</span><br><span class="line">└───┴───────────┴───┴───────────┴───┘</span><br></pre></td></tr></table></figure>

<p>原来的字符串<code>&quot;hello&quot;</code>还在，只是我们无法通过变量<code>s</code>访问它而已。因此，字符串的不可变是指字符串内容不可变。</p>
</li>
</ul>
</li>
<li><p>注意要区分空值<code>null</code>和空字符串<code>&quot;&quot;</code>，空字符串是一个有效的字符串对象，它不等于<code>null</code></p>
</li>
<li><p>数组字符串</p>
<ul>
<li><p>字符串是引用类型，因此我们先定义一个字符串数组：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>[] names = &#123;</span><br><span class="line">    <span class="string">"ABC"</span>, <span class="string">"XYZ"</span>, <span class="string">"zoo"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于<code>String[]</code>类型的数组变量<code>names</code>，它实际上包含3个元素，但每个元素都指向某个字符串对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          ┌─────────────────────────┐</span><br><span class="line">    names │   ┌─────────────────────┼───────────┐</span><br><span class="line">      │   │   │                     │           │</span><br><span class="line">      ▼   │   │                     ▼           ▼</span><br><span class="line">┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┐</span><br><span class="line">│   │░░░│░░░│░░░│   │ &quot;ABC&quot; │   │ &quot;XYZ&quot; │   │ &quot;zoo&quot; │   │</span><br><span class="line">└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┘</span><br><span class="line">      │                 ▲</span><br><span class="line">      └─────────────────┘</span><br></pre></td></tr></table></figure>

<p>对<code>names[1]</code>进行赋值，例如<code>names[1] = &quot;cat&quot;;</code>，效果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          ┌─────────────────────────────────────────────────┐</span><br><span class="line">    names │   ┌─────────────────────────────────┐           │</span><br><span class="line">      │   │   │                                 │           │</span><br><span class="line">      ▼   │   │                                 ▼           ▼</span><br><span class="line">┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┬───────┬───┐</span><br><span class="line">│   │░░░│░░░│░░░│   │ &quot;ABC&quot; │   │ &quot;XYZ&quot; │   │ &quot;zoo&quot; │   │ &quot;cat&quot; │   │</span><br><span class="line">└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┴───────┴───┘</span><br><span class="line">      │                 ▲</span><br><span class="line">      └─────────────────┘</span><br></pre></td></tr></table></figure>

<p>这里注意到原来<code>names[1]</code>指向的字符串<code>&quot;XYZ&quot;</code>并没有改变，仅仅是将<code>names[1]</code>的引用从指向<code>&quot;XYZ&quot;</code>改成了指向<code>&quot;cat&quot;</code>，其结果是字符串<code>&quot;XYZ&quot;</code>再也无法通过<code>names[1]</code>访问到了。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数组</p>
<ul>
<li>二维数组就是数组的数组，三维数组就是二维数组的数组；</li>
<li>多维数组的每个数组元素长度都不要求相同；</li>
<li>打印多维数组可以使用<code>Arrays.deepToString()</code>；</li>
</ul>
</li>
</ul>
<ul>
<li>命令行参数<ul>
<li>命令行参数类型是<code>String[]</code>数组；</li>
<li>命令行参数由JVM接收用户输入并传给<code>main</code>方法；</li>
<li>如何解析命令行参数需要由程序自己实现。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul>
<li><p>重载</p>
<ul>
<li>方法重载是指多个方法的方法名相同，但各自的参数不同；</li>
<li>重载方法应该完成类似的功能，参考<code>String</code>的<code>indexOf()</code>；</li>
<li>重载方法返回值类型应该相同。</li>
</ul>
</li>
<li><p>继承</p>
<ul>
<li><p>如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法</p>
</li>
<li><p>向上转型：</p>
<ul>
<li><p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">Person p = s; <span class="comment">// upcasting, ok</span></span><br><span class="line">Object o1 = p; <span class="comment">// upcasting, ok</span></span><br><span class="line">Object o2 = s; <span class="comment">// upcasting, ok</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>向下转型：父类类型强制转型为子类类型</p>
<ul>
<li><pre><code>Person p1 = new Student(); // upcasting, ok
Person p2 = new Person();
Student s1 = (Student) p1; // ok
Student s2 = (Student) p2; // runtime error! ClassCastException!
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  测试上面的代码，可以发现：</span><br><span class="line"></span><br><span class="line">  `Person`类型`p1`实际指向`Student`实例，`Person`类型变量`p2`实际指向`Person`实例。在向下转型的时候，把`p1`转型为`Student`会成功，因为`p1`确实指向`Student`实例，把`p2`转型为`Student`会失败，因为`p2`的实际类型是`Person`，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。</span><br><span class="line"></span><br><span class="line">  因此，向下转型很可能会失败。失败的时候，Java虚拟机会报`ClassCastException`。</span><br><span class="line"></span><br><span class="line">- 利用`instanceof`，在向下转型前可以先判断：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  Person p = <span class="keyword">new</span> Student()<span class="comment">;</span></span><br><span class="line">  if (p instanceof Student) &#123;</span><br><span class="line"><span class="title">      // 只有判断成功才会向下转型:</span></span><br><span class="line">      Student s = (Student) p<span class="comment">; // 一定会成功</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>多态：针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法</p>
<ul>
<li>允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码</li>
<li>子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；</li>
<li>Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；</li>
<li><code>final</code>修饰符有多种作用：<ul>
<li><code>final</code>修饰的方法可以阻止被覆写；</li>
<li><code>final</code>修饰的class可以阻止被继承；</li>
<li><code>final</code>修饰的field必须在创建对象时初始化，随后不可修改。</li>
</ul>
</li>
</ul>
</li>
<li><p>抽象</p>
<ul>
<li>通过<code>abstract</code>定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；</li>
<li>定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；</li>
<li>如果不实现抽象方法，则该子类仍是一个抽象类；</li>
<li>面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。</li>
</ul>
</li>
<li><p>接口</p>
<ul>
<li><p>Java的接口（interface）定义了纯抽象规范，一个类可以实现多个接口；</p>
</li>
<li><p>接口也是数据类型，适用于向上转型和向下转型；</p>
</li>
<li><p>接口的所有方法都是抽象方法，接口不能定义实例字段；</p>
</li>
<li><p><code>interface</code>的字段只能是<code>public static final</code>类型</p>
</li>
<li><p>接口可以定义<code>default</code>方法（JDK&gt;=1.8）</p>
<ul>
<li>实现类可以不必覆写<code>default</code>方法</li>
<li>新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法</li>
<li><code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</li>
</ul>
</li>
<li><p>接口与抽象区别</p>
<ul>
<li><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">abstract class</th>
<th align="center">interface</th>
</tr>
</thead>
<tbody><tr>
<td align="left">继承</td>
<td align="left">只能extends一个class</td>
<td align="center">可以implements多个interface</td>
</tr>
<tr>
<td align="left">字段</td>
<td align="left">可以定义实例字段</td>
<td align="center">不能定义实例字段</td>
</tr>
<tr>
<td align="left">抽象方法</td>
<td align="left">可以定义抽象方法</td>
<td align="center">可以定义抽象方法</td>
</tr>
<tr>
<td align="left">非抽象方法</td>
<td align="left">可以定义非抽象方法</td>
<td align="center">可以定义default方法</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><p>static关键字</p>
<ul>
<li>静态字段<ul>
<li>静态字段并不属于实例，而属于class，所有实例共享一个静态字段</li>
<li>实例对象能访问静态字段：编译器根据实例类型自动转换为<code>类名.静态字段</code>来访问静态对象（<strong>不推荐</strong>）</li>
</ul>
</li>
<li>静态方法<ul>
<li>调用静态方法不需要实例，无法访问<code>this</code>，但可以访问静态字段和其他静态方法；</li>
<li>常用作辅助方法：<ul>
<li>Arrays.sort()</li>
<li>Math.random()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>包</p>
<ul>
<li>Java内建的<code>package</code>机制是为了避免<code>class</code>命名冲突；- </li>
<li>JDK的核心类使用<code>java.lang</code>包，编译器会自动导入；</li>
<li>JDK的其它常用类定义在<code>java.util.*</code>，<code>java.math.*</code>，<code>java.text.*</code>，……；</li>
<li>包名推荐使用倒置的域名，例如<code>org.apache</code>。</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li>Java内建的访问权限包括<code>public</code>、<code>protected</code>、<code>private</code>和<code>package</code>权限；</li>
<li>Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束；</li>
<li><code>final</code>修饰符不是访问权限，它可以修饰<code>class</code>、<code>field</code>和<code>method</code>；<ul>
<li>用<code>final</code>修饰<code>class</code>可以阻止被继承</li>
<li>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写</li>
<li>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值</li>
<li>用<code>final</code>修饰局部变量可以阻止被重新赋值</li>
</ul>
</li>
<li>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="java核心类"><a href="#java核心类" class="headerlink" title="java核心类"></a>java核心类</h4><ul>
<li><p>String</p>
<ul>
<li><pre><code class="java">String`是一个引用类型，它本身也是一个`<span class="class"><span class="keyword">class</span></span>
<span class="class"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 字符串在`<span class="keyword">String</span>`内部是通过一个`<span class="keyword">char</span>[]`数组表示的，因此，按下面的写法也是可以的：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">String</span> s2 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'!'</span>&#125;);</span><br></pre></td></tr></table></figure></span></code></pre>
</li>
<li><p><strong>字符串<em>不可变</em></strong>。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的。</p>
</li>
</ul>
</li>
<li><p>字符串比较</p>
<ul>
<li><p>比较是否相同：使用<code>equals()</code>方法而不能用<code>==</code></p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        String s1 = <span class="string">"hello"</span>;
        String s2 = <span class="string">"hello"</span>;
        System.out.println(s1 == s2);
        System.out.println(s1.equals(s2));
    }
}
&lt;!--￼<span class="number">11</span>--&gt;

而较新的JDK版本的`String`则以`<span class="keyword">byte</span>[]`存储：如果`String`仅包含ASCII字符，则每个`<span class="keyword">byte</span>`存储一个字符，否则，每两个`<span class="keyword">byte</span>`存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的`String`通常仅包含ASCII字符：

&lt;!--￼<span class="number">12</span>--&gt;

对于使用者来说，`String`内部的优化不影响任何已有代码，因为它的`<span class="keyword">public</span>`方法签名是不变的。</code></pre>
</li>
</ul>
</li>
<li><p>StringBuilder</p>
<ul>
<li><pre><code class="java">String s = <span class="string">""</span>;
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {
    s = s + <span class="string">","</span> + i;
}
&lt;!--￼<span class="number">13</span>--&gt;</code></pre>
</li>
<li><p>支持链式操作</p>
<ul>
<li>链式操作的关键是，定义的<code>append()</code>方法会返回<code>this</code></li>
</ul>
</li>
<li><p><code>StringBuffer</code>是<code>StringBuilder</code>的线程安全版本，现在很少使用</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>Java的异常是<code>class</code>，它的继承关系如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                     ┌───────────┐</span><br><span class="line">                     │  Object   │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                           │</span><br><span class="line">                     ┌───────────┐</span><br><span class="line">                     │ Throwable │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                 ┌─────────┴─────────┐</span><br><span class="line">                 │                   │</span><br><span class="line">           ┌───────────┐       ┌───────────┐</span><br><span class="line">           │   Error   │       │ Exception │</span><br><span class="line">           └───────────┘       └───────────┘</span><br><span class="line">                 ▲                   ▲</span><br><span class="line">         ┌───────┘              ┌────┴──────────┐</span><br><span class="line">         │                      │               │</span><br><span class="line">┌─────────────────┐    ┌─────────────────┐┌───────────┐</span><br><span class="line">│OutOfMemoryError │... │RuntimeException ││IOException│...</span><br><span class="line">└─────────────────┘    └─────────────────┘└───────────┘</span><br><span class="line">                                ▲</span><br><span class="line">                    ┌───────────┴─────────────┐</span><br><span class="line">                    │                         │</span><br><span class="line">         ┌─────────────────────┐ ┌─────────────────────────┐</span><br><span class="line">         │NullPointerException │ │IllegalArgumentException │...</span><br></pre></td></tr></table></figure>

<p>从继承关系可知：<code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p>
<ul>
<li><code>OutOfMemoryError</code>：内存耗尽</li>
<li><code>NoClassDefFoundError</code>：无法加载某个Class</li>
<li><code>StackOverflowError</code>：栈溢出</li>
</ul>
<p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p>
<p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p>
<ul>
<li><code>NumberFormatException</code>：数值类型的格式错误</li>
<li><code>FileNotFoundException</code>：未找到文件</li>
<li><code>SocketException</code>：读取网络失败</li>
</ul>
<p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p>
<ul>
<li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li>
<li><code>IndexOutOfBoundsException</code>：数组索引越界</li>
</ul>
<p><strong>java规定：</strong></p>
<ul>
<li>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为Checked Exception。</li>
<li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li>
</ul>
<p>抛出异常：</p>
<p>调用<code>printStackTrace()</code>可以打印异常的传播栈，对于调试非常有用；</p>
<p>捕获异常并再次抛出新的异常时，应该持有原始异常信息；</p>
<p>通常不要在<code>finally</code>中抛出异常。如果在<code>finally</code>中抛出异常，应该原始异常加入到原有异常中。调用方可通过<code>Throwable.getSuppressed()</code>获取所有添加的<code>Suppressed Exception</code>。</p>
<hr>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>def：反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息</p>
<p>targe：反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法</p>
<ul>
<li><p>class</p>
<ul>
<li><p>JVM为每个加载的<code>class</code>及<code>interface</code>创建了对应的<code>Class</code>实例来保存<code>class</code>及<code>interface</code>的所有信息</p>
<ul>
<li><p>除了基本类型（int）外，其他均为class</p>
</li>
<li><p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = <span class="keyword">new</span> Class(String);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>获取一个<code>class</code>对应的<code>Class</code>实例后，就可以获取该<code>class</code>的所有信息；</p>
<ul>
<li><p>一个<code>Class</code>实例包含了该<code>class</code>的所有完整信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = <span class="string">"java.lang.String"</span>  │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│<span class="keyword">package</span> = <span class="string">"java.lang"</span>      │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│<span class="keyword">super</span> = <span class="string">"java.lang.Object"</span> │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│<span class="class"><span class="keyword">interface</span> </span>= CharSequence...│</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│field = value[],hash,...   │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│method = indexOf()...      │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>通过Class实例获取<code>class</code>信息的方法称为反射（Reflection）；</p>
<ul>
<li><p>如何获取一个<code>class</code>的<code>Class</code>实例？有三个方法：</p>
<p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello"</span>;</span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></table></figure>

<p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>JVM总是动态加载<code>class</code>，可以在运行期根据条件来控制加载class</p>
</li>
<li><p>因为<code>Class</code>实例在JVM中是唯一的，所以，上述方法获取的<code>Class</code>实例是同一个实例。可以用<code>==</code>比较两个<code>Class</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class cls1 = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">String s = <span class="string">"Hello"</span>;</span><br><span class="line">Class cls2 = s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> sameClass = cls1 == cls2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JVM动态加载<code>class</code>的特性：jvm只有使用到某个类时才会加载到内存</p>
</li>
</ul>
</li>
<li><p>访问字段</p>
<ul>
<li><p>Java的反射API提供的<code>Field</code>类封装了字段的所有信息：</p>
</li>
<li><p>通过<code>Class</code>实例的方法可以获取<code>Field</code>实例：<code>getField()</code>，<code>getFields()</code>，<code>getDeclaredField()</code>，<code>getDeclaredFields()</code>；</p>
</li>
<li><p>通过Field实例可以获取字段信息：<code>getName()</code>，<code>getType()</code>，<code>getModifiers()</code>；</p>
</li>
<li><p>通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用<code>setAccessible(true)</code>来访问非<code>public</code>字段。</p>
</li>
<li><p>通过反射读写字段是一种非常规方法，它会破坏对象的封装。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”</p>
<p>Java的注解可以分为三类：</p>
<ul>
<li>第一类是由编译器使用的注解，例如：<ul>
<li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li>
<li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li>
<li>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</li>
</ul>
</li>
<li>第二类是由工具处理<code>.class</code>文件使用的注解，这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</li>
<li>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</li>
</ul>
<hr>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul>
<li><p>简介</p>
<ul>
<li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li>
<li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li>
<li><code>Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>接口与实现分离</li>
<li>支持泛型</li>
</ul>
</li>
<li><p>Java集合使用统一的<code>Iterator</code>遍历</p>
</li>
<li><p>list：顺序列表</p>
<ul>
<li><code>ArrayList</code><ul>
<li>在内部使用了数组来存储所有元素</li>
<li>数组已满，没有空闲位置的时候，<code>ArrayList</code>先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组</li>
<li>添加和删除的操作封装起来，让我们操作<code>List</code>类似于操作数组，却不用关心内部元素如何移动</li>
</ul>
</li>
<li>LinkedList<ul>
<li>链表形式</li>
</ul>
</li>
</ul>
</li>
<li><p>比较一下<code>ArrayList</code>和<code>LinkedList</code>：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">ArrayList</th>
<th align="left">LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取指定元素</td>
<td align="left">速度很快</td>
<td align="left">需要从头开始查找元素</td>
</tr>
<tr>
<td align="left">添加元素到末尾</td>
<td align="left">速度很快</td>
<td align="left">速度很快</td>
</tr>
<tr>
<td align="left">在指定位置添加/删除</td>
<td align="left">需要移动元素</td>
<td align="left">不需要移动元素</td>
</tr>
<tr>
<td align="left">内存占用</td>
<td align="left">少</td>
<td align="left">较大</td>
</tr>
</tbody></table>
</li>
<li><p>equals</p>
<ul>
<li><p><code>List</code>的实现类通过元素的<code>equals()</code>方法比较两个元素是否相等</p>
</li>
<li><p>Java标准库提供的<code>String</code>、<code>Integer</code>等已经覆写了<code>equals()</code>方法</p>
</li>
<li><p>自定义的对象需要覆写euquals方法</p>
<ul>
<li><p>如何正确编写<code>equals()</code>方法？<code>equals()</code>方法要求我们必须满足以下条件：</p>
<ul>
<li>自反性（Reflexive）：对于非<code>null</code>的<code>x</code>来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li>
<li>对称性（Symmetric）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li>
<li>传递性（Transitive）：对于非<code>null</code>的<code>x</code>、<code>y</code>和<code>z</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>；</li>
<li>一致性（Consistent）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，只要<code>x</code>和<code>y</code>状态不变，则<code>x.equals(y)</code>总是一致地返回<code>true</code>或者<code>false</code>；</li>
<li>对<code>null</code>的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li>
</ul>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>{
    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) {
        Person p = (Person) o;
        <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}
&lt;!--￼<span class="number">21</span>--&gt;


</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- **`entrySet()`集合**

  - ```java
    for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
                String key = entry.getKey();
                Integer value = entry.getValue();
                System.out.println(key + &quot; = &quot; + value);
            }
    <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 在`Map`的内部，对`key`做比较是通过`equals()`实现的</span><br><span class="line"></span><br><span class="line">    - 使用`String`作为`key`，因为`String`已经正确覆写了`equals()`方法</span><br><span class="line"></span><br><span class="line">    - 编写`equals()`和`hashCode()`遵循的原则是：</span><br><span class="line"></span><br><span class="line">      - `equals()`用到的用于比较的每一个字段，都必须在`hashCode()`中用于计算；</span><br><span class="line">      - `equals()`中没有使用到的字段，绝不可放在`hashCode()`中计算。</span><br><span class="line"></span><br><span class="line">      另外注意，对于放入`HashMap`的`value`对象，没有任何要求</span><br><span class="line"></span><br><span class="line">### 延伸阅读</span><br><span class="line"></span><br><span class="line">既然`HashMap`内部使用了数组，通过计算`key`的`hashCode()`直接定位`value`所在的索引，那么第一个问题来了：hashCode()返回的`int`范围高达±<span class="number">21</span>亿，先不考虑负数，`HashMap`内部使用的数组得有多大？</span><br><span class="line"></span><br><span class="line">实际上`HashMap`初始化时默认的数组大小只有<span class="number">16</span>，任何`key`，无论它的`hashCode()`有多大，都可以简单地通过：</span><br></pre></td></tr></table></figure></code></pre><p>int index = key.hashCode() &amp; 0xf; // 0xf = 15</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">把索引确定在<span class="number">0</span>～<span class="number">15</span>，即永远不会超出数组范围，上述算法只是一种最简单的实现。</span><br><span class="line"></span><br><span class="line">第二个问题：如果添加超过<span class="number">16</span>个`key-value`到`HashMap`，数组不够用了怎么办？</span><br><span class="line"></span><br><span class="line">添加超过一定数量的`key-value`时，`HashMap`会在内部自动扩容，每次扩容一倍，即长度为<span class="number">16</span>的数组扩展为长度<span class="number">32</span>，相应地，需要重新确定`hashCode()`计算的索引位置。例如，对长度为<span class="number">32</span>的数组计算`hashCode()`对应的索引，计算方式要改为：</span><br></pre></td></tr></table></figure>
<p>int index = key.hashCode() &amp; 0x1f; // 0x1f = 31</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">由于扩容会导致重新分布已有的`key-value`，所以，频繁扩容对`HashMap`的性能影响很大。如果我们确定要使用一个容量为`10000`个`key-value`的`HashMap`，更好的方式是创建`HashMap`时就指定容量：</span><br></pre></td></tr></table></figure>
<p>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(10000);</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">虽然指定容量是`10000`，但`HashMap`内部的数组长度总是<span class="number">2</span>n，因此，实际数组长度被初始化为比`10000`大的`16384`（<span class="number">214</span>）。</span><br><span class="line"></span><br><span class="line">最后一个问题：如果不同的两个`key`，例如`"a<span class="string">"`和`"b"</span>`，它们的`hashCode()`恰好是相同的（这种情况是完全可能的，因为不相等的两个实例，只要求`hashCode()`尽量不相等），那么，当我们放入：</span><br></pre></td></tr></table></figure>
<p>map.put(“a”, new Person(“Xiao Ming”));<br>map.put(“b”, new Person(“Xiao Hong”));</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">时，由于计算出的数组索引相同，后面放入的`"Xiao Hong<span class="string">"`会不会把`"Xiao Ming"</span>`覆盖了？</span><br><span class="line"></span><br><span class="line">当然不会！使用`Map`的时候，只要`key`不相同，它们映射的`value`就互不干扰。但是，在`HashMap`内部，确实可能存在不同的`key`，映射到相同的`hashCode()`，即相同的数组索引上，肿么办？</span><br><span class="line"></span><br><span class="line">我们就假设`"a<span class="string">"`和`"b"</span>`这两个`key`最终计算出的索引都是<span class="number">5</span>，那么，在`HashMap`的数组中，实际存储的不是一个`Person`实例，而是一个`List`，它包含两个`Entry`，一个是`"a<span class="string">"`的映射，一个是`"b"</span>`的映射：</span><br><span class="line"></span><br><span class="line">```ascii</span><br><span class="line">  ┌───┐</span><br><span class="line"><span class="number">0</span> │   │</span><br><span class="line">  ├───┤</span><br><span class="line"><span class="number">1</span> │   │</span><br><span class="line">  ├───┤</span><br><span class="line"><span class="number">2</span> │   │</span><br><span class="line">  ├───┤</span><br><span class="line"><span class="number">3</span> │   │</span><br><span class="line">  ├───┤</span><br><span class="line"><span class="number">4</span> │   │</span><br><span class="line">  ├───┤</span><br><span class="line"><span class="number">5</span> │ ●─┼───&gt; List&lt;Entry&lt;String, Person&gt;&gt;</span><br><span class="line">  ├───┤</span><br><span class="line"><span class="number">6</span> │   │</span><br><span class="line">  ├───┤</span><br><span class="line"><span class="number">7</span> │   │</span><br><span class="line">  └───┘</span><br></pre></td></tr></table></figure>

<p>在查找的时候，例如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure>

<p>HashMap内部通过<code>&quot;a&quot;</code>找到的实际上是<code>List&gt;</code>，它还需要遍历这个<code>List</code>，并找到一个<code>Entry</code>，它的<code>key</code>字段是<code>&quot;a&quot;</code>，才能返回对应的<code>Person</code>实例。</p>
<p>我们把不同的<code>key</code>具有相同的<code>hashCode()</code>的情况称之为哈希冲突。在冲突的时候，一种最简单的解决办法是用<code>List</code>存储<code>hashCode()</code>相同的<code>key-value</code>。显然，如果冲突的概率越大，这个<code>List</code>就越长，<code>Map</code>的<code>get()</code>方法效率就越低，这就是为什么要尽量满足条件二：</p>
<p> 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。</p>
<p><code>hashCode()</code>方法编写得越好，<code>HashMap</code>工作的效率就越高。</p>
<ul>
<li><h4 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h4><ul>
<li><p>如果<code>Map</code>的key是<code>enum</code>类型，推荐使用<code>EnumMap</code>，既保证速度，也不浪费空间</p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        Map&lt;DayOfWeek, String&gt; map = <span class="keyword">new</span> EnumMap&lt;&gt;(DayOfWeek<span class="class">.<span class="keyword">class</span>)</span>;
        map.put(DayOfWeek.MONDAY, <span class="string">"星期一"</span>);
        map.put(DayOfWeek.TUESDAY, <span class="string">"星期二"</span>);
        map.put(DayOfWeek.WEDNESDAY, <span class="string">"星期三"</span>);
        map.put(DayOfWeek.THURSDAY, <span class="string">"星期四"</span>);
        map.put(DayOfWeek.FRIDAY, <span class="string">"星期五"</span>);
        map.put(DayOfWeek.SATURDAY, <span class="string">"星期六"</span>);
        map.put(DayOfWeek.SUNDAY, <span class="string">"星期日"</span>);
        System.out.println(map);
        System.out.println(map.get(DayOfWeek.MONDAY));
    }
}
&lt;!--￼<span class="number">28</span>--&gt;</code></pre>
</li>
<li><p>Key必须实现<code>Comparable</code>接口,TreeMap<code>不使用</code>equals()<code>和</code>hashCode()</p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        Map&lt;Student, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() {
            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student p1, Student p2)</span> </span>{
                <span class="keyword">if</span> (p1.score == p2.score) {
                    <span class="keyword">return</span> <span class="number">0</span>;
                }
                <span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;
            }
        });
        map.put(<span class="keyword">new</span> Student(<span class="string">"Tom"</span>, <span class="number">77</span>), <span class="number">1</span>);
        map.put(<span class="keyword">new</span> Student(<span class="string">"Bob"</span>, <span class="number">66</span>), <span class="number">2</span>);
        map.put(<span class="keyword">new</span> Student(<span class="string">"Lily"</span>, <span class="number">99</span>), <span class="number">3</span>);
        <span class="keyword">for</span> (Student key : map.keySet()) {
            System.out.println(key);
        }
        System.out.println(map.get(<span class="keyword">new</span> Student(<span class="string">"Bob"</span>, <span class="number">66</span>))); <span class="comment">// 重写方法，相等为0</span>
    }
}
&lt;!--￼<span class="number">29</span>--&gt;</code></pre>
</li>
<li><pre><code class="ascii">       ┌───┐
       │Set│
       └───┘
         ▲
    ┌────┴─────┐
    │          │
┌───────┐ ┌─────────┐
│HashSet│ │SortedSet│
└───────┘ └─────────┘
               ▲
               │
          ┌─────────┐
          │ TreeSet │
          └─────────┘
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - `HashSet`是无序的，因为它实现了`Set`接口，并没有实现`SortedSet`接口；</span><br><span class="line"></span><br><span class="line">  - `TreeSet`是有序的，因为它实现了`SortedSet`接口。</span><br><span class="line"></span><br><span class="line">    - 添加的元素必须正确实现`Comparable`接口，如果没有实现`Comparable`接口，那么创建`TreeSet`时必须传入一个`Comparator`对象。</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">#### IO流</span><br><span class="line"></span><br><span class="line">IO流是一种流式的数据输入/输出模型：</span><br><span class="line"></span><br><span class="line">- 二进制数据以`byte`为最小单位在`InputStream`/`OutputStream`中单向流动；</span><br><span class="line">- 字符数据以`char`为最小单位在`Reader`/`Writer`中单向流动。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**File**：Java标准库的`java.io.File`对象表示一个文件或者目录：</span><br><span class="line"></span><br><span class="line">- 创建`File`对象本身不涉及IO操作；</span><br><span class="line"></span><br><span class="line">- 可以获取路径／绝对路径／规范路径：`getPath()`/`getAbsolutePath()`/`getCanonicalPath()`；</span><br><span class="line"></span><br><span class="line">- 可以获取目录的文件和子目录：`list()`/`listFiles()`；</span><br><span class="line"></span><br><span class="line">- 可以创建或删除文件和目录。</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public class Main &#123;</span><br><span class="line">      public static void main(String[] args) throws IOException &#123;</span><br><span class="line">          File f = <span class="keyword">new</span> File(<span class="string">".."</span>)<span class="comment">;</span></span><br><span class="line">          System.out.println(f.getPath())<span class="comment">;</span></span><br><span class="line">          System.out.println(f.getAbsolutePath())<span class="comment">;</span></span><br><span class="line">          System.out.println(f.getCanonicalPath())<span class="comment">;</span></span><br><span class="line">          File file = <span class="keyword">new</span> File(<span class="string">"/path/to/file"</span>)<span class="comment">;</span></span><br><span class="line">          #-----------------------------------------</span><br><span class="line">          if (file.createNewFile()) &#123;</span><br><span class="line"><span class="title">              // 文件创建成功:</span></span><br><span class="line"><span class="title">              // TODO:</span></span><br><span class="line">              if (file.delete()) &#123;</span><br><span class="line"><span class="title">                  // 删除文件成功:</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>inputsteam</strong>: 是一个抽象类，而不是接口，是所有输入流的超类（以字节为单位）</p>
<ul>
<li><p>面向抽象编程原则的应用：接受<code>InputStream</code>抽象类型，而不是具体的<code>FileInputStream</code>类型，从而使得代码可以处理<code>InputStream</code>的任意实现类</p>
</li>
<li><p>fileinputstream</p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{
    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>)) {
        <span class="comment">// 定义1000个字节大小的缓冲区:</span>
        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];
        <span class="keyword">int</span> n;
        <span class="keyword">while</span> ((n = input.read(buffer)) != -<span class="number">1</span>) { <span class="comment">// 读取到缓冲区</span>
            System.out.println(<span class="string">"read "</span> + n + <span class="string">" bytes."</span>);
        }
    }
}
&lt;!--￼<span class="number">31</span>--&gt;
<span class="number">1</span>.利用Java <span class="number">7</span>引入的新的<span class="keyword">try</span>(resource)的语法，只需要编写<span class="keyword">try</span>语句，让编译器自动为我们关闭资源
<span class="number">2</span>.编译器只看<span class="keyword">try</span>(resource = ...)中的对象是否实现了java.lang.AutoCloseable接口，如果实现了，就自动加上<span class="keyword">finally</span>语句并调用close()方法。
<span class="number">3</span>.read方法是阻塞的（返回后才能继续）
&lt;!--￼<span class="number">32</span>--&gt;


</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>装饰模式</strong>：运行时动态的增加功能</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">                 ┌─────────────┐</span><br><span class="line">                 │ InputStream │</span><br><span class="line">                 └─────────────┘</span><br><span class="line">                       ▲ ▲</span><br><span class="line">┌────────────────────┐ │ │ ┌─────────────────┐</span><br><span class="line">│  FileInputStream   │─┤ └─│FilterInputStream│</span><br><span class="line">└────────────────────┘ │   └─────────────────┘</span><br><span class="line">┌────────────────────┐ │     ▲ ┌───────────────────┐</span><br><span class="line">│<span class="keyword">ByteArrayInputStream│─┤ </span>    ├─│<span class="keyword">BufferedInputStream│</span></span><br><span class="line"><span class="keyword">└────────────────────┘ </span>│     │ └───────────────────┘</span><br><span class="line">┌────────────────────┐ │     │ ┌───────────────────┐</span><br><span class="line">│ ServletInputStream │─┘     ├─│  DataInputStream  │</span><br><span class="line">└────────────────────┘       │ └───────────────────┘</span><br><span class="line">                             │ ┌───────────────────┐</span><br><span class="line">                             └─│CheckedInputStream │</span><br><span class="line">                               └───────────────────┘</span><br></pre></td></tr></table></figure>

<p>编写一个<code>CountInputStream</code>，它的作用是对输入的字节进行计数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="string">"hello, world!"</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">try</span> (CountInputStream input = <span class="keyword">new</span> CountInputStream(<span class="keyword">new</span> ByteArrayInputStream(data))) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Total read "</span> + input.getBytesRead() + <span class="string">" bytes"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CountInputStream(InputStream in) &#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBytesRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = in.read();</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = in.read(b, off, len);</span><br><span class="line">        <span class="keyword">this</span>.count += n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>classpath路径：</strong>避免不同环境下文件路径不一致的问题</p>
<p>调用<code>getResourceAsStream()</code>需要特别注意的一点是，如果资源文件不存在，它将返回<code>null</code>。因此，我们需要检查返回的<code>InputStream</code>是否为<code>null</code>，如果为<code>null</code>，表示资源文件在classpath中没有找到：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (InputStream input = get<span class="constructor">Class()</span>.get<span class="constructor">ResourceAsStream(<span class="string">"/default.properties"</span>)</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input != null) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Properties <span class="built_in">props</span> = <span class="built_in">new</span> Properties();</span><br><span class="line"><span class="built_in">props</span>.<span class="built_in">load</span>(inputStreamFromClassPath(<span class="string">"/default.properties"</span>));</span><br><span class="line"><span class="built_in">props</span>.<span class="built_in">load</span>(inputStreamFromFile(<span class="string">"./conf.properties"</span>));</span><br></pre></td></tr></table></figure>

<p>这样读取配置文件，应用程序启动就更加灵活</p>
<p><strong>序列化</strong></p>
<p><strong>Reader</strong></p>
<table>
<thead>
<tr>
<th align="left">InputStream</th>
<th align="left">Reader</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字节流，以<code>byte</code>为单位</td>
<td align="left">字符流，以<code>char</code>为单位</td>
</tr>
<tr>
<td align="left">读取字节（-1，0~255）：<code>int read()</code></td>
<td align="left">读取字符（-1，0~65535）：<code>int read()</code></td>
</tr>
<tr>
<td align="left">读到字节数组：<code>int read(byte[] b)</code></td>
<td align="left">读到字符数组：<code>int read(char[] c)</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"src/readme.txt"</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"read "</span> + n + <span class="string">" chars."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Reader</code>是基于<code>InputStream</code>构造的：可以通过<code>InputStreamReader</code>在指定编码的同时将任何<code>InputStream</code>转换为<code>Reader</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 持有InputStream:</span></span><br><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>);</span><br><span class="line"><span class="comment">// 变换为Reader:</span></span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(input, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>



<p><strong>write</strong></p>
<table>
<thead>
<tr>
<th align="left">OutputStream</th>
<th align="left">Writer</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字节流，以<code>byte</code>为单位</td>
<td align="left">字符流，以<code>char</code>为单位</td>
</tr>
<tr>
<td align="left">写入字节（0~255）：<code>void write(int b)</code></td>
<td align="left">写入字符（0~65535）：<code>void write(int c)</code></td>
</tr>
<tr>
<td align="left">写入字节数组：<code>void write(byte[] b)</code></td>
<td align="left">写入字符数组：<code>void write(char[] c)</code></td>
</tr>
<tr>
<td align="left">无对应方法</td>
<td align="left">写入String：<code>void write(String s)</code></td>
</tr>
</tbody></table>
<h3 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h3><p><code>FileWriter</code>就是向文件中写入字符流的<code>Writer</code>。它的使用方法和<code>FileReader</code>类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"readme.txt"</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(<span class="string">'H'</span>); <span class="comment">// 写入单个字符</span></span><br><span class="line">    writer.write(<span class="string">"Hello"</span>.toCharArray()); <span class="comment">// 写入char[]</span></span><br><span class="line">    writer.write(<span class="string">"Hello"</span>); <span class="comment">// 写入String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Writer</code>是基于<code>OutputStream</code>构造的，可以通过<code>OutputStreamWriter</code>将<code>OutputStream</code>转换为<code>Writer</code>，转换时需要指定编码</p>
<p><code>PrintStream</code>是一种能接收各种数据类型的输出，打印数据时比较方便：</p>
<ul>
<li><code>System.out</code>是标准输出；</li>
<li><code>System.err</code>是标准错误输出。</li>
</ul>
<p><code>PrintWriter</code>是基于<code>Writer</code>的输出</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="ck9lj0kal00029svagb9s5f8v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-剑指offer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/%E5%89%91%E6%8C%87offer/" class="article-date">
  <time datetime="2020-03-26T05:28:02.065Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/%E5%89%91%E6%8C%87offer/">剑指offer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>-回溯法<br>                 if(judge(matrix,i,j,rows,cols,flag,str,0)){<br>                     return true;<br>                 }<br>            }<br>        }<br>        return false;<br>    }</p>
<pre><code>//judge(初始矩阵，索引行坐标i，索引纵坐标j，矩阵行数，矩阵列数，待判断的字符串，字符串索引初始为0即先判断字符串的第一位)
private boolean judge(char[] matrix,int i,int j,int rows,int cols,boolean[] flag,char[] str,int k){
    //先根据i和j计算匹配的第一个元素转为一维数组的位置
    int index = i*cols+j;
    //递归终止条件
    if(i&lt;0 || j&lt;0 || i&gt;=rows || j&gt;=cols || matrix[index] != str[k] || flag[index] == true)
        return false;
    //若k已经到达str末尾了，说明之前的都已经匹配成功了，直接返回true即可
    if(k == str.length-1)
        return true;
    //要走的第一个位置置为true，表示已经走过了
    flag[index] = true;

    //回溯，递归寻找，每次找到了就给k加一，找不到，还原
    if(judge(matrix,i-1,j,rows,cols,flag,str,k+1) ||
       judge(matrix,i+1,j,rows,cols,flag,str,k+1) ||
       judge(matrix,i,j-1,rows,cols,flag,str,k+1) ||
       judge(matrix,i,j+1,rows,cols,flag,str,k+1)  )
    {
        return true;
    }
    //走到这，说明这一条路不通，还原，再试其他的路径
    flag[index] = false;
    return false;
}</code></pre><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 机器人的运动范围</span><br></pre></td></tr></table></figure>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 同样是回溯法</span><br><span class="line"></span><br><span class="line">  - 访问位</span><br><span class="line">  - 边界条件：越界  ， 不满足题意  ， 访问过</span><br><span class="line">  - 回溯前后左右格子数目</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">   public <span class="keyword">int</span> movingCount(<span class="keyword">int</span> threshold, <span class="keyword">int</span> <span class="built_in">rows</span>, <span class="keyword">int</span> <span class="built_in">cols</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> flag[][] = new <span class="keyword">int</span>[<span class="built_in">rows</span>][<span class="built_in">cols</span>]; <span class="comment">//记录是否已经走过</span></span><br><span class="line">          <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">rows</span>, <span class="built_in">cols</span>, flag, threshold);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      private <span class="keyword">int</span> helper(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> <span class="built_in">rows</span>, <span class="keyword">int</span> <span class="built_in">cols</span>, <span class="keyword">int</span>[][] flag, <span class="keyword">int</span> threshold) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= <span class="built_in">rows</span> || j &lt; <span class="number">0</span> || j &gt;= <span class="built_in">cols</span> || numSum(i) + numSum(j)  &gt; threshold || flag[i][j] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          flag[i][j] = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">return</span> helper(i - <span class="number">1</span>, j, <span class="built_in">rows</span>, <span class="built_in">cols</span>, flag, threshold)</span><br><span class="line">                  + helper(i + <span class="number">1</span>, j, <span class="built_in">rows</span>, <span class="built_in">cols</span>, flag, threshold)</span><br><span class="line">                  + helper(i, j - <span class="number">1</span>, <span class="built_in">rows</span>, <span class="built_in">cols</span>, flag, threshold)</span><br><span class="line">                  + helper(i, j + <span class="number">1</span>, <span class="built_in">rows</span>, <span class="built_in">cols</span>, flag, threshold)</span><br><span class="line">                  + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  	<span class="comment">// 数字位数相加</span></span><br><span class="line">      private <span class="keyword">int</span> numSum(<span class="keyword">int</span> i) &#123;</span><br><span class="line">          <span class="keyword">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="built_in">sum</span> += i%<span class="number">10</span>;</span><br><span class="line">              i = i/<span class="number">10</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;<span class="number">1</span>并且m&gt;<span class="number">1</span>），每段绳子的长度记为k[<span class="number">0</span>],k[<span class="number">1</span>],...,k[m]。请问k[<span class="number">0</span>]xk[<span class="number">1</span>]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是<span class="number">8</span>时，我们把它剪成长度分别为<span class="number">2</span>、<span class="number">3</span>、<span class="number">3</span>的三段，此时得到的最大乘积是<span class="number">18</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">动态规划求解问题的四个特征： </span><br><span class="line">①求一个问题的最优解； </span><br><span class="line">②整体的问题的最优解是依赖于各个子问题的最优解； </span><br><span class="line">③小问题之间还有相互重叠的更小的子问题； </span><br><span class="line">④从上往下分析问题，从下往上求解问题；</span><br></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// n&lt;=3的情况，m&gt;1必须要分段，例如：3必须分成1、2；1、1、1 ，n=3最大分段乘积是2,</span></span><br><span class="line">    	<span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        下面3行是n&gt;=4的情况，跟n&lt;=3不同，4可以分很多段，比如分成1、3，</span></span><br><span class="line"><span class="comment">        这里的3可以不需要再分了，因为3分段最大才2，不分就是3。记录最大的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;<span class="comment">//记录最大的</span></span><br><span class="line">    	<span class="comment">//j&lt;=i/2是因为1*3和3*1是一样的，没必要计算在内，只要计算到1*3和2*2就好了。然后就是取最大，1*3最大是3,2*2最大是4，那么dp[4]=res就是4。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=i/<span class="number">2</span> ; j++) &#123; <span class="comment">//  i/2 只需算一半</span></span><br><span class="line">                res=Math.max(res,dp[j]*dp[i-j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]=res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>贪婪法</p>
<ul>
<li>每次争取剪长度为三  </li>
<li>2 * 2&gt;3 * 1</li>
</ul>
</li>
<li><pre><code class="java">
<span class="comment">// 不断的切分3</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{
        <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>){
            <span class="keyword">return</span> <span class="number">1</span>;
        }
        <span class="keyword">if</span>(n==<span class="number">3</span>){
            <span class="keyword">return</span> <span class="number">2</span>;
        }
        <span class="keyword">int</span> sum = <span class="number">1</span>;
        <span class="keyword">while</span>(n&gt;<span class="number">4</span>){
            sum*=<span class="number">3</span>;
            n-=<span class="number">3</span>;
        }
        <span class="keyword">return</span> sum*n;

    }
&lt;!--￼<span class="number">5</span>--&gt;


</code></pre>
</li>
</ul>
<hr>
<h4 id="二进制中1的位数"><a href="#二进制中1的位数" class="headerlink" title="二进制中1的位数"></a>二进制中1的位数</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个整数，输出该数二进制表示中<span class="number">1</span>的个数。其中负数用补码表示。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>普通做法:按位依次与1，循环左移1，比较次数为32（int）</p>
</li>
<li><p>根据 与运算 定义，设二进制数字 nn ，则有：<br>若 n &amp; 1 = 0n&amp;1=0 ，则 nn 二进制 最右一位 为 00 ；<br>若 n &amp; 1 = 1n&amp;1=1 ，则 nn 二进制 最右一位 为 11 。</p>
</li>
</ul>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{
        <span class="keyword">int</span> count = <span class="number">0</span>;
        <span class="keyword">int</span> flag = <span class="number">1</span>;
        <span class="keyword">while</span>(flag!=<span class="number">0</span>){
            <span class="keyword">if</span>((n&amp;flag)!=<span class="number">0</span>){
                count++;
            }
            flag = flag&lt;&lt;<span class="number">1</span>;
        }
        <span class="keyword">return</span> count;
    }
&lt;!--￼<span class="number">7</span>--&gt;


</code></pre>
</li>
</ul>
<hr>
<h4 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个<span class="keyword">double</span>类型的浮点数<span class="keyword">base</span>和<span class="keyword">int</span>类型的整数exponent。求<span class="keyword">base</span>的exponent次方。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该题看起来比较简单，但是需要考虑多种情况</p>
<ul>
<li>指数是不是为0 或者 负数</li>
<li>基数为0</li>
<li>快速幂的方法</li>
</ul>
<p>普通方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> base == <span class="number">0</span>: <span class="comment">#base为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> exponent == <span class="number">0</span>: <span class="comment">#指数为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> exponent &lt; <span class="number">0</span>: <span class="comment">#指数为负数</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(-exponent):</span><br><span class="line">                result = result * base</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/result</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(exponent):</span><br><span class="line">            result = result * base</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>快速幂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">       <span class="keyword">int</span> exp = Math.abs(n);</span><br><span class="line">       <span class="keyword">while</span>(exp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>((exp&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">               res*=x;</span><br><span class="line">           &#125;</span><br><span class="line">           x*=x;</span><br><span class="line">           exp = exp&gt;&gt;<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> n&gt;<span class="number">0</span>?res:<span class="number">1.0</span>/res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 递归法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> n=Math.abs(exponent);</span><br><span class="line">          <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">              <span class="keyword">return</span> base;</span><br><span class="line">          <span class="keyword">double</span>  result=Power(base,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">          result*=result;</span><br><span class="line">          <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">              result*=base;</span><br><span class="line">          <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">              result=<span class="number">1</span>/result;</span><br><span class="line">          <span class="keyword">return</span> result;            </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<hr>
<h4 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h4><hr>
<h4 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目一：在O（<span class="number">1</span>）时间内删除链表节点</span><br></pre></td></tr></table></figure>

<ul>
<li>平常的删除节点是需要找到要删除的上一个节点，更改指针，删除需要删除的节点，O(N)</li>
<li>该题时间为O（1）<ul>
<li>我们考虑，该节点的下一个节点容易找到，将next节点的值赋值给该节点，删除next节点，更改指针</li>
</ul>
</li>
<li>边界问题<ul>
<li>delete节点位于中间</li>
<li>delete节点位于头尾节点:普通方法</li>
<li>链表只有一个节点</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">       ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       dummy.next = head;</span><br><span class="line">       ListNode cur = dummy;</span><br><span class="line">       <span class="keyword">while</span> (cur.next!=<span class="keyword">null</span>)&#123;  <span class="comment">// 取下一个值，判断next是否为空</span></span><br><span class="line">           <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">               ListNode del = cur.next;</span><br><span class="line">               cur.next = del.next;</span><br><span class="line">               del.next = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目二：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span> 处理后为 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>由于是排序链表，重复节点必相邻</li>
<li>pre，next指针 pre指针指向确定的节点，next指针相当于工作节点，一直指向不为重复的值</li>
<li>增加头节点，为了防止头节点就是重复节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pHead==<span class="keyword">null</span> || pHead.next==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> pHead;&#125;</span><br><span class="line">ListNode Head = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//创建新的头节点</span></span><br><span class="line">Head.next = pHead;</span><br><span class="line">ListNode pre  = Head;</span><br><span class="line">ListNode last = Head.next;</span><br><span class="line"><span class="keyword">while</span> (last!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(last.next!=<span class="keyword">null</span> &amp;&amp; last.val == last.next.val)&#123;</span><br><span class="line">        <span class="comment">// 找到最后的一个相同节点</span></span><br><span class="line">        <span class="keyword">while</span> (last.next!=<span class="keyword">null</span> &amp;&amp; last.val == last.next.val)&#123;</span><br><span class="line">            last = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = last.next;</span><br><span class="line">        last = last.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        last = last.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Head.next;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="调整数组的顺序使奇数位于偶数的前面"><a href="#调整数组的顺序使奇数位于偶数的前面" class="headerlink" title="调整数组的顺序使奇数位于偶数的前面"></a>调整数组的顺序使奇数位于偶数的前面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变</span><br></pre></td></tr></table></figure>

<ul>
<li>比较简单，类似快排中的partition</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j&amp;&amp;(nums[i]%<span class="number">2</span>)!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j&amp;&amp;(nums[j]%<span class="number">2</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="链表环的入口"><a href="#链表环的入口" class="headerlink" title="链表环的入口"></a>链表环的入口</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出<span class="literal">null</span>。</span><br></pre></td></tr></table></figure>

<ul>
<li>判断是否有环：快慢指针，一个跑两格，一个跑一格，相遇则为有环</li>
<li>找出入口节点：快指针回到头节点，两个一起跑相遇为入口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="comment">// 单节点或者无节点返回错误</span></span><br><span class="line">        <span class="keyword">if</span>(pHead ==<span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义快慢指针</span></span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; slow !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;  <span class="comment">//相遇，链表有环</span></span><br><span class="line">                fast = pHead;  <span class="comment">//快指针回头节点</span></span><br><span class="line">                <span class="keyword">while</span>(fast != slow)&#123;  <span class="comment">//两个一起走</span></span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span>(fast == slow)&#123;  <span class="comment">//再次相遇为环的入口节点</span></span><br><span class="line">                    <span class="keyword">return</span> slow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个链表，反转链表后，输出新链表的表头</span><br></pre></td></tr></table></figure>

<ul>
<li>传统的递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode node = ReverseList(head.next);</span><br><span class="line">                head.next.next = head;</span><br><span class="line">                head.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>三指针 ，断链的话需要保存后一个节点，当前节点指向前一个节点</li>
<li><img src="C:%5CUsers%5C%E5%8D%97%E5%A4%A7%E5%AE%8B%E4%BB%B2%E5%9F%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200227175142167.png" alt="image-20200227175142167"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则</span><br></pre></td></tr></table></figure>

<ul>
<li><p>增加头节点</p>
</li>
<li><pre><code class="java"> <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{
        ListNode head0 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);
        ListNode cur = head0;
        ListNode a = l1;
        ListNode b = l2;
        <span class="keyword">while</span> (a!=<span class="keyword">null</span>&amp;&amp;b!=<span class="keyword">null</span>){
            <span class="keyword">if</span> (a.val&lt;=b.val){
                cur.next = a;
                cur = a;
                a = a.next;
            }<span class="keyword">else</span> {
                cur.next = b;
                cur = b;
                b = b.next;
            }
        }
        <span class="keyword">if</span>(a==<span class="keyword">null</span>){
            cur.next = b;
        }
        <span class="keyword">if</span>(b==<span class="keyword">null</span>){
            cur.next = a;
        }
        <span class="keyword">return</span> head0.next;
    }
&lt;!--￼<span class="number">24</span>--&gt;</code></pre>
</li>
<li><p>非递归实现：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        head = ListNode(<span class="number">0</span>)  //额外头节点</span><br><span class="line">        tmp = head</span><br><span class="line">        <span class="keyword">while</span> pHead1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> pHead2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> pHead1.val &lt;= pHead2.val:</span><br><span class="line">                tmp.next = pHead1</span><br><span class="line">                pHead1 = pHead1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp.next = pHead2</span><br><span class="line">                pHead2 = pHead2.next</span><br><span class="line">            tmp = tmp.next  //这里需要注意</span><br><span class="line">        <span class="keyword">if</span> pHead1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            tmp.next = pHead2</span><br><span class="line">        <span class="keyword">elif</span> pHead2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            tmp.next = pHead1</span><br><span class="line">        <span class="keyword">return</span> head.next   //返回为额外头节点的下一个</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入两棵二叉树<span class="keyword">A</span>，B，判断B是不是<span class="keyword">A</span>的子结构。（ps：我们约定空树不是任意一个树的子结构）</span><br></pre></td></tr></table></figure>

<ul>
<li>首先在A中找B的根节点</li>
<li>找到后判断其子树</li>
<li>注意的是：与二叉树相关有大量的指针操作，判断是否为空</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span>||B ==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(A.val == B.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> isSub(A,B);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSubStructure(A.left, B)||isSubStructure(A.right, B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSub</span><span class="params">(TreeNode x,TreeNode y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="keyword">null</span>)&#123; <span class="comment">//  y搜索完了 未找到匹配项</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123; <span class="comment">// x 搜索完了 出错</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x.val!=y.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSub(x.left,y.left)&amp;&amp;isSub(x.right,y.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="树的镜像"><a href="#树的镜像" class="headerlink" title="树的镜像"></a>树的镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作给定的二叉树，将其变换为源二叉树的镜像。</span><br></pre></td></tr></table></figure>

<ul>
<li>交换根节点的左右子节点</li>
<li>递归子树</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>||(root.left == <span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        mirrorTree(root.left);</span><br><span class="line">        mirrorTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非递归，自定义栈实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 空树</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右均为空</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用来遍历的栈</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line"> </span><br><span class="line">    stack.push(root);</span><br><span class="line"> </span><br><span class="line">    TreeNode curNode;</span><br><span class="line">    TreeNode tempNode;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 深度优先</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      curNode = stack.pop();</span><br><span class="line">      <span class="keyword">if</span>(curNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(curNode.left == <span class="keyword">null</span> &amp;&amp; curNode.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 交换</span></span><br><span class="line">      tempNode = curNode.left;</span><br><span class="line">      curNode.left = curNode.right;</span><br><span class="line">      curNode.right = tempNode;</span><br><span class="line">      stack.push(curNode.left);</span><br><span class="line">      stack.push(curNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</span><br></pre></td></tr></table></figure>

<ul>
<li>比较左右子树的值，递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSym(pRoot.left,pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSym</span><span class="params">(TreeNode left,TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSym(left.left,right.right)&amp;&amp; isSym(left.right,right.left);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下<span class="number">4</span> X <span class="number">4</span>矩阵： <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> 则依次打印出数字<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">10.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> down = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 最上面一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=left;col&lt;=right;col++)&#123;</span><br><span class="line">                list.add(matrix[up][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向下逼近</span></span><br><span class="line">            up++;</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(up &gt; down)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最右边一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=up;row&lt;=down;row++)&#123;</span><br><span class="line">                list.add(matrix[row][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向左逼近</span></span><br><span class="line">            right--;</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最下面一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=right;col&gt;=left;col--)&#123;</span><br><span class="line">                list.add(matrix[down][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向上逼近</span></span><br><span class="line">            down--;</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(up &gt; down)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最左边一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=down;row&gt;=up;row--)&#123;</span><br><span class="line">                list.add(matrix[row][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向右逼近</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="包含min函数的最小栈"><a href="#包含min函数的最小栈" class="headerlink" title="包含min函数的最小栈"></a>包含min函数的最小栈</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的<span class="variable">min</span>函数（时间复杂度应为<span class="variable">O</span>（<span class="number">1</span>））。</span><br><span class="line">注意：保证测试中不会当栈为空的时候，对栈调用<span class="function"><span class="title">pop</span>()或者<span class="title"><span class="built_in">min</span></span>()或者<span class="title">top</span>()方法。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>维护一个辅助栈，栈容量与原始栈相同：每次加元素，辅助栈始终添加最小值到栈顶，出栈一起出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty() || node &lt; stack2.peek())&#123;</span><br><span class="line">            stack2.push(node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack2.push(stack2.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1.pop();</span><br><span class="line">        stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>每次遇到最小的元素在压辅助栈</p>
</li>
<li><pre><code class="java">Stack&lt;Integer&gt; A, B;
    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>{
        A = <span class="keyword">new</span> Stack&lt;&gt;();
        B = <span class="keyword">new</span> Stack&lt;&gt;();
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
        A.add(x);
        <span class="keyword">if</span>(B.empty() || B.peek() &gt;= x)
            B.add(x);
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{
        <span class="keyword">if</span>(A.pop().equals(B.peek()))
            B.pop();
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> A.peek();
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> B.peek();
    }

&lt;!--￼<span class="number">37</span>--&gt;
输入两组整数序列，判断是否为压栈和弹出序列
&lt;!--￼<span class="number">38</span>--&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a>从上到下打印二叉树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从上往下打印出二叉树的每个节点，同层节点从左至右打印  （层次遍历）</span><br></pre></td></tr></table></figure>

<ul>
<li>利用队列，每次取出顶端元素打印</li>
<li>每次打印一个节点得时候，如果有子节点，则把子节点放入队列末尾，头部取出打印</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.add(root);</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">           TreeNode node = queue.poll();</span><br><span class="line">           res.add(node.val);</span><br><span class="line">           <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.add(node.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.add(node.right);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (Integer n :</span><br><span class="line">               res) &#123;</span><br><span class="line">           r[index++] = n;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        treeNodeTmp = [root]</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">while</span> treeNodeTmp:</span><br><span class="line">            tmpNode = treeNodeTmp[<span class="number">0</span>]</span><br><span class="line">            ret.append(tmpNode.val)</span><br><span class="line">            <span class="keyword">if</span> tmpNode.left:</span><br><span class="line">                treeNodeTmp.append(tmpNode.left)</span><br><span class="line">            <span class="keyword">if</span> tmpNode.right:</span><br><span class="line">                treeNodeTmp.append(tmpNode.right)</span><br><span class="line">            <span class="keyword">del</span> treeNodeTmp[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="多行打印二叉树"><a href="#多行打印二叉树" class="headerlink" title="多行打印二叉树"></a>多行打印二叉树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行</span><br></pre></td></tr></table></figure>

<ul>
<li>因为每层都是独立的，所以建立两个栈，一层节点的子节点全部放入一个栈交替进行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 注意这里每次循环size()，发生变化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self,pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nodeStack = [pRoot]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> nodeStack:</span><br><span class="line">            res = []</span><br><span class="line">            nextStack = [] <span class="comment"># 辅助栈存放下一层结点</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nodeStack:</span><br><span class="line">                res.append(i.val)</span><br><span class="line">                <span class="keyword">if</span> i.left:</span><br><span class="line">                    nextStack.append(i.left)</span><br><span class="line">                <span class="keyword">if</span> i.right:</span><br><span class="line">                    nextStack.append(i.right)</span><br><span class="line">            nodeStack = nextStack <span class="comment">#辅助栈存为主栈</span></span><br><span class="line">            result.append(res) <span class="comment">#添加该层结点</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="按之字形打印二叉树"><a href="#按之字形打印二叉树" class="headerlink" title="按之字形打印二叉树"></a>按之字形打印二叉树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</span><br></pre></td></tr></table></figure>

<ul>
<li>奇数反转</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">           List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">               TreeNode node = queue.poll();</span><br><span class="line">               tmp.add(node.val);</span><br><span class="line">               <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">               <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">1</span>) Collections.reverse(tmp);</span><br><span class="line">           res.add(tmp);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两个栈：一个奇数栈 一个偶数栈</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        <span class="keyword">int</span> layer = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//s1存奇数层节点</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s1 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        s1.push(pRoot);</span><br><span class="line">        <span class="comment">//s2存偶数层节点</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s2 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">         </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> (!s1.empty() || !s2.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layer%<span class="number">2</span> != <span class="number">0</span>) &#123;   <span class="comment">//  n &amp; 1 == 0，则n为偶数</span></span><br><span class="line">                ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">while</span> (!s1.empty()) &#123;</span><br><span class="line">                    TreeNode node = s1.pop();</span><br><span class="line">                    <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        temp.add(node.val);</span><br><span class="line">                        System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">                        s2.push(node.left);</span><br><span class="line">                        s2.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!temp.isEmpty()) &#123;</span><br><span class="line">                    list.add(temp);</span><br><span class="line">                    layer++;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">while</span> (!s2.empty()) &#123;</span><br><span class="line">                    TreeNode node = s2.pop();</span><br><span class="line">                    <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        temp.add(node.val);</span><br><span class="line">                        System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">                        s1.push(node.right);</span><br><span class="line">                        s1.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!temp.isEmpty()) &#123;</span><br><span class="line">                    list.add(temp);</span><br><span class="line">                    layer++;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出<span class="keyword">Yes</span>,否则输出<span class="keyword">No</span>。假设输入的数组的任意两个数字都互不相同。</span><br></pre></td></tr></table></figure>

<ul>
<li>首先找到右子树开始的节点</li>
<li>然后对右子树节点依次进行判断</li>
<li>依次遍历左右子树</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = sequence.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> root = sequence[len-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i]&gt;root) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;len-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[j]&lt;root) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> left=<span class="keyword">true</span>,right=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>) left=VerifySquenceOfBST(Arrays.copyOfRange(sequence,<span class="number">0</span>,i));<span class="comment">//左闭右开</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len-<span class="number">1</span>)  right=VerifySquenceOfBST(Arrays.copyOfRange(sequence,i,len-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的<span class="built_in">list</span>中，数组长度大的数组靠前)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>DFS</p>
</li>
<li><pre><code class="java">LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();
    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;(); 
    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) {
        recur(root, sum);
        <span class="keyword">return</span> res;
    }
    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root, <span class="keyword">int</span> tar)</span> </span>{
        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;
        path.add(root.val);
        tar -= root.val;
        <span class="keyword">if</span>(tar == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)
            res.add(<span class="keyword">new</span> LinkedList(path));
        recur(root.left, tar);
        recur(root.right, tar);
        path.removeLast();
    }

&lt;!--￼<span class="number">51</span>--&gt;
</code></pre>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        self.sums = expectNumber</span><br><span class="line">        self.DFS(root, result, [root.val])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self, root, result, path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span> <span class="keyword">and</span> sum(path) == self.sums:</span><br><span class="line">            result.append(path)</span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">            self.DFS(root.left, result, path+[root.left.val])</span><br><span class="line">        <span class="keyword">if</span> root.right !=<span class="literal">None</span>:</span><br><span class="line">            self.DFS(root.right,result,path+[root.right.val])</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="将二叉树转化为双向循环链表"><a href="#将二叉树转化为双向循环链表" class="headerlink" title="将二叉树转化为双向循环链表"></a>将二叉树转化为双向循环链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Node pre,head,tail;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       inOrder(root.left);</span><br><span class="line">       root.left = pre;</span><br><span class="line">       <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">           head = root;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           pre.right = root;</span><br><span class="line">       &#125;</span><br><span class="line">       pre = root;</span><br><span class="line">       tail = root;</span><br><span class="line">       inOrder(root.right);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       inOrder(root);</span><br><span class="line">       tail.right = head;</span><br><span class="line">       head.left = tail;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h4><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的<span class="built_in">head</span>。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</span><br></pre></td></tr></table></figure>

<ul>
<li><p>投机取巧</p>
</li>
<li><pre><code class="java">mport java.util.HashMap;
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span>
<span class="function">    </span>{
        HashMap&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;RandomListNode, RandomListNode&gt;();
        RandomListNode cur = pHead;
        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {
            map.put(cur, <span class="keyword">new</span> RandomListNode(cur.label));
            cur = cur.next;
        }
        cur = pHead;
        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        <span class="keyword">return</span> map.get(pHead);
    }
}
&lt;!--￼<span class="number">55</span>--&gt;
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
&lt;!--￼<span class="number">56</span>--&gt;




</code></pre>
</li>
</ul>
<h4 id="数组中超过一半的数字"><a href="#数组中超过一半的数字" class="headerlink" title="数组中超过一半的数字"></a>数组中超过一半的数字</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为<span class="number">9</span>的数组&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>&#125;。由于数字<span class="number">2</span>在数组中出现了<span class="number">5</span>次，超过数组长度的一半，因此输出<span class="number">2</span>。如果不存在则输出<span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>排序取中间</p>
</li>
<li><p>hash表</p>
</li>
<li><p>patition（改变数组）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">if</span>(array.length&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">int</span> end  = length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = length&gt;&gt;<span class="number">1</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> index = Partition(array,start,end);</span><br><span class="line">        <span class="keyword">while</span>(index!=middle)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index&gt;middle)&#123;</span><br><span class="line">                index = Partition(array,start,index-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                index = Partition(array,index+<span class="number">1</span>,end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = array[middle];</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == result)</span><br><span class="line">                times++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(times*<span class="number">2</span>&lt;length)&#123;</span><br><span class="line">            System.out.println(times);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = (array[start]+array[end])/<span class="number">2</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">while</span>(array[end]&gt;flag)&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array,start,end);</span><br><span class="line">            <span class="keyword">while</span>(array[start]&lt;=flag)&#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp =array[num1];</span><br><span class="line">        array[num1] =array[num2];</span><br><span class="line">        array[num2] =temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>根据数组特点</p>
<ul>
<li>方法：我们在遍历数组的时候，保存两个值，一个是数组中的数字，另一个是次数，当遍历到下一个数字的时候，如果和上一次的数字一样则次数加1，如果不一样次数减一(相当于抵消了)，如果次数为0了，那就保存下一个数字，并把次数设置为1，因为我们要找的数字如果存在最后一定是把次数设置为1的那个数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers.empty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//[1,2,3,2,4,2,5,2,3]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;numbers.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">0</span>)&#123;</span><br><span class="line">            temp = numbers[i];</span><br><span class="line">            time = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp == numbers[i])&#123;</span><br><span class="line">            ++time;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            --time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 temp 是否符合要求</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp == numbers[i])&#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; numbers.<span class="built_in">size</span>()/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
</li>
</ul>
<h4 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入n个整数，找出其中最小的K个数。例如输入<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>这<span class="number">8</span>个数字，则最小的<span class="number">4</span>个数字是<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,</span><br></pre></td></tr></table></figure>

<ul>
<li>维护一个最大堆，每次加入元素判断是否小于根节点，最终输出整个最大堆</li>
<li>java中使用优先队列来实现堆，此时重写优先队列中的比较函数</li>
<li>该方法常用于海量数据的获取  topk问题   <strong>O（nlogk</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> len = input.length;</span><br><span class="line">       <span class="keyword">if</span>(k&gt;len||k==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list;</span><br><span class="line">       &#125;</span><br><span class="line">       PriorityQueue&lt;Integer&gt; maxheap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> o2-o1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(maxheap.size()!=k)&#123;  <span class="comment">//maxheap不为k时不断的放入元素</span></span><br><span class="line">               maxheap.offer(input[i]);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (maxheap.peek()&gt;input[i])&#123;  <span class="comment">//等于k时 判断堆顶元素</span></span><br><span class="line">               maxheap.poll();</span><br><span class="line">             </span><br><span class="line">               maxheap.offer(input[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(Integer n:maxheap)&#123; <span class="comment">//遍历取出</span></span><br><span class="line">           list.add(n);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于快速排序（会改变原数组值）</li>
<li>思想：patition使得第k个元素的左边比他下，右边比他大    <strong>O（N）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = partition(input,start,end);</span><br><span class="line">        <span class="keyword">while</span>(index!=k-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;k-<span class="number">1</span>)&#123;</span><br><span class="line">        	end = index - <span class="number">1</span>;</span><br><span class="line">        	index = partition(input,start,end);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">            index = partition(input,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//输出前k个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用<span class="function"><span class="title">Insert</span>()方法读取数据流，使用<span class="title">GetMedian</span>()方法获取当前读取数据的中位数</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>问题在于该数据流是一直变化的</p>
</li>
<li><p>数据流排好序的</p>
</li>
<li><p>采用最大堆+最小堆的方式   堆中插入数据效率为O（logn）得到堆顶元素为O（1）</p>
</li>
<li><p>因为要求的是中位数，那么这两个堆，<strong>大顶堆用来存较小的数，从大到小排列</strong>；</p>
<p><strong>小顶堆存较大的数，从小到大的顺序排序</strong>，显然中位数就是大顶堆的根节点与小顶堆的根节点和的平均数。</p>
</li>
<li><p>实现细节：为了公平，规定偶数插入大顶堆，奇数插入小顶堆。再把相应最大最小的数添加到彼此的堆中</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小顶堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//大顶堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="number">15</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//记录偶数个还是奇数个</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每次插入小顶堆的是当前大顶堆中最大的数</span></span><br><span class="line">    <span class="comment">//每次插入大顶堆的是当前小顶堆中最小的数</span></span><br><span class="line">    <span class="comment">//这样保证小顶堆中的数永远大于等于大顶堆中的数</span></span><br><span class="line">    <span class="comment">//中位数就可以方便地从两者的根结点中获取了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//个数为偶数的话，则先插入到大顶堆，然后将大顶堆中最大的数插入小顶堆中</span></span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">            <span class="keyword">int</span> max = maxHeap.poll();</span><br><span class="line">            minHeap.offer(max);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//个数为奇数的话，则先插入到小顶堆，然后将小顶堆中最小的数插入大顶堆中</span></span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">            <span class="keyword">int</span> min = minHeap.poll();</span><br><span class="line">            maxHeap.offer(min);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前为偶数个，则取小顶堆和大顶堆的堆顶元素求平均</span></span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek() + maxHeap.peek())/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前为奇数个，则直接从小顶堆中取元素即可</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如:&#123;<span class="number">6</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">7</span>,<span class="number">-15</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,连续子向量的最大和为<span class="number">8</span>(从第<span class="number">0</span>个开始,到第<span class="number">3</span>个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>动态规划三步走</li>
</ul>
<ol>
<li>确定dp[]数组含义：截止这个数字为止，连续子数组最大的值</li>
<li>状态转移方程：dp[i] = max(dp[i-1]+array[i],array[i]) <ul>
<li>前一个数字的最大和与该处数字比较，取最大值</li>
</ul>
</li>
<li>base case：好像没啥，注意结果定义为数组第一个值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i] = math.max(dp[i-<span class="number">1</span>]+array[i],array[i])</span><br><span class="line">              max = math.max(max,dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1–n整数中1出现的次数"><a href="#1–n整数中1出现的次数" class="headerlink" title="1–n整数中1出现的次数"></a>1–n整数中1出现的次数</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求出<span class="number">1</span>~<span class="number">13</span>的整数中<span class="number">1</span>出现的次数,并算出<span class="number">100</span>~<span class="number">1300</span>的整数中<span class="number">1</span>出现的次数？为此他特别数了一下<span class="number">1</span>~<span class="number">13</span>中包含<span class="number">1</span>的数字有<span class="number">1</span>、<span class="number">10</span>、<span class="number">11</span>、<span class="number">12</span>、<span class="number">13</span>因此共出现<span class="number">6</span>次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中<span class="number">1</span>出现的次数（从<span class="number">1</span> 到 n 中<span class="number">1</span>出现的次数）。</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个 m*n 的棋盘中的每一个格都放一个礼物，每个礼物都有一定的价值（价值大于<span class="number">0</span>）.你可以从棋盘的左上角开始拿各种里的礼物，并每次向左或者向下移动一格，直到到达棋盘的右下角。给定一个棋盘及上面个的礼物，请计算你最多能拿走多少价值的礼物？</span><br></pre></td></tr></table></figure>

<img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20200303214920868.png" alt="image-20200303214920868" style="zoom:50%;" />

<ol>
<li><p>dp[]数组含义：该格子的最大价值</p>
</li>
<li><p>转移方程：f(i,j) = max(f(i-1,j), f(i,j-1)) + gift[i,j]；</p>
</li>
<li><p>base case：可以初始化第一行，第一列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxValue1</span><span class="params">(<span class="keyword">int</span>[][] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> rows = arr.length; <span class="comment">//行</span></span><br><span class="line">		<span class="keyword">int</span> cols = arr[<span class="number">0</span>].length; <span class="comment">//列</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span>[][] maxValue = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">					up = maxValue[i-<span class="number">1</span>][j];</span><br><span class="line">				<span class="keyword">if</span>(j&gt;<span class="number">0</span>)</span><br><span class="line">					left = maxValue[i][j-<span class="number">1</span>];</span><br><span class="line">			maxValue[i][j] = Math.max(up, left) + arr[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> maxValue[rows-<span class="number">1</span>][cols-<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ul>
<li><p>优化：二维数组转为一维数组</p>
</li>
<li><p>只保留相邻行</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxValue2</span><span class="params">(<span class="keyword">int</span>[][] arr)</span> </span>{
        <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length==<span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">0</span>;

        <span class="keyword">int</span> rows = arr.length;
        <span class="keyword">int</span> cols = arr[<span class="number">0</span>].length;
        <span class="keyword">int</span>[] maxValue = <span class="keyword">new</span> <span class="keyword">int</span>[cols];
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++) {
            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++) {
                <span class="keyword">int</span> left = <span class="number">0</span>;
                <span class="keyword">int</span> up = <span class="number">0</span>;
                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)
                    up = maxValue[j];
                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)
                    left = maxValue[j-<span class="number">1</span>];
                maxValue[j] = Math.max(up, left)+arr[i][j];
            }
        }
        <span class="keyword">return</span> maxValue[cols-<span class="number">1</span>];
    }
&lt;!--￼<span class="number">70</span>--&gt;
请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。例如，在字符串中”arabcacfr”，最长非重复子字符串为”acfr”，长度为<span class="number">4</span>。
&lt;!--￼<span class="number">71</span>--&gt;</code></pre>
</li>
<li><p><img src="https://pic4.zhimg.com/80/v2-ec6f1e5c8bd7902a4d6b2ffdf024e54f_1440w.jpg" alt="img"></p>
</li>
<li><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span>
        <span class="comment"># 保存每个字符上一次出现的位置索引</span>
        pos = {}
        l = <span class="number">0</span>
        maxlen = <span class="number">0</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):
            <span class="keyword">if</span> pos.get(s[i]) <span class="keyword">is</span> <span class="literal">None</span>:                
                l += <span class="number">1</span>                
            <span class="keyword">else</span>:
                maxlen = max(l, maxlen)
                d = i - pos[s[i]]
                l = d <span class="keyword">if</span> d&lt;=l <span class="keyword">else</span> l+<span class="number">1</span>
            pos[s[i]] = i       
        <span class="keyword">return</span> max(l, maxlen)
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 借用arraylist</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public static int lengthOfLongestSubstring(String str) &#123;</span><br><span class="line">  		if(str.length()==0)</span><br><span class="line">  			return 0;</span><br><span class="line">  		</span><br><span class="line">  		int maxLength=1;</span><br><span class="line">  		List&lt;Character&gt; list = new ArrayList&lt;Character&gt;();</span><br><span class="line">  		list.add(str.charAt(0));</span><br><span class="line">  		for(int i=1;i&lt;str.length();i++) &#123;</span><br><span class="line">  			if(list.contains(str.charAt(i))) &#123;</span><br><span class="line">  				//返回与当前字符相同字符的索引</span><br><span class="line">  				int index = list.indexOf(str.charAt(i)); </span><br><span class="line">  				list = list.subList(index+1, list.size());</span><br><span class="line">  				list.add(str.charAt(i));</span><br><span class="line">  				maxLength = Math.max(maxLength, list.size());</span><br><span class="line">  			&#125;else &#123;</span><br><span class="line">  				list.add(str.charAt(i));</span><br><span class="line">  				maxLength = Math.max(maxLength, list.size());</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		return maxLength;</span><br><span class="line">  	&#125;</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
<hr>
<h4 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在字符串中找出第一个只出现一次的字符</span><br></pre></td></tr></table></figure>

<ul>
<li><p>笨办法：从头开始遍历，比较每次元素在后续是否有相同 为O（n^2）</p>
</li>
<li><p>hash表：java hashmap忽略</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">findFirstNoRepeatChar</span><span class="params">(String str)</span></span>{
        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.trim().length()==<span class="number">0</span>){
            <span class="keyword">return</span> <span class="string">'0'</span>;
        }
        <span class="keyword">int</span> []counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];
        str = str.toLowerCase(); <span class="comment">//防止出现大小写混乱的情况</span>
        <span class="keyword">int</span> len = str.length();
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++){
            counts[str.charAt(i) - <span class="string">'a'</span>]++;
        }
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++){
            <span class="keyword">if</span>(counts[str.charAt(i) - <span class="string">'a'</span>] == <span class="number">1</span>){
                <span class="keyword">return</span> str.charAt(i);
            }
        }
        <span class="keyword">return</span> <span class="string">'0'</span>;
    }
&lt;!--￼<span class="number">74</span>--&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h4><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数<span class="keyword">P</span>。并将<span class="keyword">P</span>对<span class="number">1000000007</span>取模的结果输出。 即输出<span class="keyword">P</span>%<span class="number">1000000007</span></span><br></pre></td></tr></table></figure>

<ul>
<li>归并排序的思想 时间复杂度为O（nlogn）</li>
<li>外部排序，需要额外O（n）空间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 使用递归</span></span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end)<span class="keyword">return</span>; <span class="comment">//结束边界</span></span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">        MergeSort(array, start, mid);</span><br><span class="line">        MergeSort(array, mid+<span class="number">1</span>, end);</span><br><span class="line">        MergeOne(array, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MergeOne</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end-start+<span class="number">1</span>];  <span class="comment">//引入额外空间</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,i=start,j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;= end)&#123;</span><br><span class="line"><span class="comment">//如果前面的元素小于后面的不能构成逆序对</span></span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt;= array[j])</span><br><span class="line">                temp[k++] = array[i++];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果前面的元素大于后面的，那么在前面元素之后的元素都能和后面的元素构成逆序对</span></span><br><span class="line">                temp[k++] = array[j++];</span><br><span class="line">                cnt = (cnt + (mid-i+<span class="number">1</span>))%<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;= mid)</span><br><span class="line">            temp[k++] = array[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=end)</span><br><span class="line">            temp[k++] = array[j++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;k; l++)&#123;</span><br><span class="line">            array[start+l] = temp[l];  <span class="comment">//辅助数组存入原数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        MergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</span><br></pre></td></tr></table></figure>

<ol>
<li>可以使用两个栈，依次弹出元素直到元素不相同     时间复杂度为O(M+N)</li>
<li>长的链表先走k步，两个链表在从头走    时间复杂度为O(M+N)</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">     <span class="comment"># write code here</span></span><br><span class="line">     pTmp1 = pHead1</span><br><span class="line">     pTmp2 = pHead2</span><br><span class="line">     <span class="comment">#当链表1 和链表2 同时存在的时候</span></span><br><span class="line">     <span class="keyword">while</span> pTmp1 <span class="keyword">and</span> pTmp2:</span><br><span class="line">         <span class="comment">#当两个链表移动到值相同的时候，这个位置就是结点，直接返回pTmp1或pTmp2</span></span><br><span class="line">         <span class="keyword">if</span> pTmp1 == pTmp2:</span><br><span class="line">             <span class="keyword">return</span> pTmp1</span><br><span class="line">         <span class="comment">#移动指针的位置，两个同时移动，</span></span><br><span class="line">         pTmp1 = pTmp1.next</span><br><span class="line">         pTmp2 = pTmp2.next</span><br><span class="line"></span><br><span class="line">     <span class="comment">#第一个参数给比较短的那个链表的值</span></span><br><span class="line">     <span class="comment">#第二个参数给比较长的链表的值</span></span><br><span class="line">     <span class="comment">#第三个参数是比较短的那个链表头</span></span><br><span class="line">     <span class="comment">#第四个参数是比较长的那个链表头</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">findEqual</span><span class="params">(longPointer, shorPointer, longHead, shortHead)</span>:</span></span><br><span class="line">         k = <span class="number">0</span></span><br><span class="line">         <span class="comment"># 寻找出链表长度之间的差值，让长的链表继续走，直到链表走完为止，走了多少步，就说明，两个链表之间的差值是多少。</span></span><br><span class="line">         <span class="keyword">while</span> longPointer:</span><br><span class="line">             longPointer = longPointer.next</span><br><span class="line">             k += <span class="number">1</span></span><br><span class="line">         <span class="comment">#然后：</span></span><br><span class="line">         <span class="comment"># 先让长的那个去走k步</span></span><br><span class="line">         longPointer = longHead</span><br><span class="line">         shortPointer = shortHead</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">             longPointer = longPointer.next</span><br><span class="line">         <span class="comment">#长的走k步之后，再让两个链表一起移动，直到两个链表移动的位置的值相等为止，那么这个点就是 两个链表的第一个公共结点。</span></span><br><span class="line">         <span class="keyword">while</span> longPointer != shortPointer:</span><br><span class="line">             longPointer = longPointer.next</span><br><span class="line">             shortPointer = shortPointer.next</span><br><span class="line">         <span class="keyword">return</span> shortPointer</span><br><span class="line">     <span class="comment">#如果两个链表不一样的长度，那么假设是 第一个链表长度长，第二个链表已经走完了，结束了，那么第一个链表还没有走完，那么就调用我们封装好的函数，或者是看下面注释的代码。</span></span><br><span class="line">     <span class="keyword">if</span> pTmp1:</span><br><span class="line">         <span class="keyword">return</span> findEqual(pTmp1,pTmp2,pHead1,pHead2)</span><br><span class="line">     <span class="keyword">if</span> pTmp2:</span><br><span class="line">         <span class="keyword">return</span> findEqual(pTmp2, pTmp1, pHead2, pHead1)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="在排序数组中查找数字"><a href="#在排序数组中查找数字" class="headerlink" title="在排序数组中查找数字"></a>在排序数组中查找数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目一：统计一个数字在排序数组中出现的次数。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>hash法   O（n）</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>{
         Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();
        <span class="comment">//常用的map赋值</span>
        <span class="keyword">int</span> length = array.length;
        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;length;i++){
            <span class="keyword">if</span>(!map.containsKey(array[i])){
                map.put(array[i],<span class="number">1</span>);
            }<span class="keyword">else</span> {
                map.put(array[i],map.get(array[i])+<span class="number">1</span>);
            }
        }
        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {
            <span class="keyword">if</span>(entry.getKey()==k)
                <span class="keyword">return</span> entry.getValue();
        }
        <span class="keyword">return</span> <span class="number">0</span>;
    }
&lt;!--￼<span class="number">80</span>--&gt;
</code></pre>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目二：<span class="number">0</span>-n<span class="number">-1</span>中缺失的数字，数组排序</span><br></pre></td></tr></table></figure>

<ul>
<li><p>题目转化为排序数组中第一个与下标不一致的元素</p>
</li>
<li><p>二分法：</p>
<ul>
<li>当下标一样，说明该值左边排好序，找右边</li>
<li>不一样：<ul>
<li>如果前一个数字为一致元素，则该下标为查找值</li>
<li>如果前一个不为一致元素，则查找左半边</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMissNumber</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num.length() == <span class="number">0</span> || num == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = num.length();</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[mid]!=mid)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid == <span class="number">0</span>||num[mid-<span class="number">1</span>]==mid-<span class="number">1</span>)&#123;<span class="comment">//mid为0无左值</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == length)&#123;<span class="comment">//找到最右边</span></span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目三：找出单调递增数组中数值和下标相等的元素</span><br></pre></td></tr></table></figure>

<ul>
<li>二分</li>
<li>mid  &gt;  下标：后半边全部大于</li>
<li>mid  &lt;  下标：左半边全部小于</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumSameAsIndex</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = num.length();</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = num.length();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid == num[mid])&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid &gt; num[mid])&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a>二叉搜索树的第k大节点</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （<span class="number">5</span>，<span class="number">3</span>，<span class="number">7</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">6</span>，<span class="number">8</span>）    中，按结点数值大小顺序第三小结点的值为<span class="number">4</span>。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>二叉树的中序遍历为顺序</p>
</li>
<li><p>一个额外空间存放二叉树的中序遍历</p>
</li>
<li><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span>
        <span class="comment"># write code here</span>
        res = []
        <span class="comment">#中序遍历</span>
        <span class="function"><span class="keyword">def</span> <span class="title">preOrder</span><span class="params">(pRoot)</span>:</span>
            <span class="keyword">if</span> pRoot == <span class="literal">None</span>:
                <span class="keyword">return</span> <span class="literal">None</span>
            preOrder(pRoot.left)
            res.append(pRoot)
            preOrder(pRoot.right)

        preOrder(pRoot)
        <span class="keyword">if</span> len(res)&lt;k <span class="keyword">or</span> k&lt;<span class="number">1</span>:
            <span class="keyword">return</span> <span class="literal">None</span>
        <span class="keyword">return</span> res[k<span class="number">-1</span>]
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 非递归中序</span><br><span class="line"></span><br><span class="line">- 把左节点依次压栈，弹出节点找右子树</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  TreeNode KthNode(TreeNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="keyword">null</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">          Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">          <span class="keyword">while</span> (root != <span class="keyword">null</span> || ! stack.isEmpty()) &#123;</span><br><span class="line">              <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  stack.<span class="keyword">push</span>(root);</span><br><span class="line">                  root = root.left;</span><br><span class="line">              &#125;</span><br><span class="line">              root = stack.<span class="keyword">pop</span>();</span><br><span class="line">              <span class="keyword">count</span> ++;</span><br><span class="line">              <span class="keyword">if</span>(<span class="keyword">count</span> == k) <span class="keyword">return</span> root;</span><br><span class="line">              root = root.right;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<hr>
<h4 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最大深度等于   max(left,right)+1</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>{
        <span class="keyword">if</span>(root==<span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="number">0</span>;
        }<span class="keyword">else</span> {
            <span class="keyword">int</span> left = TreeDepth(root.left);
            <span class="keyword">int</span> right = TreeDepth(root.right);
            <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;
        }
    }
&lt;!--￼<span class="number">88</span>--&gt;


</code></pre>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断是否平衡二叉树</span><br></pre></td></tr></table></figure>

<ul>
<li><p>普通方法存在大量重复</p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> classSolution {
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>{
        <span class="keyword">if</span>(root == <span class="keyword">null</span>) {
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="keyword">return</span> Math.abs(maxDepth(root.left) - maxDepth(root.right)) &lt;= <span class="number">1</span> &amp;&amp;
            IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>{
        <span class="keyword">if</span>(root == <span class="keyword">null</span>) {
            <span class="keyword">return</span> <span class="number">0</span>;
        }
        <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
}
&lt;!--￼<span class="number">90</span>--&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="数组中出现的数字"><a href="#数组中出现的数字" class="headerlink" title="数组中出现的数字"></a>数组中出现的数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目一：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字</span><br></pre></td></tr></table></figure>

<ul>
<li><p>无聊的hash法</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>{
        <span class="keyword">int</span> length = array.length;
        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();
        <span class="comment">//常用的map赋值</span>
        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;length;i++){
            <span class="keyword">if</span>(!map.containsKey(array[i])){
                map.put(array[i],<span class="number">1</span>);
            }<span class="keyword">else</span> {
                map.put(array[i],map.get(array[i])+<span class="number">1</span>);
            }
        }
        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];
        <span class="keyword">int</span> k =<span class="number">0</span>;
        <span class="comment">//取出map集合中的key value 注意方法map.entryset()</span>
        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {
            <span class="keyword">if</span>(entry.getValue() == <span class="number">1</span>){
                num[k] = entry.getKey();
                k++;
            }
        }
        num1[<span class="number">0</span>]=num[<span class="number">0</span>];
        num2[<span class="number">0</span>]=num[<span class="number">1</span>];
    }
&lt;!--￼<span class="number">92</span>--&gt;


</code></pre>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目二：一个整型数组里除了一个数字之外，其他的数字都出现了三次。请写程序找出这一个只出现一次的数字</span><br></pre></td></tr></table></figure>

<ol>
<li>计算数组中所有数字对应的二进制数各个位置的和，即就是计算数组中所有数字对应的二进制数各个位置出现1的次数</li>
<li>若某一位上的数不能被3整除，则证明目标数字的这一位肯定为1</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindNumberApperingOnce</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number.size() &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bitSum[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//数组长度固定为O（1）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> bitmask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;=<span class="number">0</span>; j--)<span class="comment">//从低位开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitmask&amp;number[i])bitSum[j]++;</span><br><span class="line">            bitmask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)<span class="comment">//0是高位</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = result &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        result += bitSum[i] % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="和为s的数字"><a href="#和为s的数字" class="headerlink" title="和为s的数字"></a>和为s的数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>排序数组  二分</p>
</li>
<li><pre><code class="java"> <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>{
         ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();
        <span class="keyword">if</span> (array == <span class="keyword">null</span> )
            <span class="keyword">return</span> list;
        <span class="keyword">int</span> left = <span class="number">0</span>;
        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;
        <span class="keyword">while</span> (left &lt; right) {
            <span class="keyword">int</span> s = array[left] + array[right];
            <span class="keyword">if</span> (s == sum) {
                list.add(array[left]);
                list.add(array[right]);
                <span class="keyword">return</span> list;
            }<span class="keyword">else</span> {
                <span class="keyword">if</span> (s &gt; sum) {
                    right--;
                }<span class="keyword">else</span> {
                    left++;
                }
            }
        }
        <span class="keyword">return</span> list;
    }
&lt;!--￼<span class="number">96</span>--&gt;
输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
&lt;!--￼<span class="number">97</span>--&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目一：反转单词顺序</span><br></pre></td></tr></table></figure>

<ol>
<li>反转句子所有单词</li>
<li>反转每个单词</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">char</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || start &lt; <span class="number">0</span> || end &gt; array.Length - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = array[start];</span><br><span class="line">            array[start] = array[end];</span><br><span class="line">            array[end] = temp;</span><br><span class="line"></span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> string <span class="title">ReverseSentense</span><span class="params">(string sentense)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (string.IsNullOrEmpty(sentense))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] array = sentense.ToCharArray();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.Length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step1.先翻转整个句子</span></span><br><span class="line">        Reverse(array, start, end);</span><br><span class="line">        <span class="comment">// Step2.再翻转句中的每个单词</span></span><br><span class="line">        start = end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; array.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[start] == <span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                start++;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (end == array.Length || array[end] == <span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Reverse(array, start, --end);</span><br><span class="line">                start = end + <span class="number">1</span>;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> string(array);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目二:汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列<span class="attribute">S</span>=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</span><br></pre></td></tr></table></figure>

<ul>
<li><p>三次反转</p>
<ul>
<li>1.反转前面n个字符</li>
<li>2.反转后面n个字符</li>
<li>3.反转所有</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> len = chars.length;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(chars,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">    reverse(chars,n,len-<span class="number">1</span>);</span><br><span class="line">    reverse(chars,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer(len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c:chars)&#123;</span><br><span class="line">        sb.append(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h4 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a>队列的最大值</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;及滑动窗口的大小<span class="number">3</span>，那么一共存在<span class="number">6</span>个滑动窗口，他们的最大值分别为&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">5</span>&#125;； 针对数组&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;的滑动窗口有以下<span class="number">6</span>个： &#123;[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;， &#123;<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>],<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;， &#123;<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>],<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;， &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,[<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>],<span class="number">5</span>,<span class="number">1</span>&#125;， &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,[<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>],<span class="number">1</span>&#125;， &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,[<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>]&#125;。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>蛮力法，从头到尾滑动窗口 时间复杂度O（Nk）</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span>{
        ArrayList&lt;Integer&gt; list  = <span class="keyword">new</span> ArrayList&lt;Integer&gt; ();
        <span class="keyword">if</span>(size&gt;num.length||size==<span class="number">0</span>)
            <span class="keyword">return</span> list;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=num.length-size;i++){
            <span class="keyword">int</span> max = num[i];
            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;i+size;j++){
                <span class="keyword">if</span>(num[j]&gt;max){
                    max = num[j];
                }
            }
            list.add(max);
        }
        <span class="keyword">return</span> list;
    }
&lt;!--￼<span class="number">104</span>--&gt;












</code></pre>
</li>
</ul>
<h4 id="圆圈中最后的数字（约瑟夫问题）"><a href="#圆圈中最后的数字（约瑟夫问题）" class="headerlink" title="圆圈中最后的数字（约瑟夫问题）"></a>圆圈中最后的数字（约瑟夫问题）</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为<span class="number">0</span>的小朋友开始报数。每次喊到m<span class="number">-1</span>的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续<span class="number">0.</span>..m<span class="number">-1</span>报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从<span class="number">0</span>到n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">如果没有小朋友，请返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法一：模仿整个过程</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{
    <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{
        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) {
            list.add(i);
        }
        <span class="keyword">int</span> bt = <span class="number">0</span>;
        <span class="keyword">while</span> (list.size() &gt; <span class="number">1</span>) {
            bt = (bt + m - <span class="number">1</span>) % list.size();<span class="comment">//类似循环队列</span>
            list.remove(bt);
        }
        <span class="keyword">return</span> list.size() == <span class="number">1</span> ? list.get(<span class="number">0</span>) : -<span class="number">1</span>;
    }
}
&lt;!--￼<span class="number">106</span>--&gt;
假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可获得的最大利润是多少？
&lt;!--￼<span class="number">107</span>--&gt;


</code></pre>
</li>
</ul>
<hr>
<h4 id="树的公共祖先"><a href="#树的公共祖先" class="headerlink" title="树的公共祖先"></a>树的公共祖先</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">树中两个结点的最低公共祖先。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法一：假设是二叉搜索树（二叉搜索树是一个排序的二叉树，左子树的结点小于根结点，右子树的结点大于根结点），故找到一个结点，使其大于左子结点小于右子结点即可。</p>
</li>
<li><pre><code>public static TreeNode getLastCommonNode(TreeNode pRoot, TreeNode pLeft, TreeNode pRight){
    TreeNode treeNode = null;
    if(pRoot == null || pLeft.val &gt; pRight.val){
        return null;
    }
    if(pRoot.val &gt;= pRight.val){
        treeNode = getLastCommonNode(pRoot.left, pLeft, pRight);
    }
    if(pRoot.val &lt;= pLeft.val){
        treeNode = getLastCommonNode(pRoot.right, pLeft, pRight);
    }
    if(pRoot.val &gt;= pLeft.val &amp;&amp; pRoot.val &lt;= pRight.val){
        return pRoot;
    }
    return treeNode;
}
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 方法二：假设是普通的树，但是每个子结点都有指向父结点的指针，这样的话类似与前面的链表找公共结点一样。</span><br><span class="line"></span><br><span class="line">- 方法三：假设就是一棵普通的树，子结点没有指向父结点的指针。</span><br><span class="line"></span><br><span class="line">  - 定义两个数组，存放根节点分别到目标节点的路径，问题转化为查找两个数组第一个出现的相同值</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public static TreeNode get<span class="constructor">LastCommonParent(TreeNode <span class="params">pRoot</span>, TreeNode <span class="params">p1</span>, TreeNode <span class="params">p2</span>)</span>&#123;</span><br><span class="line">  	<span class="comment">//保存p1的路径</span></span><br><span class="line">  	ArrayList&lt;TreeNode&gt; path1 = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;<span class="literal">()</span>;</span><br><span class="line">  	<span class="comment">//保存p2的路径</span></span><br><span class="line">  	ArrayList&lt;TreeNode&gt; path2 = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;<span class="literal">()</span>;</span><br><span class="line">  	ArrayList&lt;TreeNode&gt; tmpList = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;<span class="literal">()</span>;</span><br><span class="line">  	get<span class="constructor">NodePath(<span class="params">pRoot</span>, <span class="params">p1</span>, <span class="params">tmpList</span>, <span class="params">path1</span>)</span>;</span><br><span class="line">  	get<span class="constructor">NodePath(<span class="params">pRoot</span>, <span class="params">p2</span>, <span class="params">tmpList</span>, <span class="params">path2</span>)</span>;</span><br><span class="line">  	<span class="comment">//如果路径不存在，返回空</span></span><br><span class="line">  	<span class="keyword">if</span>(path1.size<span class="literal">()</span><span class="operator"> == </span><span class="number">0</span><span class="operator"> || </span>path2.size<span class="literal">()</span><span class="operator"> == </span><span class="number">0</span>)&#123;</span><br><span class="line">  		return null;</span><br><span class="line">  	&#125;</span><br><span class="line">  	return get<span class="constructor">LastCommonParent(<span class="params">path1</span>, <span class="params">path2</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//获取根节点到目标节点的路径</span></span><br><span class="line">  public static void get<span class="constructor">NodePath(TreeNode <span class="params">pRoot</span>, TreeNode <span class="params">pNode</span>, ArrayList&lt;TreeNode&gt; <span class="params">tmpList</span>, ArrayList&lt;TreeNode&gt; <span class="params">path</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(pRoot<span class="operator"> == </span>pNode<span class="operator"> || </span>pRoot<span class="operator"> == </span>null)&#123;</span><br><span class="line">  		return ;</span><br><span class="line">  	&#125;</span><br><span class="line">  	tmpList.add(pRoot);</span><br><span class="line">  	ArrayList&lt;TreeNode&gt; childs = pRoot.children;</span><br><span class="line">  	for(TreeNode node : childs)&#123;</span><br><span class="line">  		<span class="keyword">if</span>(node<span class="operator"> == </span>pNode)&#123;</span><br><span class="line">  			path.add<span class="constructor">All(<span class="params">tmpList</span>)</span>;</span><br><span class="line">  			break;</span><br><span class="line">  		&#125;</span><br><span class="line">  		get<span class="constructor">NodePath(<span class="params">node</span>, <span class="params">pNode</span>, <span class="params">tmpList</span>, <span class="params">path</span>)</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	tmpList.remove(tmpList.size<span class="literal">()</span>-<span class="number">1</span>); <span class="comment">//清空集合</span></span><br><span class="line">  &#125;</span><br><span class="line">  	</span><br><span class="line">  <span class="keyword">private</span> static TreeNode get<span class="constructor">LastCommonParent(ArrayList&lt;TreeNode&gt; <span class="params">path1</span>, ArrayList&lt;TreeNode&gt; <span class="params">path2</span>)</span> &#123;</span><br><span class="line">  	TreeNode tmpNode = null;</span><br><span class="line">  	for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; path1.size<span class="literal">()</span>; i++)&#123;</span><br><span class="line">  		<span class="keyword">if</span>(path1.get(i)!=path2.get(i))&#123;</span><br><span class="line">  			break;</span><br><span class="line">  		&#125;</span><br><span class="line">  	    <span class="comment">//循环结束时tmpNode即为最后一个共同结点</span></span><br><span class="line">  		tmpNode = path1.get(i);</span><br><span class="line">  	&#125;</span><br><span class="line">  	return tmpNode;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</code></pre></li>
</ul>
<p>####</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/%E5%89%91%E6%8C%87offer/" data-id="ck9lj0kbq000i9sva29dh3rot" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/">计算机网络知识点</a>
          </li>
        
          <li>
            <a href="/2020/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">高并发知识点总结</a>
          </li>
        
          <li>
            <a href="/2020/04/29/Mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">Mysql知识点总结</a>
          </li>
        
          <li>
            <a href="/2020/04/29/java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89/">java常用集合（重点）</a>
          </li>
        
          <li>
            <a href="/2020/04/29/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/">多线程知识点</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 MRZ<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>MRZ de 博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录自己生活与学习的点点滴滴">
<meta property="og:type" content="website">
<meta property="og:title" content="MRZ de 博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="MRZ de 博客">
<meta property="og:description" content="记录自己生活与学习的点点滴滴">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="MRZ">
<meta property="article:tag" content="程序员，工程师，南京大学，java">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="MRZ de 博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MRZ de 博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">write something to the future!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-rabbitmq消息中间件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/rabbitmq%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="article-date">
  <time datetime="2020-03-26T07:12:53.814Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/rabbitmq%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">rabbitmq消息中间件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html>
<head>
<title>rabbitmq - 幕布</title>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="renderer" content="webkit"/>
<meta name="author" content="mubu.com"/>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="MRZ de 博客" type="application/atom+xml">
</head>
<body style="margin: 50px 20px;color: #333;font-family: SourceSansPro,-apple-system,BlinkMacSystemFont,'PingFang SC',Helvetica,Arial,'Microsoft YaHei',微软雅黑,黑体,Heiti,sans-serif,SimSun,宋体,serif">
<div class="export-wrapper"><div style="font-size: 22px; padding: 0 15px 0;"><div style="padding-bottom: 24px">rabbitmq</div><div style="background: #e5e6e8; height: 1px; margin-bottom: 20px;"></div></div><ul style="list-style: disc outside;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">基于AMQP协议</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应 用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户 端/中间件同产品、不同的开发语言等条件的限制</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">工作模型</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%223411710128b4f00ee-6082657%22%2C%22oh%22%3A458%2C%22ow%22%3A1240%2C%22uri%22%3A%22document_image%2Fa09649b8-10df-45e2-bf3f-715a22942a86-6082657.jpg%22%2C%22w%22%3A847%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/a09649b8-10df-45e2-bf3f-715a22942a86-6082657.jpg" style="max-width: 720px; width: 847px;" class="attach-img"></div></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%222ef1710128ffab082-6082657%22%2C%22oh%22%3A846%2C%22ow%22%3A1232%2C%22uri%22%3A%22document_image%2Fe8fa4fe6-d1a1-4c05-b160-74792f2fbf29-6082657.jpg%22%2C%22w%22%3A855%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/e8fa4fe6-d1a1-4c05-b160-74792f2fbf29-6082657.jpg" style="max-width: 720px; width: 855px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">常见交换机类型</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Direct Exchange 直连交换机</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">定义：直连类型的交换机与一个队列绑定时，需要指定一个明确的binding key。 路由规则：发送消息到直连类型的交换机时，只有routing key跟binding key完全匹配时，绑定的队列才能收到消 息。</span></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%221b71710129fb3208b-6082657%22%2C%22oh%22%3A592%2C%22ow%22%3A1264%2C%22uri%22%3A%22document_image%2Faba7141e-e71d-42a8-94c4-a24cca98641b-6082657.jpg%22%2C%22w%22%3A766%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/aba7141e-e71d-42a8-94c4-a24cca98641b-6082657.jpg" style="max-width: 720px; width: 766px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Topic Exchange 主题交换机</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">定义：主题类型的交换机与一个队列绑定时，可以指定按模式匹配的routing key。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">通配符有两个，*代表匹配一个单词。#代表匹配零个或者多个单词。单词与单词之间用 . 隔开。 路由规则：发送消息到主题类型的交换机时，routing key符合binding key的模式时，绑定的队列才能收到消息。</span></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%222df171012a8187073-6082657%22%2C%22oh%22%3A603%2C%22ow%22%3A1253%2C%22uri%22%3A%22document_image%2F5803b8a9-e21f-44db-93aa-befb70b5ca71-6082657.jpg%22%2C%22w%22%3A769%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/5803b8a9-e21f-44db-93aa-befb70b5ca71-6082657.jpg" style="max-width: 720px; width: 769px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Fanout Exchange 广播交换机</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">定义：广播类型的交换机与一个队列绑定时，不需要指定binding key。 路由规则：当消息发送到广播类型的交换机时，不需要指定routing key，所有与之绑定的队列都能收到消息。</span></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22394171012ae90f108-6082657%22%2C%22oh%22%3A442%2C%22ow%22%3A1251%2C%22uri%22%3A%22document_image%2Fbb43ffb6-ab6e-45fe-ab12-27c2787c8a05-6082657.jpg%22%2C%22w%22%3A802%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/bb43ffb6-ab6e-45fe-ab12-27c2787c8a05-6082657.jpg" style="max-width: 720px; width: 802px;" class="attach-img"></div></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">参数说明</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">声明交换机的参数</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">String type：交换机的类型，direct, topic, fanout中的一种。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">boolean durable：是否持久化，代表交换机在服务器重启后是否还存在。</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">声明队列的参数</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">boolean durable：是否持久化，代表队列在服务器重启后是否还存在。 boolean exclusive：是否排他性队列。排他性队列只能在声明它的Connection中使用，连接断开时自动删除。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">boolean autoDelete：是否自动删除。如果为true，至少有一个消费者连接到这个队列，之后所有与这个队列连接 的消费者都断开时，队列会自动删除。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Map&lt;String, Object&gt; arguments：队列的其他属性，例如x-message-ttl、x-expires、x-max-length、x-maxlength-bytes、x-dead-letter-exchange、x-dead-letter-routing-key、x-max-priority。</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">死信队列</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">有三种情况消息会进入DLX（Dead Letter Exchange）死信交换机。</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">1、(NACK || Reject ) &amp;&amp; requeue == false </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">2、消息过期 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">3、队列达到最大长度（先入队的消息会被发送到DLX）</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%221b0171012f3984015-6082657%22%2C%22oh%22%3A623%2C%22ow%22%3A1272%2C%22uri%22%3A%22document_image%2F3e588885-b9a9-46a7-a08d-0d03b0119a58-6082657.jpg%22%2C%22w%22%3A829%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/3e588885-b9a9-46a7-a08d-0d03b0119a58-6082657.jpg" style="max-width: 720px; width: 829px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">延迟队列</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">RabbitMQ本身不支持延迟队列。可以使用TTL结合DLX的方式来实现消息的延迟投递，即把DLX跟某个队列绑定， 到了指定时间，消息过期后，就会从DLX路由到这个队列，消费者可以从这个队列取走消息。 另一种方式是使用rabbitmq-delayed-message-exchange插件。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当然，将需要发送的信息保存在数据库，使用任务调度系统扫描然后发送也是可以实现的。</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">限流</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">服务端流控（Flow Control）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">RabbitMQ 会在启动时检测机器的物理内存数值。默认当 MQ 占用 40% 以上内存时，MQ 会主动抛出一个内存警 告并阻塞所有连接（Connections）。可以通过修改 rabbitmq.conﬁg 文件来调整内存阈值，默认值是 0.4，如下 所示：&nbsp; &nbsp;[{rabbit, [{vm_memory_high_watermark, 0.4}]}]. 默认情况，如果剩余磁盘空间在 1GB 以下，RabbitMQ 主动阻塞所有的生产者。这个阈值也是可调的。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">注意队列长度只在消息堆积的情况下有意义，而且会删除先入队的消息，不能实现服务端限流</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">消费端限流</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在AutoACK为false的情况下，如果一定数目的消息（通过基于consumer或者channel设置Qos的值）未被确认 前，不进行消费新的消息。</span></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22220171013175c00a3-6082657%22%2C%22oh%22%3A101%2C%22ow%22%3A1017%2C%22uri%22%3A%22document_image%2Fa0be6241-7fb4-484b-a6db-764b7a27d1fa-6082657.jpg%22%2C%22w%22%3A657%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/a0be6241-7fb4-484b-a6db-764b7a27d1fa-6082657.jpg" style="max-width: 720px; width: 657px;" class="attach-img"></div></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">可靠性投递：</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">首先需要明确，效率与可靠性是无法兼得的，如果要保证每一个环节都成功，势必会对消息的收发效率造成影响。&nbsp;如果是一些业务实时一致性要求不是特别高的场合，可以牺牲一些可靠性来换取效率。&nbsp;</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%2229c1710132f57f0d-6082657%22%2C%22oh%22%3A432%2C%22ow%22%3A1597%2C%22uri%22%3A%22document_image%2Ffc8cf6a2-3608-41c2-a766-a68fd37cd9e6-6082657.jpg%22%2C%22w%22%3A745%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/fc8cf6a2-3608-41c2-a766-a68fd37cd9e6-6082657.jpg" style="max-width: 720px; width: 745px;" class="attach-img"></div></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">1、确保消息发送到RabbitMQ服务器</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">可能因为网络或者Broker的问题导致①失败，而生产者是无法知道消息是否正确发送到Broker的。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">解决方案：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">第一种是Transaction（事务）模式 ：在通过channel.txSelect方法开启事务之后，我们便可以发布消息给RabbitMQ了，如果事务提交成功，则消息一定 到达了RabbitMQ中，如果在事务提交执行之前由于RabbitMQ异常崩溃或者其他原因抛出异常，这个时候我们便 可以将其捕获，进而通过执行channel.txRollback方法来实现事务回滚。使用事务机制的话会“吸干”RabbitMQ的性 能，一般不建议使用。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">第二种Conﬁrm（确认）模式：生产者通过调用channel.conﬁrmSelect方法（即Conﬁrm.Select命令）将信道设置为conﬁrm模式。一旦消息被投 递到所有匹配的队列之后，RabbitMQ就会发送一个确认（Basic.Ack）给生产者（包含消息的唯一ID），这就使得 生产者知晓消息已经正确到达了目的地了。</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">2、确保消息路由到正确的队列</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">可能因为路由关键字错误，或者队列不存在，或者队列名称错误导致②失败。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">解决方案：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">使用mandatory参数和ReturnListener，可以实现消息无法路由的时候返回给生产者。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">另一种方式就是使用备份交换机（alternate-exchange），无法路由的消息会发送到这个交换机上。</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">3、确保消息在队列正确地存储</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">可能因为系统宕机、重启、关闭等等情况导致存储在队列的消息丢失，即③出现问题。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">队列 交换机 消息持久化</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">4、确保消息从队列正确地投递到消费者</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">如果消费者收到消息后未来得及处理即发生异常，或者处理过程中发生异常，会导致④失败。</span></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">解决方案：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">为了保证消息从队列可靠地达到消费者，RabbitMQ提供了消息确认机制（message acknowledgement）。消费 者在订阅队列时，可以指定autoAck参数，当autoAck等于false时，RabbitMQ会等待消费者显式地回复确认信号 后才从队列中移去消息。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">如果消息消费失败，也可以调用Basic.Reject或者Basic.Nack来拒绝当前消息而不是确认。如果requeue参数设置为 true，可以把这条消息重新存入队列，以便发给下一个消费者（当然，只有一个消费者的时候，这种方式可能会出 现无限循环重复消费的情况，可以投递到新的队列中，或者只打印异常日志）。</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">消息重复可能会有两个原因：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">1、生产者的问题，环节①重复发送消息，比如在开启了Conﬁrm模式但未收到确认。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> 2、环节④出了问题，由于消费者未发送ACK或者其他原因，消息重复投递。 </span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">解决方案：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">对于重复发送的消息，可以对每一条消息生成一个唯一的业务ID，通过日志或者建表来做重复控制。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">比如：在写入消息队列的数据做唯一标示，消费消息时，根据唯一标识判断是否消费过；</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">消息的顺序性</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">消息的顺序性指的是消费者消费的顺序跟生产者产生消息的顺序是一致的。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在RabbitMQ中，一个队列有多个消费者时，由于不同的消费者消费消息的速度是不一样的，顺序无法保证。</span></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">解决方案：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">面试题</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">1、消息队列的作用与使用场景？</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">2、创建队列和交换机的方法？</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">3、多个消费者监听一个生产者时，消息如何分发？ </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">4、无法被路由的消息，去了哪里？</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">5、消息在什么时候会变成Dead Letter（死信）？</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> 6、RabbitMQ如何实现延迟队列？ </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">7、如何保证消息的可靠性投递？</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">8、如何在服务端和消费端做限流？</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> 9、如何保证消息的顺序性？</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">10、RabbitMQ的节点类型？</span></li></ul></li></ul></div>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>
</html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/rabbitmq%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" data-id="ck9li3zwg0004t0va3uc03wd9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JVM虚拟机" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="article-date">
  <time datetime="2020-03-26T07:12:44.250Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/">JVM虚拟机</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html>
<head>
<title>JVM虚拟机 - 幕布</title>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="renderer" content="webkit"/>
<meta name="author" content="mubu.com"/>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="MRZ de 博客" type="application/atom+xml">
</head>
<body style="margin: 50px 20px;color: #333;font-family: SourceSansPro,-apple-system,BlinkMacSystemFont,'PingFang SC',Helvetica,Arial,'Microsoft YaHei',微软雅黑,黑体,Heiti,sans-serif,SimSun,宋体,serif">
<div class="export-wrapper"><div style="font-size: 22px; padding: 0 15px 0;"><div style="padding-bottom: 24px">JVM虚拟机</div><div style="background: #e5e6e8; height: 1px; margin-bottom: 20px;"></div></div><ul style="list-style: disc outside;"><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">JVM基本结构</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">类加载子系统 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">运行时数据区（内存结构）</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> 执行引擎</span></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%221ed170b3c67024168-6082657%22%2C%22oh%22%3A988%2C%22ow%22%3A948%2C%22uri%22%3A%22document_image%2F34392fa0-ef69-4d3c-9a74-14877a417139-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/34392fa0-ef69-4d3c-9a74-14877a417139-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 30px;"><span class="content mubu-node collapsed" heading="2" style="line-height: 30px; min-height: 30px; font-size: 21px; padding: 2px 0px; display: inline-block; vertical-align: top;">内存结构</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">1.方法区（Method Area）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">所有定义的方法的 信息都保存在该区域，静态变量+常量+类信息（构造方法/接口定义）+运行时常量池都存在方法区中</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆）</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">运行时常量池</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">用于 存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，并非预置入Class文件中常量池的内容才能进入方 法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较 多的便是String类的intern（）方法</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">2.堆（Heap）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">概念：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">虚拟机启动时自动分配创建，用于存放对象的实例及数组，几乎所有对象（包括常量池）都在堆上分配内存</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当对象无法在 该空间申请到内存是将抛出OutOfMemoryError异常。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">垃圾收集器管理的主要区域</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">结构：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" images="%5B%7B%22id%22%3A%2244170b3cd6197122-6082657%22%2C%22oh%22%3A294%2C%22ow%22%3A1281%2C%22uri%22%3A%22document_image%2F64689cda-214a-4897-9756-6b198595bac3-6082657.jpg%22%7D%5D" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/64689cda-214a-4897-9756-6b198595bac3-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">新生代（Young Generation）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">新生代分为两部分：伊甸区（Eden space）和幸存者区（Survivor space），所有的类都是在伊甸区被new出来的。 幸存区又分为From和To区</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">JVM的垃圾回收器将Eden区进行垃圾回 收（Minor GC）</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">老年代（Old Generation）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">新生代经过多次GC仍然存货的对象移动到老年区。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">若老年代也满了，这时候将发生Major GC（也可以叫Full GC）， 进行老年区的内存清理。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">若老年区执行了Full GC之后发现依然无法进行对象的保存，就会抛出 OOM（OutOfMemoryError）异常</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">元空间（Meta Space）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在JDK1.8之后，元空间替代了永久代，它是对JVM规范中方法区的实现</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">区别在于元数据区不在虚拟机当中，而是用的本地内存，永久代在虚拟机当中，永久代逻辑结构上也属于堆，但是物理上不属于。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">移除永久代是为融合HotSpot与 JRockit而做出的努力，因为JRockit没有永久代，不需要配置永久代</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">3.栈(Stack）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一 致&nbsp;</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一个线程对应一个虚拟机栈，一个方法对应一个栈帧</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚 拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部 分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如 果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常</span></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">4.本地方法栈(Native Method Stack）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行native方法服务</span></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">5.程序计数器(Program Counter Register）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选 取下一条需要执行的字节码指令</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">就是一个指针，指向方法区中的方法字节码（用来存储指向吓一跳指令的地址，也即将要执行的指令代码），由执行 引擎读取下一条指令</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">是一个非常小的内存空间，几乎可以忽略不计</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">没有规定任何OutOfMemoryError情况的区域</span></li></ul></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">类加载机制</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">概念</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;"> 类生命周期</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" images="%5B%7B%22id%22%3A%22af170b3ea5f2b146-6082657%22%2C%22oh%22%3A425%2C%22ow%22%3A1172%2C%22uri%22%3A%22document_image%2F4424aef0-be3e-443f-9591-231d5beb0e92-6082657.jpg%22%7D%5D" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/4424aef0-be3e-443f-9591-231d5beb0e92-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">1.加载 ：将.class文件从磁盘读到内存</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">1）通过一个类的全限定名来获取定义此类的二进制字节流。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">2.连接 </span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">2.1 验证 ：验证字节码文件的正确性 </span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" color="#dc2d1e" heading="3" style="color: rgb(220, 45, 30); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">2.2 准备 ：给类的静态变量分配内存，并赋予默认值</span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">2.3 解析 ：类装载器装入类所引用的其它所有类</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">3.初始化</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">只在使用时，才会进行这个阶段</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#dc2d1e" style="color: rgb(220, 45, 30); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">为类的静态变量赋予正确的初始值，此处赋予的才是程序 编写者为变量分配的真正的初始值，执行静态代码块</span></li></ul></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">类启动器的种类</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">启动类加载器(Bootstrap ClassLoader)</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">负责加载JRE的核心类库，如JRE目标下的rt.jar，charsets.jar等 </span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">扩展类加载器(Extension ClassLoader)</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">负责加载JRE扩展目录ext中jar类包 </span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">系统类加载器(Application ClassLoader)</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">负责加载ClassPath路径下的类包 </span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">用户自定义加载器(User ClassLoader)</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">负责加载用户自定义路径下的类包</span></li></ul></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">类加载机制</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">全盘负责委托机制</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当一个ClassLoader加载一个类的时候，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个 ClassLoader载入</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">双亲委派机制</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">并不是一个具有强制性约束力的模型，而是java设计者推荐给开发者的一种类加载器实现的最佳机制</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">指先委托父类加载器寻找目标类，在找不到的情况下载自己的路径中查找并载入目标类</span></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22eb170f839ec3e0cf-6082657%22%2C%22oh%22%3A755%2C%22ow%22%3A780%2C%22uri%22%3A%22document_image%2Fe66a6300-da71-4cd9-8e1c-854e6945fd99-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/e66a6300-da71-4cd9-8e1c-854e6945fd99-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">双亲委派模式的优势</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">沙箱安全机制：比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改 避免类的重复加载：</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当父ClassLoader已经加载了该类的时候，就不需要子CJlassLoader再加载一次</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">双亲委派模型的局限性</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">父级加载器无法加载子级类加载器路径中的类。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">破坏双亲委派模型</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">JDBC</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等，SPI 的接口由 Java 核心库来提供</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径（CLASSPATH）里。SPI接口中的代码经常需要加载具体的实现类</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">有了线程上下文类加载器，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上已经打破了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">模块热部署</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">应用程序能够像我们的计算机外设那样，接上鼠标、U盘不用重启机器就能使用，鼠标有问题就换个鼠标，不用停机也不用重启。 </span></li></ul></li></ul></li></ul></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">GC算法与垃圾收集器</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">如何判断对象可以被回收&nbsp;</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#dc2d1e" heading="3" style="color: rgb(220, 45, 30); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">引用计数法</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">给对象添加一个引用计数器，每当有一个地方引用，计数器就加1。当引用失效，计数器就减1。任何时候计数器为0 的对象就是不可能再被使用的</span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">实现简单，效率高，它很难解决对象之前相互循环引用的问题</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" color="#dc2d1e" heading="3" style="color: rgb(220, 45, 30); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">可达性分析算法&nbsp;</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">算法的基本思想就是通过一系列的称为”GC Roots“的对象作为起点，从这些节点开始向下搜索，节点所走过的路 径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象时不可用的</span></li><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">GC Roots根节点：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">虚拟机栈（栈帧中的本地变量表）中引用的对象。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">方法区中类静态属性引用的对象。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">方法区中常量引用的对象。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">本地方法栈中JNI（即一般说的Native方法）引用的对象。</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">如何判断一个常量是废弃常量&nbsp;</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">运行时常量池主要回收的是废弃的常量。那么，我们怎么判断一个常量时废弃常量呢？</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">假如在常量池中存在字符串"abc"，如果当前没有任何String对象引用该字符串常量的话，就说明常量”abc“就是废弃 常量，如果这时发生内存回收的话而且有必要的话，”abc“会被系统清理出常量池。</span></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">如何判断一个类是无用的类</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">需要满足以下三个条件：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> 加载该类的 ClassLoader 已经被回收。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">虚拟机可以对满足上述3个条件的无用类进行回收，这里仅仅是”可以“，而并不是和对象一样不适用了就必然会被回 收。&nbsp;</span></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">再谈引用</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">强引用。强引用就是指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够， 都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引 用。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2之后，提供了PhantomReference类来实现虚引用。</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" color="#dc2d1e" heading="3" style="color: rgb(220, 45, 30); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">垃圾回收算法</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">标记-清除算法</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" images="%5B%7B%22id%22%3A%224170b3fface90e6-6082657%22%2C%22oh%22%3A686%2C%22ow%22%3A1005%2C%22uri%22%3A%22document_image%2Fbe321012-4928-4f25-94e3-186aa3899d7d-6082657.jpg%22%2C%22w%22%3A884%7D%5D" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/be321012-4928-4f25-94e3-186aa3899d7d-6082657.jpg" style="max-width: 720px; width: 884px;" class="attach-img"></div></li><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">两个不足的地方：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">1. 效率问题，标记和清除两个过程的效率都不高；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> 2. 空间问题，标记清除后会产生大量不连续的碎片；</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">复制算法（新生代）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" images="%5B%7B%22id%22%3A%2211c170b401372f07c-6082657%22%2C%22oh%22%3A674%2C%22ow%22%3A997%2C%22uri%22%3A%22document_image%2Fc9801180-53a3-4ad6-a4b5-ecd1d54be181-6082657.jpg%22%7D%5D" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/c9801180-53a3-4ad6-a4b5-ecd1d54be181-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">为了解决效率问题，复制算法出现了。它可以把内存分为大小相同的两块，每次只使用其中的一块。</span></li><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">当这一块的内存 使用完后，就将还存活的对象复制到另一块区，然后再把使用的空间一次清理掉。</span></li><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">这样就使每次的内存回收都是对内 存区间的一半进行回收</span></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">标记-整理算法</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">根据老年代的特点提出的一种标记算法，标记过程和“标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行 回收，而是让所有存活的对象向一段移动，然后直接清理掉边界以外的内存</span></li><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" images="%5B%7B%22id%22%3A%221cc170b40489bc022-6082657%22%2C%22oh%22%3A664%2C%22ow%22%3A998%2C%22uri%22%3A%22document_image%2F3dbe6abe-0193-4e5b-832f-88360292a901-6082657.jpg%22%7D%5D" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/3dbe6abe-0193-4e5b-832f-88360292a901-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">分代收集算法</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">在新生代中，每次收集都有大量对象死去，所以可以选择复制算法，只要付出少量对象的复制成本就可以完成每次垃 圾收集。</span></li><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">老年代的对象存活几率时比较高的，而且没有额外的空间对它进行分配担保，就必须选择“标记-清除”或 者“标记-整理”算法进行垃圾收集&nbsp;</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" color="#dc2d1e" heading="3" style="color: rgb(220, 45, 30); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">垃圾收集器</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">根据具体的应用场景选择合适的垃圾收集器</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" images="%5B%7B%22id%22%3A%229b170b407a84a0c2-6082657%22%2C%22oh%22%3A615%2C%22ow%22%3A943%2C%22uri%22%3A%22document_image%2Fe22376cb-d5e6-4c01-b181-664aa6b0d572-6082657.jpg%22%2C%22w%22%3A855%7D%5D" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/e22376cb-d5e6-4c01-b181-664aa6b0d572-6082657.jpg" style="max-width: 720px; width: 855px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">Serial收集器（单线程）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">简介</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">一个单线程收集器</span></li><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ）</span></li><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">新生代采用复制算法，老年代采用标记-整理算法</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">优点：简单高效，无线程交互开销</span></li><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">应用场景：运行在Client模式下的虚拟机</span></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">ParNew收集器（多线程）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">简介</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集 算法、回收策略等等）和Serial收集器完全一样</span></li><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">新生代采用复制算法，老年代采用标记-整理算法。</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">应用场景：在Server模式下的虚拟机的首要选择，，除了Serial收集器外，可与cms配合使用</span></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">Serial Old收集器（单线程）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">Serial收集器的老年代版本，它同样是一个单线程收集器</span></li><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">两大用途：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">一种用途是在JDK1.5以及以前的版本 中与Parallel Scavenge收集器搭配使用</span></li><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">另一种用途是作为CMS收集器的后备方案。&nbsp;</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">Parallel Scavenge收集器</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">Parallel Scavenge 收集器类似于ParNew 收集器。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停 顿时间（提高用户体验）。</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> Parallel Scavenge收集器提供了很多参数供用户找到合适的停顿时间或大吞吐量</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">新生代采用复制算法，老年代采用标记-整理算法。</span></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">Parallel Old收集器</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Parallel Scavenge收集器的老年代版本。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在注重吞吐量以及CPU资源的场合，都可以 优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">使用多线程和“标记-整理”算法。</span></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">CMS收集器</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">并行和并发概念补充：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序 在继续运行，而垃圾收集器运行在另一个CPU上</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">概念（Concurrent Mark Sweep）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">CMS（Concurrent Mark Sweep）收集器是一种以获取短回收停顿时间为目标的收集器。它而非常符合在注重用 户体验的应用上使用。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾 收集线程与用户线程（基本上）同时工作。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">运行过程</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">初始标记（CMS initial mark）： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">并发标记（CMS concurrent mark）： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶 段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">重新标记（CMS remark）： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生 变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶 段时间短 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">并发清除（CMS concurrent sweep）： 开启用户线程，同时GC线程开始对为标记的区域做清扫</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">初始标记（CMS initial mark） (stop the world)并发标记（CMS concurrent mark） (这一阶段用户线程可以工作)重新标记（CMS remark） (stop the world)并发清除（CMS concurrent sweep）(并发)</span></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22281170b418a61c025-6082657%22%2C%22oh%22%3A595%2C%22ow%22%3A1387%2C%22uri%22%3A%22document_image%2F4dc9420d-0bc6-4af0-992b-bcf6974d9976-6082657.jpg%22%2C%22w%22%3A931%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/4dc9420d-0bc6-4af0-992b-bcf6974d9976-6082657.jpg" style="max-width: 720px; width: 931px;" class="attach-img"></div></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">优缺点：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">优点：并发收集、低停顿。</span></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缺点：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">对CPU资源敏感；</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当CPU不足4个（譬如2个）时，CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还分出一半的运算能力去执行收集器线程 </span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">无法处理浮动垃圾；</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。(如果出现Concurrent Mode Failure，使用SerialOld备用方案)。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">CMS收集器提供了一个-XX：+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程。</span></li></ul></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">G1收集器</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">概念：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC停顿时间要求的同时,还具备高吞吐量性能特征</span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值大的Region(这也就是它的名 字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间 内可以尽可能高的收集效率（把内存化整为零）。&nbsp;</span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" images="%5B%7B%22id%22%3A%222e8170b41cc062122-6082657%22%2C%22oh%22%3A496%2C%22ow%22%3A1531%2C%22uri%22%3A%22document_image%2F177cadf0-eaf4-426b-accf-2a681f5c786a-6082657.jpg%22%7D%5D" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/177cadf0-eaf4-426b-accf-2a681f5c786a-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">特点：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短StopThe-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方 式让java程序继续执行 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基 于“复制”算法实现的 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追 求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内&nbsp;</span></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">过程：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">初始标记 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">并发标记 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">最终标记 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">筛选回收</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">怎么选择垃圾收集器？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">1. 优先调整堆的大小让服务器自己来选择</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> 2. 如果内存小于100m，使用串行收集器 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">3. 如果是单核，并且没有停顿时间的要求，串行或JVM自己选择 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">4. 如果允许停顿时间超过1秒，选择并行或者JVM自己选 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">5. 如果响应时间重要，并且不能超过1秒，使用并发收集器</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">官方推荐G1，性能高。</span></li></ul></li></ul></div>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>
</html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" data-id="ck9li3zx6000ht0va5jbm5f3b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库阅读视频笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%98%85%E8%AF%BB%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-03-26T07:12:18.896Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%98%85%E8%AF%BB%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/">数据库阅读视频笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html>
<head>
<title>数据库 - 幕布</title>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="renderer" content="webkit"/>
<meta name="author" content="mubu.com"/>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="MRZ de 博客" type="application/atom+xml">
</head>
<body style="margin: 50px 20px;color: #333;font-family: SourceSansPro,-apple-system,BlinkMacSystemFont,'PingFang SC',Helvetica,Arial,'Microsoft YaHei',微软雅黑,黑体,Heiti,sans-serif,SimSun,宋体,serif">
<div class="export-wrapper"><div style="font-size: 22px; padding: 0 15px 0;"><div style="padding-bottom: 24px">数据库</div><div style="background: #e5e6e8; height: 1px; margin-bottom: 20px;"></div></div><ul style="list-style: disc outside;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">InnoDB简介</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">存储引擎负责对表中的数据的进行读取和写入，常用的存储引擎有InnoDB、MyISAM、Memory等</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在InnoDB中，数据会存储到磁盘上，在真正处理数据时需要先将数据加载到内存，表中读取某些记录时，InnoDB存储引擎不需要一条一条的把记录从磁盘上读出来</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">InnoDB采取的方式是：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB，</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">也就是说，当需要从磁盘中读数据时每一次最少将从磁盘中读取16KB的内容到内存中，每一次最少也会把内存中的16KB内容写到磁盘中</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">关于主键</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一个表没有手动定义主键，则会选取一个Unique键作为主键</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">row_id是在没有自定义主键以及Unique键的情况下才会存在</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">索引分类</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">聚簇索引</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">特点</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">1. 按主键值的大小进行记录和页的排序：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">数据页(叶子节点)里的记录是按照主键值从小到大排序的一个单向链表。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">数据页(叶子节点)之间也是是按照主键值从小到大排序的一个双向链表。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">B+树中同一个层的页目录也是按照主键值从小到大排序的一个双向链表。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">2. B+树的叶子节点存储的是完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">二级索引（复制索引）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">引入</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">聚簇索引只能在搜索条件是主键值时才能发挥作用</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">别的列作为搜索条件时我们可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">二级索引与聚簇索引有几处不同：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">1. 按指定的索引列的值来进行排序</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">2. 叶子节点存储的不是完整的用户记录，而只是索引列+主键。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">3. 目录项记录中不是主键+页号，变成了索引列+页号。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">4. 在对二级索引进行查找数据时，需要根据主键值去聚簇索引中再查找一遍完整的用户记录，这个过程叫做回表</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">联合索引</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">以多个列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">覆盖索引：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">指从辅助索引中就能获取到需要的记录，而不需要查找聚簇索引中的记录。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">使用覆盖索引的一个好处是因为辅助索引不包括一条记录的整行信息，所以数据量较聚集索引要少，可以减少大量io操作</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">索引实战</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">代价</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">空间代价</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一个索引都为对应一棵B+树，树中每一个节点都是一个数据页，一个页默认会占用16KB的存储空间，所以一个 索引也是会占用磁盘空间的</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">时间代价</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">索引是对数据的排序，那么当对表中的数据进行增、删、改操作时，都需要去维护修改内容涉及到的B+树索引</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" color="#dc2d1e" style="color: rgb(220, 45, 30); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">索引使用（默认创建联合索引 bcd）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">全值匹配</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">select * from t1 where b = 1 and c = 1 and d = 1;</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">select * from t1 where b = 1 and c = 1 and d = 1;</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">匹配左边的列</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">select * from t1 where b = 1;</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> select * from t1 where b = 1 and c = 1;</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#dc2d1e" style="color: rgb(220, 45, 30); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">select * from t1 where c = 1;（使用不到索引）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#dc2d1e" style="color: rgb(220, 45, 30); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">为B+树先是按照b列的值排序的，在b列的值相同的情况下才使用c列进行排序</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">匹配列前缀</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">select * from t1 where b like '%101%';（使用不到）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">字符串中间有'101'的字符串并没有排好序，所以只能全表扫描</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询以com为后缀的网址的话可以这样写查询条件：WHERE url LIKE '%com'</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#dc2d1e" style="color: rgb(220, 45, 30); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">把url  颠倒过来 moc.udiab.www&nbsp;</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">再查找以com为后缀的网址时搜索条件便可以这么写：WHERE url LIKE 'moc%'，这样就可以用到索引</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">匹配范围值</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">select * from t1 where b &gt; 1 and b &lt; 20000;</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询过程：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> 找到b值为1的记录。</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">找到b值为20000的记录。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记录都可以很容易的取出来</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">找到这些记录的主键值，再到聚簇索引中回表查找完整的记录。</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">select * from t1 where b &gt; 1 and c &gt; 1;</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#dc2d1e" style="color: rgb(220, 45, 30); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">对多个列同时进行范围查找的话，只有对索引左边的那个 列进行范围查找的时候才能用到B+树索引</span></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询过程：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">1. 通过条件b &gt; 1来对b进行范围，查找的结果可能有多条b值不同的记录， </span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">2. 对这些b值不同的记录继续通过c &gt; 1继续过滤。</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">解释：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">只能用到b列的部分，而用不到c列的部分</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">因为只有b值相同的情况下才能用c列的值 进行排序，而这个查询中通过b进行范围查找的记录中可能并不是按照c列进行排序的</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">精确匹配某一列，范围匹配另一列</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">select * from t1 where b = 1 and c &gt; 1;</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">精确匹配到了B  b值相同情况下走c</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">排序</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">select * from t1 order by b, c, d;</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询的结果集需要先按照b值排序，如果记录的b值相同，则需要按照c来排序，如果c的值相同，则需要按照 d排序</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">这个B+树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">分组</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">select b, c, d, count(*) from t1 group by b, c, d;</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询语句相当于做了3次分组操作：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> 1. 先把记录按照b值进行分组，所有b值相同的记录划分为一组。</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> 2. 将每个b值相同的分组里的记录再按照c的值进行分组，将title值相同的记录放到一个分组里。</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> 3. 再将上一步中产生的分组按照d的值分成更小的分组。</span></li></ul></li></ul></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">如何建立索引</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">考虑索引的选择型</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数的比值</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">选择性的取值范围为(0, 1]，选择性越高的索引价值越大。</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">如果选择性等于1，就代表这个列的不重复值和表记录 数是一样的，那么对这个列建立索引是非常合适的</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">如果选择性非常小，那么就代表这个列的重复值是很多的， 不适合建立索引</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">考虑前缀索引</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当前缀长度合适时可以做到既使得前缀索引的选择性接近全列索引，</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">索引key变短而减少了索引文件的大小和维护开销</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于覆盖索引</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">总结</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">索引列的类型尽量小</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">利用索引字符串值的前缀</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">主键自增</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">定位并删除表中的重复和冗余索引</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">尽量使用覆盖索引进行查询，避免回表带来的性能损耗。</span></li></ul></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">数据库事务</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">ACID</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">原子性</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">一个不可分割的操作，我们把这种要么全做，要么全不做的规则称之为原子性</span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">隔离性</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">操作是不能相互影响的</span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">一致性</span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">持久性</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">对于转账的交易记录，需要永久保存</span></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">事务的概念</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">我们把需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称之为一个事务。</span></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">事务的使用</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">手动提交</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">begin + commit</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">自动提交</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">SET autocommit = ON（默认）</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">隐式提交</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">定义或修改数据库对象的数据定义语言（Data deﬁnition language，缩写为：DDL）。所谓的数据 库对象，指的就是数据库、表、视图、存储过程等等这些东西。当我们使用CREATE、ALTER、 DROP等语句去修改这些所谓的数据库对象时，就会隐式的提交前边语句所属于的事务。 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">隐式使用或修改mysql数据库中的表：当我们使用ALTER USER、CREATE USER、DROP USER、 GRANT、RENAME USER、SET PASSWORD等语句时也会隐式的提交前边语句所属于的事务。 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">事务控制或关于锁定的语句：当我们在一个事务还没提交或者回滚时就又使用START TRANSACTION或者BEGIN语句开启了另一个事务时，会隐式的提交上一个事务。或者当前的 autocommit系统变量的值为OFF，我们手动把它调为ON时，也会隐式的提交前边语句所属的事 务。或者使用LOCK TABLES、UNLOCK TABLES等关于锁定的语句也会隐式的提交前边语句所属 的事务。 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">加载数据的语句：比如我们使用LOAD DATA语句来批量往数据库中导入数据时，也会隐式的提交 前边语句所属的事务。 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">其它的一些语句：使用ANALYZE TABLE、CACHE INDEX、CHECK TABLE、FLUSH、 LOAD INDEX INTO CACHE、OPTIMIZE TABLE、REPAIR TABLE、RESET等语句也会隐式的提交前边语 句所属的事务</span></li></ul></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">隔离性分类详解</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">读未提交</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">一个事务可以读到其他事务还没有提交的数据，会出现脏读。</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">一个事务读到了另一个未提交事务修改过的数据，这就是脏读。</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">读已提交</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事 务都能查询得到最新值，会出现不可重复读、幻读。</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先 的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，这就是幻读​一个事务在自己没有更新数据库数据的情况，同一个查询操作执行两次或多次的结果应该是一致的；如果不一致，就说明为不可重复读。​​</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">可重复读（默认）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">一个事务第一次读过某条记录后，即使其他事务修改了该记录的值并且提交，该事务之后再读该条记录时，读到 的仍是第一次读到的值，而不是每次都读到不同的数据，这就是可重复读，这种隔离级别解决了不可重复，但是 还是会出现幻读。</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">串行化</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">如果我们不允许读-写、写-读 的并发操作，可以使用SERIALIZABLE隔离级别，这种隔离基金因为对同一条记录的操作都是串行的，所以不会 出现脏读、幻读等现象</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" color="#dc2d1e" heading="3" style="color: rgb(220, 45, 30); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">总结</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">READ UNCOMMITTED隔离级别下，可能发生<span class="bold" style="font-weight: bold;">脏读 、不可重复读和 和幻读</span>问题。 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">READ COMMITTED隔离级别下，可能发生<span class="bold" style="font-weight: bold;">不可重复读和幻读问题</span>，但是不会发生脏读**问 题。 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">REPEATABLE READ隔离级别下，可能发生<span class="bold" style="font-weight: bold;">幻读问题</span>，不会发生脏读和不可重复读的问题。 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">SERIALIZABLE隔离级别下，各种问题都不可以发生。</span></li></ul></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">版本链与ReadView</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">版本链</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列（row_id并不是必要的，我们 创建的表中有主键或者非NULL唯一键时都不会包含row_id列）： </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">roll_pointer：每次对某条记录进行改动时，这个隐藏列会存一个指针，可以通过这个指针找到该记 录修改前的信息。</span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" images="%5B%7B%22id%22%3A%2233f170b95b4333132-6082657%22%2C%22oh%22%3A753%2C%22ow%22%3A1032%2C%22uri%22%3A%22document_image%2Ffb3e8ac4-ea2d-469c-b185-eae03e8a77ff-6082657.jpg%22%7D%5D" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/fb3e8ac4-ea2d-469c-b185-eae03e8a77ff-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">ReadView</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">对于使用READ UNCOMMITTED隔离级别的事务来说，直接读取记录的最新版本就好了，对于使用 SERIALIZABLE隔离级别的事务来说，使用加锁的方式来访问记录。</span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">对于使用READ COMMITTED和 REPEATABLE READ隔离级别的事务来说，就需要用到我们上边所说的版本链了，核心问题就是：<span class="bold" style="font-weight: bold;">需要判断一下 版本链中的哪个版本是当前事务可见</span>的。</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">read commit实现方式</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">每次读取数据前都生成一个ReadView</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">repeatRead实现方式</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">在第一次读取数据时生成一个ReadView</span></li></ul></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">ReadView中主要包含4个比较重要的内容： 1. m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。 2. min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小 值。 3. max_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id值。 4. creator_trx_id：表示生成该ReadView的事务的事务id。</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之 后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1， max_trx_id的值就是4</span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见： </span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事 务生成ReadView前已经提交，所以该版本可以被当前事务访问。 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">如果被访问版本的trx_id属性值大于ReadView中的max_trx_id值，表明生成该版本的事务在当前事 务生成ReadView后才开启，所以该版本不可以被当前事务访问。 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下 trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃 的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版 本可以被访问</span></li></ul></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">MVVC总结</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" color="#333333" heading="3" style="color: rgb(51, 51, 51); line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD、 REPEATABLE READ这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链的过程。可以使不同 事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ这两个隔离级 别的一个很大不同就是：<span class="bold" style="font-weight: bold;">生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会 生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查 询操作都重复使用这个ReadView就好了</span></span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">锁</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">读锁和写锁</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">读锁：共享锁、Shared Locks、S锁。 </span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">写锁：排他锁、Exclusive Locks、X锁。</span></li></ul></li><li class="collapsed" style="line-height: 27px;"><span class="content mubu-node collapsed" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">读写操作</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">读操作</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">对于普通 SELECT 语句，InnoDB 不会加任何锁</span></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">select --- lock in share mode</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">将查找到的数据加上一个S锁，允许其他事务继续获取这些记录的S锁，不能获取这些记录的X锁（会阻塞）</span></li></ul></li><li style="line-height: 27px;"><span class="content mubu-node" heading="3" style="line-height: 27px; min-height: 27px; font-size: 19px; padding: 2px 0px; display: inline-block; vertical-align: top;">select --- for update</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">将查找到的数据加上一个X锁，不允许其他事务获取这些记录的S锁和X锁</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">写操作</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">DELETE：删除一条数据时，先对记录加X锁，再执行删除操作。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">INSERT：插入一条记录时，会先加隐式锁 <span class="bold" style="font-weight: bold;">隐式锁</span>来保护这条新插入的记录在本事务提交前不被别的事务访问到。 </span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">隐式锁：一个事务插入一条记录后，还未提交，这条记录会保存本次事务id，而其他事务如果想来读取这个记 录会发现事务id不对应，所以相当于在插入一条记录时，隐式的给这条记录加了一把隐式锁</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">update：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">如果被更新的列，修改前后没有导致存储空间变化，那么会先给记录加X锁，再直接 对记录进行修改。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">如果被更新的列，修改前后导致存储空间发生了变化，那么会先给记录加X锁，然后 将记录删掉，再Insert一条新记录。</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">行锁与写锁</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">行锁</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">LOCK_REC_NOT_GAP：单个行记录上的锁。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">LOCK_GAP：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务 的两次当前读，出现幻读的情况。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">LOCK_ORDINARY：锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</span></span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">READ COMMIT级别</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询使用主键</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询使用的是主键时，只需要在主键值对应的那一个条数据加锁即可。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询使用唯一键</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询使用的是唯一索引时，只需要对查询值所对应的唯一索引记录项和对应的聚集索引上的项加锁即可</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询使用普通的索引</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询使用的是普通索引时，会对满足条件的索引记录都加上锁，同时对这些索引记录对应的聚集索引上的项也加锁。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询没有使用索引</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询的时候没有走索引，也只会对满足条件的记录加锁。</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">REPEAT READ</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">前面两个和RC一致</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询使用普通索引</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">REPEATABLE READ级别可以解决幻读，解决的方式就是加了GAP锁。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询不使用索引</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询的时候没有走索引，会对表中所有的记录以及间隙加锁。</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">表锁</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">IS IX 锁</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">IS锁：意向共享锁、Intention Shared Lock。当事务准备在某条记录上加S锁时，需要先在表级别 加一个IS锁。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">IX锁，意向排他锁、Intention Exclusive Lock。当事务准备在某条记录上加X锁时，需要先在表级 别加一个IX锁</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#dc2d1e" style="color: rgb(220, 45, 30); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以 避免用遍历的方式来查看表中有没有上锁的记录。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">AUTO-INC锁</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT 修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC锁释放掉。这样一个事务在持有 AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连 续的。</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">采用一个轻量级的锁，在为插入语句生成AUTO_INCREMENT修饰的列的值时获取一下这个轻量级 锁，然后生成本次插入语句需要用到的AUTO_INCREMENT列的值之后，就把该轻量级锁释放掉， 并不需要等到整个插入语句执行完才释放锁。</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">悲观锁与乐观锁</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">悲观锁用的就是数据库的行锁，认为数据库会发生并发冲突，直接上来就把数据锁住，其他事务不能修改，直至 提交了当前事务。</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">乐观锁其实是一种思想，认为不会锁定的情况下去更新数据，如果发现不对劲，才不更新(回滚)。在数据库中往 往添加一个version字段来实现。</span></li><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">1、悲观锁，就是对数据的冲突采取一种悲观的态度，也就是说假设数据肯定会冲突，所以在数据开始读取的时候就把数据锁定住。【数据锁定：数据将暂时不会得到修改】</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">2、乐观锁，认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让用户返回错误的信息。让用户决定如何去做。</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">死锁避免</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" color="#333333" style="color: rgb(51, 51, 51); line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">以固定的顺序访问表和行</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">大事务拆小，大事务更容易产生死锁</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">降低隔离级别（下下签）</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">为表添加合理的索引</span></li></ul></li></ul></li></ul></div>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>
</html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%98%85%E8%AF%BB%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/" data-id="ck9li3zxc000lt0va64qk7kd0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis原理知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/redis%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86/" class="article-date">
  <time datetime="2020-03-26T07:05:54.663Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/redis%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86/">redis原理知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html>
<head>
<title>数据结构 - 幕布</title>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="renderer" content="webkit"/>
<meta name="author" content="mubu.com"/>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="MRZ de 博客" type="application/atom+xml">
</head>
<body style="margin: 50px 20px;color: #333;font-family: SourceSansPro,-apple-system,BlinkMacSystemFont,'PingFang SC',Helvetica,Arial,'Microsoft YaHei',微软雅黑,黑体,Heiti,sans-serif,SimSun,宋体,serif">
<div class="export-wrapper"><div style="font-size: 22px; padding: 0 15px 0;"></div><ul style="list-style: disc outside;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">数据结构</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">String——字符串</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在Redis内部，String类型通过 int、SDS(simple dynamic string)作为结构存储，int用来存放整型数据，sds存放字 节/字符串和浮点型数据</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">定义SDS对象，此对象中包含三个属性：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">len buf中已经占有的长度(表示此字符串的实际长度)</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">free buf中未使用的缓冲区长度</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">buf[] 实际保存字符串数据的地方</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%222a3170fd82d23007-6082657%22%2C%22oh%22%3A694%2C%22ow%22%3A1098%2C%22uri%22%3A%22document_image%2F33433c31-426b-4b52-960b-b8fe609c8183-6082657.jpg%22%2C%22w%22%3A604%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/33433c31-426b-4b52-960b-b8fe609c8183-6082657.jpg" style="max-width: 720px; width: 604px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Hash——字典</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">redis的散列可以存储多个键 值 对之间的映射，散列存储的值既可以是字符串又可以是数字值，并且用户同样可以对散列存储的数字值执行自增操作或者自减操作。散列可以看作是一个文档或关系数据库里的一行。hash底层的数据结构实现有两种：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一种是ziplist，上面已经提到过。当存储的数据超过配置的阀值时就是转用hashtable的结构。这种转换比较消耗性能，所以应该尽量避免这种转换操作。同时满足以下两个条件时才会使用这种结构：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当键的个数小于hash-max-ziplist-entries（默认512）</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当所有值都小于hash-max-ziplist-value（默认64）</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">另一种就是hashtable。这种结构的时间复杂度为O(1)，但是会消耗比较多的内存空间。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22305170fd8e2877063-6082657%22%2C%22oh%22%3A638%2C%22ow%22%3A1239%2C%22uri%22%3A%22document_image%2F3cb374c2-aa8b-4682-b516-71d78fa0e97f-6082657.jpg%22%2C%22w%22%3A780%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/3cb374c2-aa8b-4682-b516-71d78fa0e97f-6082657.jpg" style="max-width: 720px; width: 780px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">List——列表</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">列表类型内部使用双向链表实现，所以向列表两端添加元素的时间复杂度为O(1), 获取越接近两端的元素速度就越 快。</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是很快的</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">内部数据结构</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">redis3.2之前，List类型的value对象内部以linkedlist或者ziplist来实现, 当list的元素个数和单个元素的长度比较小 的时候，Redis会采用ziplist（压缩列表）来实现来减少内存占用。否则就会采用linkedlist（双向链表）结构。</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">这两种存储方式都有优缺点，双向链表在链表两端进行push和pop操作，在插入节点上复杂度比较低，但是内存开 销比较大； ziplist存储在一段连续的内存上，所以存储效率很高，但是插入和删除都需要频繁申请和释放内存；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">redis3.2之后，采用的一种叫quicklist的数据结构来存储list，列表的底层都由quicklist实现。&nbsp;</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">quicklist仍然是一个双向链表，只是列表的每个节点都是一个ziplist，其实就是linkedlist和ziplist的结合，quicklist 中每个节点ziplist都能够存储多个数据元素，在源码中的文件为【quicklist.c】，在源码第一行中有解释为：A doubly linked list of ziplists意思为一个由ziplist组成的双向链表；</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22280170fd8b88de0e-6082657%22%2C%22oh%22%3A922%2C%22ow%22%3A1332%2C%22uri%22%3A%22document_image%2Ffb878b98-c965-4566-a17c-d93fc114bb11-6082657.jpg%22%2C%22w%22%3A842%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/fb878b98-c965-4566-a17c-d93fc114bb11-6082657.jpg" style="max-width: 720px; width: 842px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Set——集合</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">集合类型中，每个元素都是不同的，也就是不能有重复数据，同时集合类型中的数据是无序的。一个集合类型键可 以存储至多232-1个 。集合类型和列表类型的最大的区别是有序性和唯一性 集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在。由于集合类型在redis内部是使用的值 为空的散列表(hash table)，所以这些操作的时间复杂度都是O(1).</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">数据结构</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Set在的底层数据结构以intset或者hashtable来存储。当set中只包含整数型的元素时，采用intset来存储，否则， 采用hashtable存储，但是对于set来说，该hashtable的value值用于为NULL。通过key来存储元素</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22174170fd8fe2d3162-6082657%22%2C%22oh%22%3A263%2C%22ow%22%3A1323%2C%22uri%22%3A%22document_image%2F9e827dbc-a924-4b10-bd62-9dc8b4e969d0-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/9e827dbc-a924-4b10-bd62-9dc8b4e969d0-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Sorted Set——有序集合</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member),每个成员都是各不相同的。有序集合的值则被称为分值（score），分值必须为浮点数。有序集合是redis里面唯一一个既可以根据成员访问元素(这一点和散列一样),又可以根据分值以及分值的排列顺序访问元素的结构。它的存储方式也有两种：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">是ziplist结构。</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">与上面的hash中的ziplist类似，member和score顺序存放并按score的顺序排列</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">另一种是skiplist与dict的结合。</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%2213c170fd9285ca089-6082657%22%2C%22oh%22%3A568%2C%22ow%22%3A1224%2C%22uri%22%3A%22document_image%2F74daf6b3-00bd-4c02-b877-e553e085ca4d-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/74daf6b3-00bd-4c02-b877-e553e085ca4d-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">BITMAP(位图)</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">HYPERLOG（）</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">GEOSPATIAL</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">原理分析</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">过期删除原理</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">消极方法（passive way）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在主键被访问时如果发现它已经失效，那么就删除它</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">数据量较大时，容易不及时清理，占据内存</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> 积极方法（active way）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">周期性地从设置了失效时间的主键中选择一部分失效的主键删除</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">对于那些从未被查询的key，即便它们已经过期，被动方式也无法清除。因此Redis会周期性地随机测试一些key， 已过期的key将会被删掉。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis每秒会进行10次操作，具体的流程：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 随机测试 20 个带有timeout信息的key；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> \2. 删除其中已经过期的key；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\3. 如果超过25%的key被删除，则重复执行步骤1； </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">这是一个简单的概率算法（trivial probabilistic algorithm），基于假设我们随机抽取的key代表了全部的key空 间。</span></li></ul></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis的数据是如何持久化的？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一种是RDB方式（redis database）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">根据指定的规则“定时”将内存中的数据存储在硬盘上</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当符合一定条件时，Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，等 到持久化过程都结束了，再用这个临时文件替换上次持久化好的文件</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">优缺点：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">优点：大规模数据的恢复，且对于数据恢复的完整性不是非常敏感</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缺点：后一次持久化后的数据可能丢失</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一种是AOF（append-only-ﬁle）方式</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在每次执行命令后将（更改）命令本身记录下来</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis存储非临时数据时，一般需要打开AOF持久化来降低进程终止导致的数据丢失。AOF可以将Redis执行 的每一条写命令追加到硬盘文件中，这一过程会降低Redis的性能，但大部分情况下这个影响是能够接受的，另外 使用较快的硬盘可以提高AOF的性能&nbsp;</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在启动时，Redis会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，载入的速度相对于RDB会慢一些&nbsp;</span></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">AOF的重写原理</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">什么时候启动重写？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前 数据集所需的小命令集合。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">重写流程？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">重写的流程是这样，主进程会fork一个子进程出来进行AOF重写，这个重写过程并不是基于原有的aof文件来做 的，而是有点类似于快照的方式，全量遍历内存中的数据，然后逐个序列到aof文件中。在fork子进程这个过程 中，服务端仍然可以对外提供服务，那这个时候重写的aof文件的数据和redis内存数据不一致了怎么办？不用担 心，这个过程中，主进程的数据更新操作，会缓存到aof_rewrite_buf中，也就是单独开辟一块缓存来存储重写期间 收到的命令，当子进程重写完以后再把缓存中的数据追加到新的aof文件。 当所有的数据全部追加到新的aof文件中后，把新的aof文件重命名为，此后所有的操作都会被写入新的aof文件。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">中途故障？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">如果在rewrite过程中出现故障，不会影响原来aof文件的正常工作，只有当rewrite完成后才会切换文件。因此这个 rewrite过程是比较可靠的</span></li></ul></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis内存回收策略？</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">并不是真正的LRU，全局扫描的代价过于大，redis又是单线程基于采样的LRU，也就是放弃了从所有数据中搜索解改为采样空间搜索优解。</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">默认的策略为noeviction策略，当内存使用达到阈值的时候，所有引起申请内存的命令会报错</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">allkeys-lru：从数据集（server.db[i].dict）中挑选近少使用的数据淘汰 </span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">适合的场景： 如果我们的应用对缓存的访问都是相对热点数据，那么可以选择这个策略</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">allkeys-random：随机移除某个key。 适合的场景：如果我们的应用对于缓存key的访问概率相等，则可以使用这个策略</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选近少使用的数据淘汰。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">适合场景：这种策略使得我们可以向Redis提示哪些key更适合被淘汰，我们可以自己控制</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis是单进程单线程？性能为什么这么快&nbsp;？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">官方的解释是，CPU并不是Redis的瓶颈所在，Redis的瓶颈主要在机器的内存和网络的带宽</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">单进程单线程好处</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">代码更清晰，处理逻辑更简单</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">不存在多进程或者多线程导致的切换而消耗CPU</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">单进程单线程弊端</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis快的主要原因是：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">完全基于内存</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">数据结构简单，对数据操作也简单</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">使用多路 I/O 复用模型</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">多路 I/O 复用模型是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</span></li></ul></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">集群</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">主从模式（可以实现读写分离）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">复制的作用是把redis的数据库复制多个副本部署在不同的服务器上，如果其中一台服务器出现故障，也能快速迁 移到其他服务器上提供服务。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">复制功能可以实现当一台redis服务器的数据更新后，自动将新的数据同步到其他服 务器上</span></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22302170faecf75e147-6082657%22%2C%22oh%22%3A349%2C%22ow%22%3A854%2C%22uri%22%3A%22document_image%2Ffb194f47-3b85-4bc4-b99a-0d1f1cb5d384-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/fb194f47-3b85-4bc4-b99a-0d1f1cb5d384-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">原理：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">全量复制</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份</span></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%2210b170fb1ef512136-6082657%22%2C%22oh%22%3A831%2C%22ow%22%3A1362%2C%22uri%22%3A%22document_image%2F05f0e158-ab86-4d73-ac78-8e96a238acce-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/05f0e158-ab86-4d73-ac78-8e96a238acce-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">复制策略：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">master/slave 复制策略是采用乐观复制，也就是说可以容忍在一定时间内master/slave数据的内容是不同的，但是 两者的数据会最终同步。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">具体来说，redis的主从同步过程本身是异步的，意味着master执行完客户端请求的命令 后会立即返回结果给客户端，然后异步的方式把命令同步给slave。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">这一特征保证启用master/slave后 master的性能不会受到影响。&nbsp;</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">问题：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">如果在这个数据不一致的窗口期间，master/slave因为网络问题断开连接，而这个时候，master 是无法得知某个命令最终同步给了多少个slave数据库</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">解决方案：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">min-slaves-to-write 3 表示只有当3个或以上的slave连接到master，master才是可写的</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">min-slaves-max-lag 10 表示允许slave最长失去连接的时间，如果10秒还没收到slave的响应，则master认为该 slave以断开</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">增量复制</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">从redis 2.8开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的 地方，继续复制下去，而不是从头开始复制一份</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">master node会在内存中创建一个backlog，master和slave都会保存一个replica oﬀset还有一个master id，oﬀset 就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次的replica oﬀset开始继续 复制</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">但是如果没有找到对应的oﬀset，那么就会执行一次全量同步</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">无硬盘复制&nbsp;</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">问题引入：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis复制的工作原理基于RDB方式的持久化实现的，也就是master在后台保存RDB快照，slave接 收到rdb文件并载入</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 当master禁用RDB时，如果执行了复制初始化操作，Redis依然会生成RDB快照，当master下次启动时执行该 RDB文件的恢复，但是因为复制发生的时间点不确定，所以恢复的数据可能是任何时间点的。就会造成数据出现问 题</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\2. 当硬盘性能比较慢的情况下（网络硬盘），那初始化复制过程会对性能产生影响</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">因此2.8.18以后的版本，Redis引入了无硬盘复制选项，可以不需要通过RDB文件去同步，直接发送数据</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">master**在内存中直接创建rdb，然后发送给slave，不会在自己本地落地磁盘了&nbsp;</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">哨兵机制</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">哨兵的作用就是监控Redis系统的运行状况，它的功能包括两个</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> \1. 监控master和slave是否正常运行</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> \2. master出现故障时自动将slave数据库升级为master</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">引入问题：哨兵的可用性如何解决？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">使用多个哨兵进行监控任务以保证系统足够稳定。此时哨兵不仅会监控master和slave，同时还会互相监 控；这种方式称为哨兵集群</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">哨兵集群需要解决故障发现、和master决策的协商机制问题&nbsp;</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">哨兵之间如何感知彼此存在？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">sentinel节点之间会因为共同监视同一个master从而产生了关联，一个新加入的sentinel节点需要和其他监视相同 master节点的sentinel相互感知</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">步骤：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 需要相互感知的sentinel都向他们共同监视的master节点订阅channel:sentinel:hello</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\2. 新加入的sentinel节点向这个channel发布一条消息，包含自己本身的信息，这样订阅了这个channel的sentinel 就可以发现这个新的sentinel</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\3. 新加入得sentinel和其他sentinel节点建立长连接</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">master 的故障发现？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">主观不可用：sentinel节点会定期向master节点发送心跳包来判断存活状态，一旦master节点没有正确响应，sentinel会把 master设置为“主观不可用状态”，然后它会把“主观不可用”发送给其他所有的sentinel节点去确认</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">客观不可用：当确认的 sentinel节点数大于&gt;quorum时，则会认为master是“客观不可用”，接着就开始进入选举新的master流程</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一致性算法Raft（决定新的master）</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一个 Raft 集群包含若干个服务器节点；通常是 5 个，这允许整个系统容忍 2 个节点的失效，每个节点处于以下三种状态之一：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">follower（跟随者）&nbsp;：所有结点都以&nbsp;follower&nbsp;的状态开始。如果没收到&nbsp;leader消息则会变成&nbsp;candidate状态。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">candidate（候选人）：会向其他结点“拉选票”，如果得到大部分的票则成为leader。这个过程就叫做Leader选举(Leader Election)。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">leader（领导者）：所有对系统的修改都会先经过leader。</span></li></ul></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%2216f170fb26f66205e-6082657%22%2C%22oh%22%3A597%2C%22ow%22%3A1190%2C%22uri%22%3A%22document_image%2F0c386e08-6bc9-4c01-bb4d-b5be57ceb51f-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/0c386e08-6bc9-4c01-bb4d-b5be57ceb51f-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">集群</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">哨兵和集群是两个独立的功能，当不需要对数据进行分片使用哨兵就够了，如果要进行水平扩容，集群是一个比较好的方式</span></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">结构：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一个Redis Cluster由多个Redis节点组构成</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">节点组中仅有一个master，以及0-n个slaver</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">只有master节点对用户提供写服务，读服务可以由master或者slave提供&nbsp;</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis的数据分区</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis Cluster采用哈希分区规则,采用虚拟槽分区</span></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22389170fb48f7e013a-6082657%22%2C%22oh%22%3A625%2C%22ow%22%3A1383%2C%22uri%22%3A%22document_image%2Fef375ec9-a995-4efd-9dad-ab1bece3b4d6-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/ef375ec9-a995-4efd-9dad-ab1bece3b4d6-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">HashTags</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">问题引入：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">某些时候要求某些相关联的key分配到相同机器</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">解决：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">引入了HashTag的概念，可以使得数据分布算法可以根据key的某一个部分进行计算，然后 让相关的key落到同一个数据分片</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">举个简单的例子</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">加入对于用户的信息进行存储， user:user1:id、user:user1:name/ 那么通过hashtag的方式</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> user:{user1}:id、user:{user1}.name; 表示 当一个key包含 {} 的时候，就不对整个key做hash，而仅对 {} 包括的字符串做hash。&nbsp;</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">重定向客户端</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis Cluster并不会代理查询，那么如果客户端访问了一个key并不存在的节点，这个节点是怎么处理的呢？</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">比如 我想获取key为msg的值，msg计算出来的槽编号为254，当前节点正好不负责编号为254的槽</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">那么就会返回客户 端下面信息：-MOVED 254 127.0.0.1:6381</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">表示客户端想要的254槽由运行在IP为127.0.0.1，端口为6381的Master实例服务。如果根据key计算得出的槽恰好由当前节点负责，则当期节点会立即返回结果</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">分片迁移</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">问题引入：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在一个稳定的Redis cluster下，每一个slot对应的节点是确定的，但是在某些情况下，节点和分片对应的关系会发 生变更</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 新加入master节点</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\2. 某个节点宕机</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当动态添加或减少node节点时，需要将16384个槽做个再分配，槽中的键值也要迁移。当然，这一过程， 在目前实现中，还处于半自动状态，需要人工介入。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">新增一个主节点</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">新增一个节点D，redis cluster的这种做法是从各个节点的前面各拿取一部分slot到D上。大致就会变成这样： </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">节点A覆盖1365-5460     节点B覆盖6827-10922     节点C覆盖12288-16383</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">节点D覆盖0-1364,5461-6826,10923-12287</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">删除一个主节点</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">先将节点的数据移动到其他节点上，然后才能执行删除</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">槽迁移的过程</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">为了保证slot数据的一致性，MasterA此时 对于slot内部数据提供读写服务的行为和通常状态下是有区别的</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">MIGRATING状态</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 如果客户端访问的Key还没有迁移出去，则正常处理这个key </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\2. 如果key已经迁移或者根本就不存在这个key，则回复客户端ASK信息让它跳转到MasterB去执行</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">IMPORTING状态</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 当来自客户端的正常访问不是从ASK跳转过来的，说明客户端还不知道迁移正在进行，很有可能操作了一个目前 还没迁移完成的并且还存在于MasterA上的key，如果此时这个key在A上已经被修改了，那么B和A的修改则会发生 冲突。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">对于MasterB上的slot上的所有非ASK跳转过来的操作，MasterB都不会去护理，而是通过MOVED 命令让客户端跳转到MasterA上去执行</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22290170fc0191fe15f-6082657%22%2C%22oh%22%3A494%2C%22ow%22%3A1312%2C%22uri%22%3A%22document_image%2F3e0d6470-8921-4651-b140-97751414fbe2-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/3e0d6470-8921-4651-b140-97751414fbe2-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">实战场景</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">分布式锁</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">什么是分布式锁呢？或者 为什么我们需要通过Redis来构建分布式锁？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">其实最根本原因就是Score（范围），因为在分布式架构中，所有的应用都是进程隔离的，在多进程访问共享资源的时候我们需要满足互斥性，就需要设定一个所有进程都能看得到的范 围，而这个范围就是Redis本身。所以我们才需要把锁构建到Redis中。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis里面提供了一些比较具有能够实现锁特性的命令</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">比如SETEX(在键不存在的情况下为键设置值)，那么我们可以基于这个命令来去实现一些简单的锁的操作&nbsp;</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">管道模式</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">管道技术：可以做到服务端未及时响应的时候，客户端也可以继续发送命令请求，做到客户 端和服务端互不影响，服务端并最终返回所有服务端的响应，大大提高了C/S模型交互的响应速度上有了质的提高&nbsp;</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">使用方法：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%2236d170fc7779070f6-6082657%22%2C%22oh%22%3A248%2C%22ow%22%3A739%2C%22uri%22%3A%22document_image%2F0a033b46-91c7-4d7b-b6fc-d8567f1f10ef-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/0a033b46-91c7-4d7b-b6fc-d8567f1f10ef-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Redis的应用架构</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">对于读多写少的高并发场景，我们会经常使用缓存来进行优化</span><br><span class="note" style="display: inline-block; color: rgb(136, 136, 136); line-height: 22px; min-height: 22px; font-size: 14px; padding-bottom: 2px;">比如说支付宝的余额展示功能，实际上99%的时候 都是查询，1%的请求是变更</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%221fb170fc79500b118-6082657%22%2C%22oh%22%3A821%2C%22ow%22%3A680%2C%22uri%22%3A%22document_image%2F0e699483-32a6-494d-b4ba-50c7a016e05b-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/0e699483-32a6-494d-b4ba-50c7a016e05b-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">数据一致性问题</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">如何更新缓存中的数据？</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 我是先更新缓存中的数据再更新数据库的数据；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\2. 还是修改数据库中的数据再更新缓存中的数据</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">redis中的数据和数据库中的数据不可能保证事务性达到统一的，这个是毫无疑问的</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">基于当前的场景进行权衡降低出现不一致问题的出现概率</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">更新缓存还是让缓存失效</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"> \1. 如果更新缓存的代价很小，那么可以先更新缓存，这个代价很小的意思是我不需要很复杂的计算去获得最新的 余额数字。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\2. 如果是更新缓存的代价很大，意味着需要通过多个接口调用和数据查询才能获得最新的结果，那么可以先淘汰 缓存。淘汰缓存以后后续的请求如果在缓存中找不到，自然去数据库中检索。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%221b2170fc82bf97143-6082657%22%2C%22oh%22%3A969%2C%22ow%22%3A1314%2C%22uri%22%3A%22document_image%2F8b69012a-097f-4aa0-ac52-0f10bbd69d5e-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/8b69012a-097f-4aa0-ac52-0f10bbd69d5e-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存常见问题：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存预热</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">用户请求数据之前，就把数据加载到缓存系统中</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">系统启动加载</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">定时加载</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存更新</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">定时更新</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">过期更新</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">写请求更新</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">先写数据库再写缓存：缓存数据库具有强一致性的要求</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">读请求更新</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存雪崩</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">原因：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">指设置缓存时采用了相同的过期时间，导致缓存在某一个时刻同时失效</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存服务器宕机宕机导致 缓存全面失效</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">请求全部转发到了DB层面，DB由于瞬间压力增大而导致崩溃。缓存失效导致的雪崩效应对底层系 统的冲击是很大的</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">解决方案：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 对缓存的访问，如果发现从缓存中取不到值，那么通过加锁或者队列的方式保证缓存的单进程操作，从而避免 失效时并发请求全部落到底层的存储系统上；但是这种方式会带来性能上的损耗</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\2. 将缓存失效的时间分散，降低每一个缓存过期时间的重复率 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\3. 如果是因为缓存服务器故障导致的问题</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一方面需要保证缓存服务器的高可用</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">另一方面，应用程序中可以采 用多级缓存</span></li></ul></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存降级</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">访问量剧增时，导致服务出现问题，优先保证核心业务的运行，减少关闭非核心业务堆资源的使用</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">写降级</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">只进行cache的更新，然后异步更新到数据库中，保证最终的一致性</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">读降级</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存穿透</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存穿透是指查询一个根本不存在的数据，缓存和数据源都不会命中。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">危害：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">缓存穿透问题可能会使后端数据源负载加大，由于很多后端数据源不具备高并发性，甚至可能造成后端数据源宕掉</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">解决方案：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\1. 如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访 问数据库，这种办法最简单粗暴。比如，”key” , “&amp;&amp;”。 </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">\2. 根据缓存数据Key的设计规则，将不符合规则的key进行过滤 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的BitSet中，不存在的数据将会被拦截掉，从而避免了对底层存储系统的查询压力</span></li></ul></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">布隆过滤器</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">简介：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一种空间效率极高的概率型算法和数据结构，主要用来 判断一个元素是否在集合中存在</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">是一个概率型的算法，所以会存在一定的误差，如果传入一个值去布隆过 滤器中检索，可能会出现检测存在的结果但是实际上可能是不存在的，但是肯定不会出现实际上不存在然后反馈存 在的结果</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter 通过极少的错误换取了存储空间的极大节省</span></li></ul></li><li class="collapsed" style="line-height: 24px;"><span class="content mubu-node collapsed" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">原理：</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。首先将位数组进行初始化，将里面每个位都设置位0。对于 集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数 组上面的一个点，然后将位数组对应的位置标记为1</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查询：W通过哈希映射到位数组上的3个点。如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">至于k个哈希函数的取值为多少，能够最大化的降低错误率（因为哈希函数越多，映射冲突会越少），这个地方就 会涉及到最优的哈希函数个数的一个算法逻辑</span></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22bc170fc9a80f6092-6082657%22%2C%22oh%22%3A383%2C%22ow%22%3A1621%2C%22uri%22%3A%22document_image%2F7150f6c1-fc0b-4766-8c59-aaf6d9686d1d-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/7150f6c1-fc0b-4766-8c59-aaf6d9686d1d-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" images="%5B%7B%22id%22%3A%22e4170fc9abbd517-6082657%22%2C%22oh%22%3A324%2C%22ow%22%3A1446%2C%22uri%22%3A%22document_image%2F3783083b-e46c-41a9-8c99-8a5d1860a81f-6082657.jpg%22%7D%5D" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"></span><div style="padding: 3px 0"><img src="https://img.mubu.com/document_image/3783083b-e46c-41a9-8c99-8a5d1860a81f-6082657.jpg" style="max-width: 720px;" class="attach-img"></div></li></ul></li></ul></li></ul></li></ul></div>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>
</html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/redis%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86/" data-id="ck9li3zx5000gt0vaaxm67c63" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-英语翻译" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91/" class="article-date">
  <time datetime="2020-03-26T06:54:40.055Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91/">英语翻译</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="英语翻译"><a href="#英语翻译" class="headerlink" title="英语翻译"></a>英语翻译</h2><p>翻译句子主要三种：简单句，并列句，复合句</p>
<ul>
<li>简单句：干掉修饰语，翻译主谓宾，然后修饰语一层一层的往上加<ul>
<li>简单句只有中心句+修饰语</li>
<li><strong>I will love  you</strong> ==for the rest of my life==</li>
</ul>
</li>
<li>并列句：找到并列连词，前一句简单句，后一句简单词，逐句翻译</li>
<li>复合句：找到关联词，劈开，先找主干：先主谓宾，再加修饰语，最后翻译从句<ul>
<li>从句主要有两大种：定语从句，同位语从句，其他从句均可视为修饰语<ul>
<li>关联词删除，==判断从句是否缺成分==（也就是是不是完整的一句话），缺的话就是定语，否则为同位语</li>
</ul>
</li>
<li>对于复合句而言，只要翻译对了主干就可以得到一部分的分</li>
</ul>
</li>
<li>关联词：<strong>关联词划分主，从句</strong><ul>
<li>that   which  ：定语，同位语从句</li>
<li>when why where who ：引导时间，原因，地点状语从句</li>
<li>and  while  but: 一般表示并列结构</li>
</ul>
</li>
</ul>
<p>翻译：完整，准确，通顺</p>
<ul>
<li><p>完整：简单句翻译主谓宾，并列句翻译每个句子的主谓宾，复合句翻译主干句</p>
</li>
<li><p>准确：单词句子翻译准确，无错误</p>
</li>
<li><p>通顺：语句通顺，符合中文阅读习惯</p>
</li>
<li><p>英文的嵌套思维转为中文思维</p>
</li>
</ul>
<p>下面举一个同位语的栗子</p>
<p>例句：But even as the number of English speakers expands further ,there are signs that the  predominance of the language may fade within the foreseeable future.</p>
<ul>
<li>逗号分隔的两个并列句，分别翻译</li>
<li>But even as the number of English speakers expands further <ul>
<li>as 和 with 一样 ，可以翻译为  随着。。。</li>
<li>但是，即使随着说英语的人数进一步增加</li>
</ul>
</li>
<li>there are signs ==that== the  predominance of the language may fade within the foreseeable future.<ul>
<li>去掉that后，从句仍然为一个独立的句子，所以为同位语</li>
<li>同位语的作用是为了对前文的补充说明的作用，所以翻译时“迹象表明：…”或者“迹象表明—”</li>
<li>先翻译前面：there are signs ：有迹象表明，该语言的优势在可预见的将来可能会消失。</li>
<li>再翻译后面： the  predominance of the language may fade within the foreseeable future.<ul>
<li><strong>the</strong>  predominance <strong>of</strong> the language ：<strong>a of b：这种类型 :翻译为：b的a</strong><ul>
<li>语言的优势</li>
</ul>
</li>
<li>句子比较简单：该语言的优势在可预见的将来可能会消失</li>
</ul>
</li>
<li>综合：迹象表明：该语言的优势在可预见的将来可能会消失。</li>
</ul>
</li>
<li>全句：但是，即使随着说英语的人数进一步增加，有迹象表明：该语言的优势在可预见的将来可能会消失。</li>
</ul>
<p>例句：Chomsky`s grammar should show pattens of language change <strong>that</strong> are indepent of the family tree.</p>
<ul>
<li>注意到这里的that引导的是定语从句（从句非完整的话），定语从句翻译时，从句要加主语：一般为:它，这</li>
<li>先翻译主句：Chomsky`s grammar should show pattens of language change<ul>
<li>乔姆斯基的语法应该显示了语言变化模式。</li>
</ul>
</li>
<li>从句，that翻译为 ：这  ：这独立于家谱</li>
<li>整合：乔姆斯基的语法应该显示了语言变化模式，这种模式独立于家谱</li>
<li>更好的翻译：乔姆斯基的语法应该显示独立于家谱的语言变化模式。</li>
</ul>
<p>例句：the virgin forest with its richness ==and== variety of trees was a real treasure-house ==which== extended from Maine all the way down to Georgia.</p>
<p>解析：</p>
<ul>
<li>这是一个复合句：which引导的定于从句</li>
<li>找主句：the virgin forest with its richness and variety of trees was a real treasure-house<ul>
<li>主句中的主谓宾：the virgin forest was a real treasure-house ：原始森林是一个真正的宝库</li>
<li>加修饰语：with its richness and variety of trees：丰富多样的树木</li>
<li>结合：拥有丰富且多样树木的原始森林是一个真正的宝库</li>
</ul>
</li>
<li>从句：which extended from <strong>Maine</strong> all the way down to <strong>Georgia</strong>.（大写的单词通常为人名，地名）<ul>
<li>which引导定语从句，这里直接翻译为  它</li>
<li>从缅因州一直延伸到佐治亚州</li>
</ul>
</li>
<li>整合：拥有丰富且多样树木的原始森林是一个真正的宝库，它从缅因州一直延伸到佐治亚州</li>
<li>注：这里的and前后为两个单词，并不构成句子</li>
</ul>
<hr>
<h4 id="英语二真题"><a href="#英语二真题" class="headerlink" title="英语二真题"></a>英语二真题</h4><ol start="19">
<li>It is easy to underestimate English writer James Herriot. He had such a pleasant, readable style that are might think that anyone could imitate it. How many times have I heard people say, “I could write a book, I just haven’t the time” Easily said. Not so easily done. James Herriot, contrary to popular opinion did not find it easy in his early days of, as he put it, “having a go at the writing game”. While he obviously had an abundance of natural talent, the final polished work that he have to the world was the result of years of practicing, re-writing and reading. Like the majority of authors, he had to suffer many disappointments and rejections along the way, but these made him all the more determined to succeed. Everything he achieved in life was earned the hard way and his success in the literacy field was no exception.</li>
</ol>
<ul>
<li>It is easy to underestimate English writer James Herriot. <ul>
<li>it is 。。。形式主语：这是很容易去低估英国作家家詹姆斯·赫里欧</li>
<li>形式主语在中文中是没有的，可以翻译为：詹姆斯·赫里欧是一位很容易让人低估的英国作家</li>
</ul>
</li>
<li>He had such a pleasant, readable style <strong>that</strong> are might think that anyone could imitate it.<ul>
<li>找到that将句子切开，这里是定语从句</li>
<li>他的作品有一种令人愉快、易读的风格，这种风格可能就让人以为任何人都能模仿他</li>
</ul>
</li>
<li>How many times have I heard people say     ,    “I could write a book, I just haven’t the time”<ul>
<li>逗号切开</li>
<li>How many times have I heard people say：我很多次（总是）听人说，</li>
<li>“I could write a book, I just haven’t the time” ：我也可以写书，也是没有时间</li>
</ul>
</li>
<li>Easily said. Not so easily done：容易说，但不容易做</li>
<li>James Herriot, <strong>contrary to popular opinion did not find it easy in his early days of,</strong> <strong>as he put it</strong>, “having a go at the writing game”. <ul>
<li>这种是属于插入语，在阅读理解中，逗号里面的句子都可以不用看：补充说明的作用，这里同样先跳过</li>
<li>James Herriot,as he put it, “having a go at the writing game”. ：詹姆斯·赫里欧，用他的话说，“在写作游戏中尝试”</li>
<li><strong>contrary to popular opinion did not find it easy in his early days of</strong> <ul>
<li><strong>contrary to popular opinion</strong> 与流行的观点相悖</li>
<li>did not find it easy in his early days of <ul>
<li>这句话少了主语，少了宾语</li>
<li>主语是James Herriot，宾语为“having a go at the writing game”</li>
<li>结合就是James Herriot did not find it easy <strong>in his early days</strong> of “having a go at the writing game”  ：詹姆斯·赫里欧在他早期，发现“在写作游戏中尝试”并不容易</li>
</ul>
</li>
</ul>
</li>
<li>整合：与大众的观点相反，詹姆斯·赫里欧在他早期发现，用他的话说，“在写作游戏中尝试”并不容易。</li>
</ul>
</li>
<li>While he obviously had an abundance of natural talent, the final polished work that he have to the world was the result of years of practicing, re-writing and reading.<ul>
<li>while 引导并列，前后两个句子分别翻译（while引导的是转折）</li>
<li>While he obviously had an abundance of natural talent：他显然极具天赋</li>
<li>the final polished work <strong>that</strong> he have to the world <strong>was</strong> the result of years of practicing, re-writing and reading<ul>
<li>that引导的定语从句，was谓语，切成三分</li>
<li>主：the final polished work，谓:was,宾：the result of years of practicing, re-writing and reading（a of b）：b的a   ：… 的结果 <ul>
<li>翻译：他最终出版的作品是多年练习、重写和阅读的结果</li>
</ul>
</li>
<li>最后加上修饰语（定语从句）： <strong>that</strong> he have to the world缺少的主语是出版的作品</li>
</ul>
</li>
<li>整合：但他留给世人的最终出版作品却是多年练习、重写和阅读的结果</li>
</ul>
</li>
<li>Like the majority of authors, he had to suffer many disappointments and rejections along the way, <strong>but</strong> these made him all the more determined to succeed<ul>
<li>并列的简单句，分别翻译</li>
<li>Like the majority of authors, he had to suffer many disappointments and rejections along the way,<ul>
<li>和大多数作家一样，他在写作过程中也遭受了许多失望和拒绝</li>
</ul>
</li>
<li><strong>but</strong> these made him all the more determined to succeed：但这些都使他更加坚定了成功的决心</li>
</ul>
</li>
<li>Everything he achieved in life <strong>was</strong> earned the hard way <strong>and</strong> his success in the literacy field <strong>was</strong> no exception.<ul>
<li>and引导的并列句，分别翻译</li>
<li>Everything he achieved in life <strong>was</strong> earned the hard way ：<ul>
<li>Everything he achieved in life 其实也是定语从句这里只是省略了that，因为句子过于简单</li>
<li>直译：他人生中取得的一切都是以一种困难的方式获得</li>
<li>意译：他人生中所取得的一切成就都是来之不易的</li>
</ul>
</li>
<li>his success in the literacy field <strong>was</strong> no exception：他在文学领域的成功也不例外</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91/" data-id="ck9li3zwl0008t0va02d18qq5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法作业" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/" class="article-date">
  <time datetime="2020-03-26T06:54:23.728Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/">算法作业</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="算法作业"><a href="#算法作业" class="headerlink" title="算法作业"></a>算法作业</h2><h4 id="解决方案的整体描述"><a href="#解决方案的整体描述" class="headerlink" title="解决方案的整体描述"></a>解决方案的整体描述</h4><ul>
<li>库所(Place)、变迁(Transition)、弧线(Arc)创建统一的节点类：id ， name ， token等</li>
<li>实现接口方法<ul>
<li>导入jdom工具包，用于解析xml文件</li>
<li>遍历xml文件，提取出库所(Place)、变迁(Transition)、弧线(Arc)中的信息依次封装入节点对象</li>
<li>确定输入库所，输出库所</li>
<li>使用数组来存放每个节的令牌信息</li>
<li>从输入库所开始使用广度优先遍历<ul>
<li>如果是库所：确定其相邻的变迁是否可达，可达的话递归遍历该变迁</li>
<li>如果是变迁：确定其是否被重复遍历，最多只能遍历二次，前库所相应令牌减一，后库所加一，再依次对后库所进行递归</li>
</ul>
</li>
<li>对结果写入到文件中</li>
</ul>
</li>
</ul>
<h4 id="整体解决方案的伪代码"><a href="#整体解决方案的伪代码" class="headerlink" title="整体解决方案的伪代码"></a>整体解决方案的伪代码</h4><ul>
<li><pre><code class="伪代码">类 node{
    id  name  token
    出节点列表  入节点列表
}
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="deletion">-</span></span><br></pre></td></tr></table></figure>
 getLogOfModel(String modelFile, String logFile) 
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="deletion">-</span></span><br></pre></td></tr></table></figure>
placeChildren = xml解析出的place集合
transitionChildren = xml解析出的transition
ArcChildren = xml解析出的Arc集合
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="deletion">-</span></span><br></pre></td></tr></table></figure>
for _ in xml解析出的place集合
    Node node = new Node(id name tocken)
for _ in xml解析出的transition集合
    Node node = new Node(id name tocken)
for _ in xml解析出的Arc集合
    出节点，入节点
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="deletion">-</span></span><br></pre></td></tr></table></figure>
BFS:
    if 是库所：
  for next in 所有相邻的变迁
        for (Node pre : next.in)
                    if (toKen[pre]] &lt;= 0)
                        该next变得不可达;
        if next 可达：
            加入遍历队列
           for i in 遍历队列:
               remove(i)
               递归bfs
else 为变迁：
    if 变迁访问了三次：
        则该路不通
    for (Node preNode : cur.in)：//遍历其前节点
        tocken[prenode]-=1
    for (Node nextNode : cur.out)：//遍历其后节点
        tocken[nextnode]+=1
        if nextnode == end：
            return
    curBFSNode.addAll(cur.out);
    for (Node next : curBFSNode) ：
        remove(next)
        BFS递归
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="deletion">-</span></span><br></pre></td></tr></table></figure>
writeTxt(logFile, string) // 写入文件中
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 解决方案各个模块的描述</span><br><span class="line"></span><br><span class="line">- 创建类的节点</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
  类 node{ 
      id  name  token
      isplace //是否为库所
      出节点列表  入节点列表
  }
  <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-<span class="ruby"> 引用第三方解析xml库</span></span><br><span class="line"></span><br><span class="line"><span class="ruby">  -</span></span><br></pre></td></tr></table></figure>
  //1.创建SAXBuilder对象
  SAXBuilder saxBuilder = new SAXBuilder();
  //2.加载文件流
  Document document = saxBuilder.build(new FileInputStream(new File(modelFile));
  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 解析xml</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
  for _ in xml解析出的place集合
      Node node = new Node(id name tocken)
      map.put(id,node)
  for _ in xml解析出的transition集合
      Node node = new Node(id name tocken)
      map.put(id,node)
  for _ in xml解析出的Arc集合
      //设置出节点，入节点
      arc(2).innode.(arc(1))
      arc(1).outnode.add(arc(2))
  <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-<span class="ruby"> 确定输入，输出库所</span></span><br><span class="line"></span><br><span class="line"><span class="ruby">  -</span></span><br></pre></td></tr></table></figure>
  for node in map.values:
      if node.isplace == true &amp;&amp; node.innode.size==0&amp;&amp;node.outnode&gt;0:
          输入库所
      else if (node.isPlace==true &amp;&amp; node.inNode.size&gt;0 &amp;&amp; node.outNode.size 、== 0)
          输出库所
  <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-<span class="ruby"> BFS</span></span><br><span class="line"></span><br><span class="line"><span class="ruby">  -</span></span><br></pre></td></tr></table></figure>
  if 是库所：
      for next in 所有相邻的变迁
          for (Node pre : next.in)
                      if (toKen[pre]] &lt;= 0)
                          该next变得不可达;
          if next 可达：
              加入遍历队列
             for i in 遍历队列:
                 remove(i)
                 递归bfs
  else 为变迁：
      if 变迁访问了三次：
          则该路不通
      for (Node preNode : cur.in)：//遍历其前节点
          tocken[prenode]-=1
      for (Node nextNode : cur.out)：//遍历其后节点
          tocken[nextnode]+=1
          if nextnode == end：
              return
      curBFSNode.addAll(cur.out);
      for (Node next : curBFSNode) ：
          remove(next)
          BFS递归
  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 写入文件</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
      if (file.exists()) {
          file.createNewFile();
          }
        fileOutputStream = new FileOutputStream(file);
        fileOutputStream.write(content.getBytes());
        fileOutputStream.flush();
        fileOutputStream.close();</code></pre>
</li>
</ul>
<h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><ul>
<li>第一个</li>
</ul>
<p><img src="C:%5CUsers%5C%E5%8D%97%E5%A4%A7%E5%AE%8B%E4%BB%B2%E5%9F%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191228230942308.png" alt="image-20191228230942308"></p>
<ul>
<li><p>结果</p>
<ul>
<li><img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20191228231001428.png" alt="image-20191228231001428" style="zoom:100%;" />
</li>
</ul>
</li>
<li><p>第二个</p>
</li>
</ul>
<p><img src="C:%5CUsers%5C%E5%8D%97%E5%A4%A7%E5%AE%8B%E4%BB%B2%E5%9F%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191228231331612.png" alt="image-20191228231331612"></p>
<ul>
<li>结果<ul>
<li><img src="C:%5CUsers%5C%E5%8D%97%E5%A4%A7%E5%AE%8B%E4%BB%B2%E5%9F%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191228231307718.png" alt="image-20191228231307718"></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/" data-id="ck9li3zwo000at0va9fy0fse1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time datetime="2020-03-26T06:54:07.935Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">java基础知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="javase"><a href="#javase" class="headerlink" title="javase"></a>javase</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>1.jdk与jre</p>
<ul>
<li>JDK：Java Development Kit</li>
<li>JRE：Java Runtime Environment</li>
</ul>
<p>简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ┌─    ┌──────────────────────────────────┐</span><br><span class="line"> │     │     Compiler, debugger, etc.     │</span><br><span class="line"> │     └──────────────────────────────────┘</span><br><span class="line">JDK ┌─ ┌──────────────────────────────────┐</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> │ JRE │      JVM + Runtime Library       │</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> └─ └─ └──────────────────────────────────┘</span><br><span class="line">       ┌───────┐┌───────┐┌───────┐┌───────┐</span><br><span class="line">       │Windows││ Linux ││ macOS ││others │</span><br><span class="line">       └───────┘└───────┘└───────┘└───────┘</span><br></pre></td></tr></table></figure>

<p>2.如何运行java文件？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────────┐</span><br><span class="line">│    Hello.java    │&lt;─── source code</span><br><span class="line">└──────────────────┘</span><br><span class="line">          │ compile</span><br><span class="line">          ▼</span><br><span class="line">┌──────────────────┐</span><br><span class="line">│   Hello.class    │&lt;─── byte code</span><br><span class="line">└──────────────────┘</span><br><span class="line">          │ execute</span><br><span class="line">          ▼</span><br><span class="line">┌──────────────────┐</span><br><span class="line">│    Run on JVM    │</span><br><span class="line">└──────────────────┘</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>javac</code>可以将<code>.java</code>源码编译成<code>.class</code>字节码；</li>
<li>使用<code>java</code>可以运行一个已编译的Java程序，参数是类名。</li>
</ul>
<hr>
<h4 id="java程序基础"><a href="#java程序基础" class="headerlink" title="java程序基础"></a>java程序基础</h4><ul>
<li><p>基本数据类型</p>
<ul>
<li>整数类型：byte，short，int，long</li>
<li>浮点数类型：float，double</li>
<li>字符类型：char</li>
<li>布尔类型：boolean</li>
</ul>
</li>
<li><p>占用字节数</p>
<ul>
<li><pre><code class="ascii">       ┌───┐
  byte │   │   1
       └───┘
       ┌───┬───┐
 short │   │   │ 2 
       └───┴───┘
       ┌───┬───┬───┬───┐
   int │   │   │   │   │ 4
       └───┴───┴───┴───┘
       ┌───┬───┬───┬───┬───┬───┬───┬───┐
  long │   │   │   │   │   │   │   │   │ 8
       └───┴───┴───┴───┴───┴───┴───┴───┘
       ┌───┬───┬───┬───┐
 float │   │   │   │   │ 4
       └───┴───┴───┴───┘
       ┌───┬───┬───┬───┬───┬───┬───┬───┐
double │   │   │   │   │   │   │   │   │ 8
       └───┴───┴───┴───┴───┴───┴───┴───┘
       ┌───┬───┐
  char │   │   │ 2
       └───┴───┘
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    `byte`恰好就是一个字节，而`long`和`<span class="built_in">double</span>`需要<span class="number">8</span>个字节。</span><br><span class="line"></span><br><span class="line">- 整型</span><br><span class="line"></span><br><span class="line">  - 对于整型类型，Java只定义了带符号的整型，因此，**最高位的bit表示符号位**（<span class="number">0</span>表示正数，<span class="number">1</span>表示负数）。各种整型能表示的最大范围如下：</span><br><span class="line"></span><br><span class="line">    - byte：<span class="number">-128</span> ~ <span class="number">127</span>      **<span class="number">2</span>^<span class="number">7</span>**</span><br><span class="line">    - short: <span class="number">-32768</span> ~ <span class="number">32767</span>    **<span class="number">2</span>^<span class="number">15</span>**</span><br><span class="line">    - <span class="built_in">int</span>: <span class="number">-2147483648</span> ~ <span class="number">2147483647</span>   **<span class="number">2</span>^<span class="number">31</span>**</span><br><span class="line">    - long: <span class="number">-9223372036854775808</span> ~ <span class="number">9223372036854775807</span></span><br><span class="line"></span><br><span class="line">  - 通常**JVM内部会把`<span class="built_in">bool</span>ean`表示为<span class="number">4</span>字节整数。**</span><br><span class="line"></span><br><span class="line">  - 整性运算</span><br><span class="line"></span><br><span class="line">    - 整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分</span><br><span class="line">    - 特别注意：**整数的除法对于除数为<span class="number">0</span>时运行时将报错，但编译不会报错。**</span><br><span class="line"></span><br><span class="line">  - 溢出</span><br><span class="line"></span><br><span class="line">    - 要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出*不会出错*，却会得到一个奇怪的结果</span><br><span class="line"></span><br><span class="line">    - eg</span><br><span class="line"></span><br><span class="line">      - 要解释上述结果，我们把整数`<span class="number">2147483640</span>`和`<span class="number">15</span>`换成二进制做加法：</span><br><span class="line"></span><br><span class="line">        ```ascii</span><br><span class="line">          <span class="number">0111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1000</span></span><br><span class="line">        + <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span></span><br><span class="line">        -----------------------------------------</span><br><span class="line">          <span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span></span><br></pre></td></tr></table></figure>

    由于最高位计算结果为`1`，因此，加法结果变成了一个负数</code></pre>
</li>
<li><p>类型自动提升和强制转型</p>
<ul>
<li>在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型（<strong>自动提升</strong>）</li>
<li>将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用<code>(类型)</code><ul>
<li>超出范围的强制转型会得到错误的结果，原因是int转型short，<code>int</code>的两个高位字节直接被扔掉，仅保留了低位的两个字节</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>浮点型</p>
<ul>
<li><p>只能进行加减乘除这些数值计算，不能做位运算和移位运算</p>
</li>
<li><p><strong>浮点数无法精确表示</strong>，比如十进制的<code>0.1</code>换算成二进制是一个无限循环小数</p>
</li>
<li><p><strong>正确的比较方法</strong>：判断两个浮点数之差的绝对值是否小于一个很小的数</p>
</li>
<li><p><strong>自动类型提升</strong>：整性与浮点型运算时，自动转化为浮点型</p>
</li>
<li><p><strong>强制转型</strong>：可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉</p>
</li>
<li><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>整数运算在除数为<code>0</code>时会报错，而浮点数运算在除数为<code>0</code>时，不会报错，但会返回几个特殊值：</p>
<ul>
<li><code>NaN</code>表示Not a Number</li>
<li><code>Infinity</code>表示无穷大</li>
<li><code>-Infinity</code>表示负无穷大</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>字符串</p>
<ul>
<li><p>字符串的不可变性</p>
<ul>
<li><p>执行<code>String s = &quot;hello&quot;;</code>时，JVM虚拟机先创建字符串<code>&quot;hello&quot;</code>，然后，把字符串变量<code>s</code>指向它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      s</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌───┬───────────┬───┐</span><br><span class="line">│   │  &quot;hello&quot;  │   │</span><br><span class="line">└───┴───────────┴───┘</span><br></pre></td></tr></table></figure>

<p>紧接着，执行<code>s = &quot;world&quot;;</code>时，JVM虚拟机先创建字符串<code>&quot;world&quot;</code>，然后，把字符串变量<code>s</code>指向它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      s ──────────────┐</span><br><span class="line">                      │</span><br><span class="line">                      ▼</span><br><span class="line">┌───┬───────────┬───┬───────────┬───┐</span><br><span class="line">│   │  &quot;hello&quot;  │   │  &quot;world&quot;  │   │</span><br><span class="line">└───┴───────────┴───┴───────────┴───┘</span><br></pre></td></tr></table></figure>

<p>原来的字符串<code>&quot;hello&quot;</code>还在，只是我们无法通过变量<code>s</code>访问它而已。因此，字符串的不可变是指字符串内容不可变。</p>
</li>
</ul>
</li>
<li><p>注意要区分空值<code>null</code>和空字符串<code>&quot;&quot;</code>，空字符串是一个有效的字符串对象，它不等于<code>null</code></p>
</li>
<li><p>数组字符串</p>
<ul>
<li><p>字符串是引用类型，因此我们先定义一个字符串数组：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>[] names = &#123;</span><br><span class="line">    <span class="string">"ABC"</span>, <span class="string">"XYZ"</span>, <span class="string">"zoo"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于<code>String[]</code>类型的数组变量<code>names</code>，它实际上包含3个元素，但每个元素都指向某个字符串对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          ┌─────────────────────────┐</span><br><span class="line">    names │   ┌─────────────────────┼───────────┐</span><br><span class="line">      │   │   │                     │           │</span><br><span class="line">      ▼   │   │                     ▼           ▼</span><br><span class="line">┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┐</span><br><span class="line">│   │░░░│░░░│░░░│   │ &quot;ABC&quot; │   │ &quot;XYZ&quot; │   │ &quot;zoo&quot; │   │</span><br><span class="line">└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┘</span><br><span class="line">      │                 ▲</span><br><span class="line">      └─────────────────┘</span><br></pre></td></tr></table></figure>

<p>对<code>names[1]</code>进行赋值，例如<code>names[1] = &quot;cat&quot;;</code>，效果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          ┌─────────────────────────────────────────────────┐</span><br><span class="line">    names │   ┌─────────────────────────────────┐           │</span><br><span class="line">      │   │   │                                 │           │</span><br><span class="line">      ▼   │   │                                 ▼           ▼</span><br><span class="line">┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┬───────┬───┐</span><br><span class="line">│   │░░░│░░░│░░░│   │ &quot;ABC&quot; │   │ &quot;XYZ&quot; │   │ &quot;zoo&quot; │   │ &quot;cat&quot; │   │</span><br><span class="line">└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┴───────┴───┘</span><br><span class="line">      │                 ▲</span><br><span class="line">      └─────────────────┘</span><br></pre></td></tr></table></figure>

<p>这里注意到原来<code>names[1]</code>指向的字符串<code>&quot;XYZ&quot;</code>并没有改变，仅仅是将<code>names[1]</code>的引用从指向<code>&quot;XYZ&quot;</code>改成了指向<code>&quot;cat&quot;</code>，其结果是字符串<code>&quot;XYZ&quot;</code>再也无法通过<code>names[1]</code>访问到了。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数组</p>
<ul>
<li>二维数组就是数组的数组，三维数组就是二维数组的数组；</li>
<li>多维数组的每个数组元素长度都不要求相同；</li>
<li>打印多维数组可以使用<code>Arrays.deepToString()</code>；</li>
</ul>
</li>
</ul>
<ul>
<li>命令行参数<ul>
<li>命令行参数类型是<code>String[]</code>数组；</li>
<li>命令行参数由JVM接收用户输入并传给<code>main</code>方法；</li>
<li>如何解析命令行参数需要由程序自己实现。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul>
<li><p>重载</p>
<ul>
<li>方法重载是指多个方法的方法名相同，但各自的参数不同；</li>
<li>重载方法应该完成类似的功能，参考<code>String</code>的<code>indexOf()</code>；</li>
<li>重载方法返回值类型应该相同。</li>
</ul>
</li>
<li><p>继承</p>
<ul>
<li><p>如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法</p>
</li>
<li><p>向上转型：</p>
<ul>
<li><p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">Person p = s; <span class="comment">// upcasting, ok</span></span><br><span class="line">Object o1 = p; <span class="comment">// upcasting, ok</span></span><br><span class="line">Object o2 = s; <span class="comment">// upcasting, ok</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>向下转型：父类类型强制转型为子类类型</p>
<ul>
<li><pre><code>Person p1 = new Student(); // upcasting, ok
Person p2 = new Person();
Student s1 = (Student) p1; // ok
Student s2 = (Student) p2; // runtime error! ClassCastException!
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  测试上面的代码，可以发现：</span><br><span class="line"></span><br><span class="line">  `Person`类型`p1`实际指向`Student`实例，`Person`类型变量`p2`实际指向`Person`实例。在向下转型的时候，把`p1`转型为`Student`会成功，因为`p1`确实指向`Student`实例，把`p2`转型为`Student`会失败，因为`p2`的实际类型是`Person`，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。</span><br><span class="line"></span><br><span class="line">  因此，向下转型很可能会失败。失败的时候，Java虚拟机会报`ClassCastException`。</span><br><span class="line"></span><br><span class="line">- 利用`instanceof`，在向下转型前可以先判断：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  Person p = <span class="keyword">new</span> Student()<span class="comment">;</span></span><br><span class="line">  if (p instanceof Student) &#123;</span><br><span class="line"><span class="title">      // 只有判断成功才会向下转型:</span></span><br><span class="line">      Student s = (Student) p<span class="comment">; // 一定会成功</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>多态：针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法</p>
<ul>
<li>允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码</li>
<li>子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；</li>
<li>Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；</li>
<li><code>final</code>修饰符有多种作用：<ul>
<li><code>final</code>修饰的方法可以阻止被覆写；</li>
<li><code>final</code>修饰的class可以阻止被继承；</li>
<li><code>final</code>修饰的field必须在创建对象时初始化，随后不可修改。</li>
</ul>
</li>
</ul>
</li>
<li><p>抽象</p>
<ul>
<li>通过<code>abstract</code>定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；</li>
<li>定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；</li>
<li>如果不实现抽象方法，则该子类仍是一个抽象类；</li>
<li>面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。</li>
</ul>
</li>
<li><p>接口</p>
<ul>
<li><p>Java的接口（interface）定义了纯抽象规范，一个类可以实现多个接口；</p>
</li>
<li><p>接口也是数据类型，适用于向上转型和向下转型；</p>
</li>
<li><p>接口的所有方法都是抽象方法，接口不能定义实例字段；</p>
</li>
<li><p><code>interface</code>的字段只能是<code>public static final</code>类型</p>
</li>
<li><p>接口可以定义<code>default</code>方法（JDK&gt;=1.8）</p>
<ul>
<li>实现类可以不必覆写<code>default</code>方法</li>
<li>新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法</li>
<li><code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</li>
</ul>
</li>
<li><p>接口与抽象区别</p>
<ul>
<li><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">abstract class</th>
<th align="center">interface</th>
</tr>
</thead>
<tbody><tr>
<td align="left">继承</td>
<td align="left">只能extends一个class</td>
<td align="center">可以implements多个interface</td>
</tr>
<tr>
<td align="left">字段</td>
<td align="left">可以定义实例字段</td>
<td align="center">不能定义实例字段</td>
</tr>
<tr>
<td align="left">抽象方法</td>
<td align="left">可以定义抽象方法</td>
<td align="center">可以定义抽象方法</td>
</tr>
<tr>
<td align="left">非抽象方法</td>
<td align="left">可以定义非抽象方法</td>
<td align="center">可以定义default方法</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><p>static关键字</p>
<ul>
<li>静态字段<ul>
<li>静态字段并不属于实例，而属于class，所有实例共享一个静态字段</li>
<li>实例对象能访问静态字段：编译器根据实例类型自动转换为<code>类名.静态字段</code>来访问静态对象（<strong>不推荐</strong>）</li>
</ul>
</li>
<li>静态方法<ul>
<li>调用静态方法不需要实例，无法访问<code>this</code>，但可以访问静态字段和其他静态方法；</li>
<li>常用作辅助方法：<ul>
<li>Arrays.sort()</li>
<li>Math.random()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>包</p>
<ul>
<li>Java内建的<code>package</code>机制是为了避免<code>class</code>命名冲突；- </li>
<li>JDK的核心类使用<code>java.lang</code>包，编译器会自动导入；</li>
<li>JDK的其它常用类定义在<code>java.util.*</code>，<code>java.math.*</code>，<code>java.text.*</code>，……；</li>
<li>包名推荐使用倒置的域名，例如<code>org.apache</code>。</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li>Java内建的访问权限包括<code>public</code>、<code>protected</code>、<code>private</code>和<code>package</code>权限；</li>
<li>Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束；</li>
<li><code>final</code>修饰符不是访问权限，它可以修饰<code>class</code>、<code>field</code>和<code>method</code>；<ul>
<li>用<code>final</code>修饰<code>class</code>可以阻止被继承</li>
<li>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写</li>
<li>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值</li>
<li>用<code>final</code>修饰局部变量可以阻止被重新赋值</li>
</ul>
</li>
<li>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="java核心类"><a href="#java核心类" class="headerlink" title="java核心类"></a>java核心类</h4><ul>
<li><p>String</p>
<ul>
<li><pre><code class="java">String`是一个引用类型，它本身也是一个`<span class="class"><span class="keyword">class</span></span>
<span class="class"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 字符串在`<span class="keyword">String</span>`内部是通过一个`<span class="keyword">char</span>[]`数组表示的，因此，按下面的写法也是可以的：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">String</span> s2 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'!'</span>&#125;);</span><br></pre></td></tr></table></figure></span></code></pre>
</li>
<li><p><strong>字符串<em>不可变</em></strong>。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的。</p>
</li>
</ul>
</li>
<li><p>字符串比较</p>
<ul>
<li><p>比较是否相同：使用<code>equals()</code>方法而不能用<code>==</code></p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        String s1 = <span class="string">"hello"</span>;
        String s2 = <span class="string">"hello"</span>;
        System.out.println(s1 == s2);
        System.out.println(s1.equals(s2));
    }
}
&lt;!--￼<span class="number">11</span>--&gt;

而较新的JDK版本的`String`则以`<span class="keyword">byte</span>[]`存储：如果`String`仅包含ASCII字符，则每个`<span class="keyword">byte</span>`存储一个字符，否则，每两个`<span class="keyword">byte</span>`存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的`String`通常仅包含ASCII字符：

&lt;!--￼<span class="number">12</span>--&gt;

对于使用者来说，`String`内部的优化不影响任何已有代码，因为它的`<span class="keyword">public</span>`方法签名是不变的。</code></pre>
</li>
</ul>
</li>
<li><p>StringBuilder</p>
<ul>
<li><pre><code class="java">String s = <span class="string">""</span>;
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {
    s = s + <span class="string">","</span> + i;
}
&lt;!--￼<span class="number">13</span>--&gt;</code></pre>
</li>
<li><p>支持链式操作</p>
<ul>
<li>链式操作的关键是，定义的<code>append()</code>方法会返回<code>this</code></li>
</ul>
</li>
<li><p><code>StringBuffer</code>是<code>StringBuilder</code>的线程安全版本，现在很少使用</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>Java的异常是<code>class</code>，它的继承关系如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                     ┌───────────┐</span><br><span class="line">                     │  Object   │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                           │</span><br><span class="line">                     ┌───────────┐</span><br><span class="line">                     │ Throwable │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                 ┌─────────┴─────────┐</span><br><span class="line">                 │                   │</span><br><span class="line">           ┌───────────┐       ┌───────────┐</span><br><span class="line">           │   Error   │       │ Exception │</span><br><span class="line">           └───────────┘       └───────────┘</span><br><span class="line">                 ▲                   ▲</span><br><span class="line">         ┌───────┘              ┌────┴──────────┐</span><br><span class="line">         │                      │               │</span><br><span class="line">┌─────────────────┐    ┌─────────────────┐┌───────────┐</span><br><span class="line">│OutOfMemoryError │... │RuntimeException ││IOException│...</span><br><span class="line">└─────────────────┘    └─────────────────┘└───────────┘</span><br><span class="line">                                ▲</span><br><span class="line">                    ┌───────────┴─────────────┐</span><br><span class="line">                    │                         │</span><br><span class="line">         ┌─────────────────────┐ ┌─────────────────────────┐</span><br><span class="line">         │NullPointerException │ │IllegalArgumentException │...</span><br></pre></td></tr></table></figure>

<p>从继承关系可知：<code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p>
<ul>
<li><code>OutOfMemoryError</code>：内存耗尽</li>
<li><code>NoClassDefFoundError</code>：无法加载某个Class</li>
<li><code>StackOverflowError</code>：栈溢出</li>
</ul>
<p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p>
<p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p>
<ul>
<li><code>NumberFormatException</code>：数值类型的格式错误</li>
<li><code>FileNotFoundException</code>：未找到文件</li>
<li><code>SocketException</code>：读取网络失败</li>
</ul>
<p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p>
<ul>
<li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li>
<li><code>IndexOutOfBoundsException</code>：数组索引越界</li>
</ul>
<p><strong>java规定：</strong></p>
<ul>
<li>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为Checked Exception。</li>
<li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li>
</ul>
<p>抛出异常：</p>
<p>调用<code>printStackTrace()</code>可以打印异常的传播栈，对于调试非常有用；</p>
<p>捕获异常并再次抛出新的异常时，应该持有原始异常信息；</p>
<p>通常不要在<code>finally</code>中抛出异常。如果在<code>finally</code>中抛出异常，应该原始异常加入到原有异常中。调用方可通过<code>Throwable.getSuppressed()</code>获取所有添加的<code>Suppressed Exception</code>。</p>
<hr>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>def：反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息</p>
<p>targe：反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法</p>
<ul>
<li><p>class</p>
<ul>
<li><p>JVM为每个加载的<code>class</code>及<code>interface</code>创建了对应的<code>Class</code>实例来保存<code>class</code>及<code>interface</code>的所有信息</p>
<ul>
<li><p>除了基本类型（int）外，其他均为class</p>
</li>
<li><p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = <span class="keyword">new</span> Class(String);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>获取一个<code>class</code>对应的<code>Class</code>实例后，就可以获取该<code>class</code>的所有信息；</p>
<ul>
<li><p>一个<code>Class</code>实例包含了该<code>class</code>的所有完整信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = <span class="string">"java.lang.String"</span>  │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│<span class="keyword">package</span> = <span class="string">"java.lang"</span>      │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│<span class="keyword">super</span> = <span class="string">"java.lang.Object"</span> │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│<span class="class"><span class="keyword">interface</span> </span>= CharSequence...│</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│field = value[],hash,...   │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│method = indexOf()...      │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>通过Class实例获取<code>class</code>信息的方法称为反射（Reflection）；</p>
<ul>
<li><p>如何获取一个<code>class</code>的<code>Class</code>实例？有三个方法：</p>
<p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello"</span>;</span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></table></figure>

<p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>JVM总是动态加载<code>class</code>，可以在运行期根据条件来控制加载class</p>
</li>
<li><p>因为<code>Class</code>实例在JVM中是唯一的，所以，上述方法获取的<code>Class</code>实例是同一个实例。可以用<code>==</code>比较两个<code>Class</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class cls1 = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">String s = <span class="string">"Hello"</span>;</span><br><span class="line">Class cls2 = s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> sameClass = cls1 == cls2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JVM动态加载<code>class</code>的特性：jvm只有使用到某个类时才会加载到内存</p>
</li>
</ul>
</li>
<li><p>访问字段</p>
<ul>
<li><p>Java的反射API提供的<code>Field</code>类封装了字段的所有信息：</p>
</li>
<li><p>通过<code>Class</code>实例的方法可以获取<code>Field</code>实例：<code>getField()</code>，<code>getFields()</code>，<code>getDeclaredField()</code>，<code>getDeclaredFields()</code>；</p>
</li>
<li><p>通过Field实例可以获取字段信息：<code>getName()</code>，<code>getType()</code>，<code>getModifiers()</code>；</p>
</li>
<li><p>通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用<code>setAccessible(true)</code>来访问非<code>public</code>字段。</p>
</li>
<li><p>通过反射读写字段是一种非常规方法，它会破坏对象的封装。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”</p>
<p>Java的注解可以分为三类：</p>
<ul>
<li>第一类是由编译器使用的注解，例如：<ul>
<li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li>
<li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li>
<li>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</li>
</ul>
</li>
<li>第二类是由工具处理<code>.class</code>文件使用的注解，这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</li>
<li>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</li>
</ul>
<hr>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul>
<li><p>简介</p>
<ul>
<li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li>
<li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li>
<li><code>Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>接口与实现分离</li>
<li>支持泛型</li>
</ul>
</li>
<li><p>Java集合使用统一的<code>Iterator</code>遍历</p>
</li>
<li><p>list：顺序列表</p>
<ul>
<li><code>ArrayList</code><ul>
<li>在内部使用了数组来存储所有元素</li>
<li>数组已满，没有空闲位置的时候，<code>ArrayList</code>先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组</li>
<li>添加和删除的操作封装起来，让我们操作<code>List</code>类似于操作数组，却不用关心内部元素如何移动</li>
</ul>
</li>
<li>LinkedList<ul>
<li>链表形式</li>
</ul>
</li>
</ul>
</li>
<li><p>比较一下<code>ArrayList</code>和<code>LinkedList</code>：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">ArrayList</th>
<th align="left">LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取指定元素</td>
<td align="left">速度很快</td>
<td align="left">需要从头开始查找元素</td>
</tr>
<tr>
<td align="left">添加元素到末尾</td>
<td align="left">速度很快</td>
<td align="left">速度很快</td>
</tr>
<tr>
<td align="left">在指定位置添加/删除</td>
<td align="left">需要移动元素</td>
<td align="left">不需要移动元素</td>
</tr>
<tr>
<td align="left">内存占用</td>
<td align="left">少</td>
<td align="left">较大</td>
</tr>
</tbody></table>
</li>
<li><p>equals</p>
<ul>
<li><p><code>List</code>的实现类通过元素的<code>equals()</code>方法比较两个元素是否相等</p>
</li>
<li><p>Java标准库提供的<code>String</code>、<code>Integer</code>等已经覆写了<code>equals()</code>方法</p>
</li>
<li><p>自定义的对象需要覆写euquals方法</p>
<ul>
<li><p>如何正确编写<code>equals()</code>方法？<code>equals()</code>方法要求我们必须满足以下条件：</p>
<ul>
<li>自反性（Reflexive）：对于非<code>null</code>的<code>x</code>来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li>
<li>对称性（Symmetric）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li>
<li>传递性（Transitive）：对于非<code>null</code>的<code>x</code>、<code>y</code>和<code>z</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>；</li>
<li>一致性（Consistent）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，只要<code>x</code>和<code>y</code>状态不变，则<code>x.equals(y)</code>总是一致地返回<code>true</code>或者<code>false</code>；</li>
<li>对<code>null</code>的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li>
</ul>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>{
    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) {
        Person p = (Person) o;
        <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}
&lt;!--￼<span class="number">21</span>--&gt;


</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- **`entrySet()`集合**

  - ```java
    for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
                String key = entry.getKey();
                Integer value = entry.getValue();
                System.out.println(key + &quot; = &quot; + value);
            }
    <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 在`Map`的内部，对`key`做比较是通过`equals()`实现的</span><br><span class="line"></span><br><span class="line">    - 使用`String`作为`key`，因为`String`已经正确覆写了`equals()`方法</span><br><span class="line"></span><br><span class="line">    - 编写`equals()`和`hashCode()`遵循的原则是：</span><br><span class="line"></span><br><span class="line">      - `equals()`用到的用于比较的每一个字段，都必须在`hashCode()`中用于计算；</span><br><span class="line">      - `equals()`中没有使用到的字段，绝不可放在`hashCode()`中计算。</span><br><span class="line"></span><br><span class="line">      另外注意，对于放入`HashMap`的`value`对象，没有任何要求</span><br><span class="line"></span><br><span class="line">### 延伸阅读</span><br><span class="line"></span><br><span class="line">既然`HashMap`内部使用了数组，通过计算`key`的`hashCode()`直接定位`value`所在的索引，那么第一个问题来了：hashCode()返回的`int`范围高达±<span class="number">21</span>亿，先不考虑负数，`HashMap`内部使用的数组得有多大？</span><br><span class="line"></span><br><span class="line">实际上`HashMap`初始化时默认的数组大小只有<span class="number">16</span>，任何`key`，无论它的`hashCode()`有多大，都可以简单地通过：</span><br></pre></td></tr></table></figure></code></pre><p>int index = key.hashCode() &amp; 0xf; // 0xf = 15</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">把索引确定在<span class="number">0</span>～<span class="number">15</span>，即永远不会超出数组范围，上述算法只是一种最简单的实现。</span><br><span class="line"></span><br><span class="line">第二个问题：如果添加超过<span class="number">16</span>个`key-value`到`HashMap`，数组不够用了怎么办？</span><br><span class="line"></span><br><span class="line">添加超过一定数量的`key-value`时，`HashMap`会在内部自动扩容，每次扩容一倍，即长度为<span class="number">16</span>的数组扩展为长度<span class="number">32</span>，相应地，需要重新确定`hashCode()`计算的索引位置。例如，对长度为<span class="number">32</span>的数组计算`hashCode()`对应的索引，计算方式要改为：</span><br></pre></td></tr></table></figure>
<p>int index = key.hashCode() &amp; 0x1f; // 0x1f = 31</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">由于扩容会导致重新分布已有的`key-value`，所以，频繁扩容对`HashMap`的性能影响很大。如果我们确定要使用一个容量为`10000`个`key-value`的`HashMap`，更好的方式是创建`HashMap`时就指定容量：</span><br></pre></td></tr></table></figure>
<p>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(10000);</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">虽然指定容量是`10000`，但`HashMap`内部的数组长度总是<span class="number">2</span>n，因此，实际数组长度被初始化为比`10000`大的`16384`（<span class="number">214</span>）。</span><br><span class="line"></span><br><span class="line">最后一个问题：如果不同的两个`key`，例如`"a<span class="string">"`和`"b"</span>`，它们的`hashCode()`恰好是相同的（这种情况是完全可能的，因为不相等的两个实例，只要求`hashCode()`尽量不相等），那么，当我们放入：</span><br></pre></td></tr></table></figure>
<p>map.put(“a”, new Person(“Xiao Ming”));<br>map.put(“b”, new Person(“Xiao Hong”));</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">时，由于计算出的数组索引相同，后面放入的`"Xiao Hong<span class="string">"`会不会把`"Xiao Ming"</span>`覆盖了？</span><br><span class="line"></span><br><span class="line">当然不会！使用`Map`的时候，只要`key`不相同，它们映射的`value`就互不干扰。但是，在`HashMap`内部，确实可能存在不同的`key`，映射到相同的`hashCode()`，即相同的数组索引上，肿么办？</span><br><span class="line"></span><br><span class="line">我们就假设`"a<span class="string">"`和`"b"</span>`这两个`key`最终计算出的索引都是<span class="number">5</span>，那么，在`HashMap`的数组中，实际存储的不是一个`Person`实例，而是一个`List`，它包含两个`Entry`，一个是`"a<span class="string">"`的映射，一个是`"b"</span>`的映射：</span><br><span class="line"></span><br><span class="line">```ascii</span><br><span class="line">  ┌───┐</span><br><span class="line"><span class="number">0</span> │   │</span><br><span class="line">  ├───┤</span><br><span class="line"><span class="number">1</span> │   │</span><br><span class="line">  ├───┤</span><br><span class="line"><span class="number">2</span> │   │</span><br><span class="line">  ├───┤</span><br><span class="line"><span class="number">3</span> │   │</span><br><span class="line">  ├───┤</span><br><span class="line"><span class="number">4</span> │   │</span><br><span class="line">  ├───┤</span><br><span class="line"><span class="number">5</span> │ ●─┼───&gt; List&lt;Entry&lt;String, Person&gt;&gt;</span><br><span class="line">  ├───┤</span><br><span class="line"><span class="number">6</span> │   │</span><br><span class="line">  ├───┤</span><br><span class="line"><span class="number">7</span> │   │</span><br><span class="line">  └───┘</span><br></pre></td></tr></table></figure>

<p>在查找的时候，例如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure>

<p>HashMap内部通过<code>&quot;a&quot;</code>找到的实际上是<code>List&gt;</code>，它还需要遍历这个<code>List</code>，并找到一个<code>Entry</code>，它的<code>key</code>字段是<code>&quot;a&quot;</code>，才能返回对应的<code>Person</code>实例。</p>
<p>我们把不同的<code>key</code>具有相同的<code>hashCode()</code>的情况称之为哈希冲突。在冲突的时候，一种最简单的解决办法是用<code>List</code>存储<code>hashCode()</code>相同的<code>key-value</code>。显然，如果冲突的概率越大，这个<code>List</code>就越长，<code>Map</code>的<code>get()</code>方法效率就越低，这就是为什么要尽量满足条件二：</p>
<p> 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。</p>
<p><code>hashCode()</code>方法编写得越好，<code>HashMap</code>工作的效率就越高。</p>
<ul>
<li><h4 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h4><ul>
<li><p>如果<code>Map</code>的key是<code>enum</code>类型，推荐使用<code>EnumMap</code>，既保证速度，也不浪费空间</p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        Map&lt;DayOfWeek, String&gt; map = <span class="keyword">new</span> EnumMap&lt;&gt;(DayOfWeek<span class="class">.<span class="keyword">class</span>)</span>;
        map.put(DayOfWeek.MONDAY, <span class="string">"星期一"</span>);
        map.put(DayOfWeek.TUESDAY, <span class="string">"星期二"</span>);
        map.put(DayOfWeek.WEDNESDAY, <span class="string">"星期三"</span>);
        map.put(DayOfWeek.THURSDAY, <span class="string">"星期四"</span>);
        map.put(DayOfWeek.FRIDAY, <span class="string">"星期五"</span>);
        map.put(DayOfWeek.SATURDAY, <span class="string">"星期六"</span>);
        map.put(DayOfWeek.SUNDAY, <span class="string">"星期日"</span>);
        System.out.println(map);
        System.out.println(map.get(DayOfWeek.MONDAY));
    }
}
&lt;!--￼<span class="number">28</span>--&gt;</code></pre>
</li>
<li><p>Key必须实现<code>Comparable</code>接口,TreeMap<code>不使用</code>equals()<code>和</code>hashCode()</p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        Map&lt;Student, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() {
            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student p1, Student p2)</span> </span>{
                <span class="keyword">if</span> (p1.score == p2.score) {
                    <span class="keyword">return</span> <span class="number">0</span>;
                }
                <span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;
            }
        });
        map.put(<span class="keyword">new</span> Student(<span class="string">"Tom"</span>, <span class="number">77</span>), <span class="number">1</span>);
        map.put(<span class="keyword">new</span> Student(<span class="string">"Bob"</span>, <span class="number">66</span>), <span class="number">2</span>);
        map.put(<span class="keyword">new</span> Student(<span class="string">"Lily"</span>, <span class="number">99</span>), <span class="number">3</span>);
        <span class="keyword">for</span> (Student key : map.keySet()) {
            System.out.println(key);
        }
        System.out.println(map.get(<span class="keyword">new</span> Student(<span class="string">"Bob"</span>, <span class="number">66</span>))); <span class="comment">// 重写方法，相等为0</span>
    }
}
&lt;!--￼<span class="number">29</span>--&gt;</code></pre>
</li>
<li><pre><code class="ascii">       ┌───┐
       │Set│
       └───┘
         ▲
    ┌────┴─────┐
    │          │
┌───────┐ ┌─────────┐
│HashSet│ │SortedSet│
└───────┘ └─────────┘
               ▲
               │
          ┌─────────┐
          │ TreeSet │
          └─────────┘
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - `HashSet`是无序的，因为它实现了`Set`接口，并没有实现`SortedSet`接口；</span><br><span class="line"></span><br><span class="line">  - `TreeSet`是有序的，因为它实现了`SortedSet`接口。</span><br><span class="line"></span><br><span class="line">    - 添加的元素必须正确实现`Comparable`接口，如果没有实现`Comparable`接口，那么创建`TreeSet`时必须传入一个`Comparator`对象。</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">#### IO流</span><br><span class="line"></span><br><span class="line">IO流是一种流式的数据输入/输出模型：</span><br><span class="line"></span><br><span class="line">- 二进制数据以`byte`为最小单位在`InputStream`/`OutputStream`中单向流动；</span><br><span class="line">- 字符数据以`char`为最小单位在`Reader`/`Writer`中单向流动。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**File**：Java标准库的`java.io.File`对象表示一个文件或者目录：</span><br><span class="line"></span><br><span class="line">- 创建`File`对象本身不涉及IO操作；</span><br><span class="line"></span><br><span class="line">- 可以获取路径／绝对路径／规范路径：`getPath()`/`getAbsolutePath()`/`getCanonicalPath()`；</span><br><span class="line"></span><br><span class="line">- 可以获取目录的文件和子目录：`list()`/`listFiles()`；</span><br><span class="line"></span><br><span class="line">- 可以创建或删除文件和目录。</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public class Main &#123;</span><br><span class="line">      public static void main(String[] args) throws IOException &#123;</span><br><span class="line">          File f = <span class="keyword">new</span> File(<span class="string">".."</span>)<span class="comment">;</span></span><br><span class="line">          System.out.println(f.getPath())<span class="comment">;</span></span><br><span class="line">          System.out.println(f.getAbsolutePath())<span class="comment">;</span></span><br><span class="line">          System.out.println(f.getCanonicalPath())<span class="comment">;</span></span><br><span class="line">          File file = <span class="keyword">new</span> File(<span class="string">"/path/to/file"</span>)<span class="comment">;</span></span><br><span class="line">          #-----------------------------------------</span><br><span class="line">          if (file.createNewFile()) &#123;</span><br><span class="line"><span class="title">              // 文件创建成功:</span></span><br><span class="line"><span class="title">              // TODO:</span></span><br><span class="line">              if (file.delete()) &#123;</span><br><span class="line"><span class="title">                  // 删除文件成功:</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>inputsteam</strong>: 是一个抽象类，而不是接口，是所有输入流的超类（以字节为单位）</p>
<ul>
<li><p>面向抽象编程原则的应用：接受<code>InputStream</code>抽象类型，而不是具体的<code>FileInputStream</code>类型，从而使得代码可以处理<code>InputStream</code>的任意实现类</p>
</li>
<li><p>fileinputstream</p>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{
    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>)) {
        <span class="comment">// 定义1000个字节大小的缓冲区:</span>
        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];
        <span class="keyword">int</span> n;
        <span class="keyword">while</span> ((n = input.read(buffer)) != -<span class="number">1</span>) { <span class="comment">// 读取到缓冲区</span>
            System.out.println(<span class="string">"read "</span> + n + <span class="string">" bytes."</span>);
        }
    }
}
&lt;!--￼<span class="number">31</span>--&gt;
<span class="number">1</span>.利用Java <span class="number">7</span>引入的新的<span class="keyword">try</span>(resource)的语法，只需要编写<span class="keyword">try</span>语句，让编译器自动为我们关闭资源
<span class="number">2</span>.编译器只看<span class="keyword">try</span>(resource = ...)中的对象是否实现了java.lang.AutoCloseable接口，如果实现了，就自动加上<span class="keyword">finally</span>语句并调用close()方法。
<span class="number">3</span>.read方法是阻塞的（返回后才能继续）
&lt;!--￼<span class="number">32</span>--&gt;


</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>装饰模式</strong>：运行时动态的增加功能</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">                 ┌─────────────┐</span><br><span class="line">                 │ InputStream │</span><br><span class="line">                 └─────────────┘</span><br><span class="line">                       ▲ ▲</span><br><span class="line">┌────────────────────┐ │ │ ┌─────────────────┐</span><br><span class="line">│  FileInputStream   │─┤ └─│FilterInputStream│</span><br><span class="line">└────────────────────┘ │   └─────────────────┘</span><br><span class="line">┌────────────────────┐ │     ▲ ┌───────────────────┐</span><br><span class="line">│<span class="keyword">ByteArrayInputStream│─┤ </span>    ├─│<span class="keyword">BufferedInputStream│</span></span><br><span class="line"><span class="keyword">└────────────────────┘ </span>│     │ └───────────────────┘</span><br><span class="line">┌────────────────────┐ │     │ ┌───────────────────┐</span><br><span class="line">│ ServletInputStream │─┘     ├─│  DataInputStream  │</span><br><span class="line">└────────────────────┘       │ └───────────────────┘</span><br><span class="line">                             │ ┌───────────────────┐</span><br><span class="line">                             └─│CheckedInputStream │</span><br><span class="line">                               └───────────────────┘</span><br></pre></td></tr></table></figure>

<p>编写一个<code>CountInputStream</code>，它的作用是对输入的字节进行计数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="string">"hello, world!"</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">try</span> (CountInputStream input = <span class="keyword">new</span> CountInputStream(<span class="keyword">new</span> ByteArrayInputStream(data))) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Total read "</span> + input.getBytesRead() + <span class="string">" bytes"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CountInputStream(InputStream in) &#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBytesRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = in.read();</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = in.read(b, off, len);</span><br><span class="line">        <span class="keyword">this</span>.count += n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>classpath路径：</strong>避免不同环境下文件路径不一致的问题</p>
<p>调用<code>getResourceAsStream()</code>需要特别注意的一点是，如果资源文件不存在，它将返回<code>null</code>。因此，我们需要检查返回的<code>InputStream</code>是否为<code>null</code>，如果为<code>null</code>，表示资源文件在classpath中没有找到：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (InputStream input = get<span class="constructor">Class()</span>.get<span class="constructor">ResourceAsStream(<span class="string">"/default.properties"</span>)</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input != null) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Properties <span class="built_in">props</span> = <span class="built_in">new</span> Properties();</span><br><span class="line"><span class="built_in">props</span>.<span class="built_in">load</span>(inputStreamFromClassPath(<span class="string">"/default.properties"</span>));</span><br><span class="line"><span class="built_in">props</span>.<span class="built_in">load</span>(inputStreamFromFile(<span class="string">"./conf.properties"</span>));</span><br></pre></td></tr></table></figure>

<p>这样读取配置文件，应用程序启动就更加灵活</p>
<p><strong>序列化</strong></p>
<p><strong>Reader</strong></p>
<table>
<thead>
<tr>
<th align="left">InputStream</th>
<th align="left">Reader</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字节流，以<code>byte</code>为单位</td>
<td align="left">字符流，以<code>char</code>为单位</td>
</tr>
<tr>
<td align="left">读取字节（-1，0~255）：<code>int read()</code></td>
<td align="left">读取字符（-1，0~65535）：<code>int read()</code></td>
</tr>
<tr>
<td align="left">读到字节数组：<code>int read(byte[] b)</code></td>
<td align="left">读到字符数组：<code>int read(char[] c)</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"src/readme.txt"</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"read "</span> + n + <span class="string">" chars."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Reader</code>是基于<code>InputStream</code>构造的：可以通过<code>InputStreamReader</code>在指定编码的同时将任何<code>InputStream</code>转换为<code>Reader</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 持有InputStream:</span></span><br><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>);</span><br><span class="line"><span class="comment">// 变换为Reader:</span></span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(input, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>



<p><strong>write</strong></p>
<table>
<thead>
<tr>
<th align="left">OutputStream</th>
<th align="left">Writer</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字节流，以<code>byte</code>为单位</td>
<td align="left">字符流，以<code>char</code>为单位</td>
</tr>
<tr>
<td align="left">写入字节（0~255）：<code>void write(int b)</code></td>
<td align="left">写入字符（0~65535）：<code>void write(int c)</code></td>
</tr>
<tr>
<td align="left">写入字节数组：<code>void write(byte[] b)</code></td>
<td align="left">写入字符数组：<code>void write(char[] c)</code></td>
</tr>
<tr>
<td align="left">无对应方法</td>
<td align="left">写入String：<code>void write(String s)</code></td>
</tr>
</tbody></table>
<h3 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h3><p><code>FileWriter</code>就是向文件中写入字符流的<code>Writer</code>。它的使用方法和<code>FileReader</code>类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"readme.txt"</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(<span class="string">'H'</span>); <span class="comment">// 写入单个字符</span></span><br><span class="line">    writer.write(<span class="string">"Hello"</span>.toCharArray()); <span class="comment">// 写入char[]</span></span><br><span class="line">    writer.write(<span class="string">"Hello"</span>); <span class="comment">// 写入String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Writer</code>是基于<code>OutputStream</code>构造的，可以通过<code>OutputStreamWriter</code>将<code>OutputStream</code>转换为<code>Writer</code>，转换时需要指定编码</p>
<p><code>PrintStream</code>是一种能接收各种数据类型的输出，打印数据时比较方便：</p>
<ul>
<li><code>System.out</code>是标准输出；</li>
<li><code>System.err</code>是标准错误输出。</li>
</ul>
<p><code>PrintWriter</code>是基于<code>Writer</code>的输出</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="ck9li3zwc0002t0va6n1f805a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-剑指offer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/%E5%89%91%E6%8C%87offer/" class="article-date">
  <time datetime="2020-03-26T05:28:02.065Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/%E5%89%91%E6%8C%87offer/">剑指offer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>-回溯法<br>                 if(judge(matrix,i,j,rows,cols,flag,str,0)){<br>                     return true;<br>                 }<br>            }<br>        }<br>        return false;<br>    }</p>
<pre><code>//judge(初始矩阵，索引行坐标i，索引纵坐标j，矩阵行数，矩阵列数，待判断的字符串，字符串索引初始为0即先判断字符串的第一位)
private boolean judge(char[] matrix,int i,int j,int rows,int cols,boolean[] flag,char[] str,int k){
    //先根据i和j计算匹配的第一个元素转为一维数组的位置
    int index = i*cols+j;
    //递归终止条件
    if(i&lt;0 || j&lt;0 || i&gt;=rows || j&gt;=cols || matrix[index] != str[k] || flag[index] == true)
        return false;
    //若k已经到达str末尾了，说明之前的都已经匹配成功了，直接返回true即可
    if(k == str.length-1)
        return true;
    //要走的第一个位置置为true，表示已经走过了
    flag[index] = true;

    //回溯，递归寻找，每次找到了就给k加一，找不到，还原
    if(judge(matrix,i-1,j,rows,cols,flag,str,k+1) ||
       judge(matrix,i+1,j,rows,cols,flag,str,k+1) ||
       judge(matrix,i,j-1,rows,cols,flag,str,k+1) ||
       judge(matrix,i,j+1,rows,cols,flag,str,k+1)  )
    {
        return true;
    }
    //走到这，说明这一条路不通，还原，再试其他的路径
    flag[index] = false;
    return false;
}</code></pre><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 机器人的运动范围</span><br></pre></td></tr></table></figure>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 同样是回溯法</span><br><span class="line"></span><br><span class="line">  - 访问位</span><br><span class="line">  - 边界条件：越界  ， 不满足题意  ， 访问过</span><br><span class="line">  - 回溯前后左右格子数目</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">   public <span class="keyword">int</span> movingCount(<span class="keyword">int</span> threshold, <span class="keyword">int</span> <span class="built_in">rows</span>, <span class="keyword">int</span> <span class="built_in">cols</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> flag[][] = new <span class="keyword">int</span>[<span class="built_in">rows</span>][<span class="built_in">cols</span>]; <span class="comment">//记录是否已经走过</span></span><br><span class="line">          <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">rows</span>, <span class="built_in">cols</span>, flag, threshold);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      private <span class="keyword">int</span> helper(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> <span class="built_in">rows</span>, <span class="keyword">int</span> <span class="built_in">cols</span>, <span class="keyword">int</span>[][] flag, <span class="keyword">int</span> threshold) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= <span class="built_in">rows</span> || j &lt; <span class="number">0</span> || j &gt;= <span class="built_in">cols</span> || numSum(i) + numSum(j)  &gt; threshold || flag[i][j] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          flag[i][j] = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">return</span> helper(i - <span class="number">1</span>, j, <span class="built_in">rows</span>, <span class="built_in">cols</span>, flag, threshold)</span><br><span class="line">                  + helper(i + <span class="number">1</span>, j, <span class="built_in">rows</span>, <span class="built_in">cols</span>, flag, threshold)</span><br><span class="line">                  + helper(i, j - <span class="number">1</span>, <span class="built_in">rows</span>, <span class="built_in">cols</span>, flag, threshold)</span><br><span class="line">                  + helper(i, j + <span class="number">1</span>, <span class="built_in">rows</span>, <span class="built_in">cols</span>, flag, threshold)</span><br><span class="line">                  + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  	<span class="comment">// 数字位数相加</span></span><br><span class="line">      private <span class="keyword">int</span> numSum(<span class="keyword">int</span> i) &#123;</span><br><span class="line">          <span class="keyword">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="built_in">sum</span> += i%<span class="number">10</span>;</span><br><span class="line">              i = i/<span class="number">10</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;<span class="number">1</span>并且m&gt;<span class="number">1</span>），每段绳子的长度记为k[<span class="number">0</span>],k[<span class="number">1</span>],...,k[m]。请问k[<span class="number">0</span>]xk[<span class="number">1</span>]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是<span class="number">8</span>时，我们把它剪成长度分别为<span class="number">2</span>、<span class="number">3</span>、<span class="number">3</span>的三段，此时得到的最大乘积是<span class="number">18</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">动态规划求解问题的四个特征： </span><br><span class="line">①求一个问题的最优解； </span><br><span class="line">②整体的问题的最优解是依赖于各个子问题的最优解； </span><br><span class="line">③小问题之间还有相互重叠的更小的子问题； </span><br><span class="line">④从上往下分析问题，从下往上求解问题；</span><br></pre></td></tr></table></figure>

<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// n&lt;=3的情况，m&gt;1必须要分段，例如：3必须分成1、2；1、1、1 ，n=3最大分段乘积是2,</span></span><br><span class="line">    	<span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        下面3行是n&gt;=4的情况，跟n&lt;=3不同，4可以分很多段，比如分成1、3，</span></span><br><span class="line"><span class="comment">        这里的3可以不需要再分了，因为3分段最大才2，不分就是3。记录最大的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;<span class="comment">//记录最大的</span></span><br><span class="line">    	<span class="comment">//j&lt;=i/2是因为1*3和3*1是一样的，没必要计算在内，只要计算到1*3和2*2就好了。然后就是取最大，1*3最大是3,2*2最大是4，那么dp[4]=res就是4。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=i/<span class="number">2</span> ; j++) &#123; <span class="comment">//  i/2 只需算一半</span></span><br><span class="line">                res=Math.max(res,dp[j]*dp[i-j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]=res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>贪婪法</p>
<ul>
<li>每次争取剪长度为三  </li>
<li>2 * 2&gt;3 * 1</li>
</ul>
</li>
<li><pre><code class="java">
<span class="comment">// 不断的切分3</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{
        <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>){
            <span class="keyword">return</span> <span class="number">1</span>;
        }
        <span class="keyword">if</span>(n==<span class="number">3</span>){
            <span class="keyword">return</span> <span class="number">2</span>;
        }
        <span class="keyword">int</span> sum = <span class="number">1</span>;
        <span class="keyword">while</span>(n&gt;<span class="number">4</span>){
            sum*=<span class="number">3</span>;
            n-=<span class="number">3</span>;
        }
        <span class="keyword">return</span> sum*n;

    }
&lt;!--￼<span class="number">5</span>--&gt;


</code></pre>
</li>
</ul>
<hr>
<h4 id="二进制中1的位数"><a href="#二进制中1的位数" class="headerlink" title="二进制中1的位数"></a>二进制中1的位数</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个整数，输出该数二进制表示中<span class="number">1</span>的个数。其中负数用补码表示。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>普通做法:按位依次与1，循环左移1，比较次数为32（int）</p>
</li>
<li><p>根据 与运算 定义，设二进制数字 nn ，则有：<br>若 n &amp; 1 = 0n&amp;1=0 ，则 nn 二进制 最右一位 为 00 ；<br>若 n &amp; 1 = 1n&amp;1=1 ，则 nn 二进制 最右一位 为 11 。</p>
</li>
</ul>
<ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{
        <span class="keyword">int</span> count = <span class="number">0</span>;
        <span class="keyword">int</span> flag = <span class="number">1</span>;
        <span class="keyword">while</span>(flag!=<span class="number">0</span>){
            <span class="keyword">if</span>((n&amp;flag)!=<span class="number">0</span>){
                count++;
            }
            flag = flag&lt;&lt;<span class="number">1</span>;
        }
        <span class="keyword">return</span> count;
    }
&lt;!--￼<span class="number">7</span>--&gt;


</code></pre>
</li>
</ul>
<hr>
<h4 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个<span class="keyword">double</span>类型的浮点数<span class="keyword">base</span>和<span class="keyword">int</span>类型的整数exponent。求<span class="keyword">base</span>的exponent次方。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该题看起来比较简单，但是需要考虑多种情况</p>
<ul>
<li>指数是不是为0 或者 负数</li>
<li>基数为0</li>
<li>快速幂的方法</li>
</ul>
<p>普通方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> base == <span class="number">0</span>: <span class="comment">#base为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> exponent == <span class="number">0</span>: <span class="comment">#指数为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> exponent &lt; <span class="number">0</span>: <span class="comment">#指数为负数</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(-exponent):</span><br><span class="line">                result = result * base</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/result</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(exponent):</span><br><span class="line">            result = result * base</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>快速幂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">       <span class="keyword">int</span> exp = Math.abs(n);</span><br><span class="line">       <span class="keyword">while</span>(exp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>((exp&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">               res*=x;</span><br><span class="line">           &#125;</span><br><span class="line">           x*=x;</span><br><span class="line">           exp = exp&gt;&gt;<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> n&gt;<span class="number">0</span>?res:<span class="number">1.0</span>/res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 递归法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> n=Math.abs(exponent);</span><br><span class="line">          <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">              <span class="keyword">return</span> base;</span><br><span class="line">          <span class="keyword">double</span>  result=Power(base,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">          result*=result;</span><br><span class="line">          <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">              result*=base;</span><br><span class="line">          <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">              result=<span class="number">1</span>/result;</span><br><span class="line">          <span class="keyword">return</span> result;            </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<hr>
<h4 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h4><hr>
<h4 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目一：在O（<span class="number">1</span>）时间内删除链表节点</span><br></pre></td></tr></table></figure>

<ul>
<li>平常的删除节点是需要找到要删除的上一个节点，更改指针，删除需要删除的节点，O(N)</li>
<li>该题时间为O（1）<ul>
<li>我们考虑，该节点的下一个节点容易找到，将next节点的值赋值给该节点，删除next节点，更改指针</li>
</ul>
</li>
<li>边界问题<ul>
<li>delete节点位于中间</li>
<li>delete节点位于头尾节点:普通方法</li>
<li>链表只有一个节点</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">       ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       dummy.next = head;</span><br><span class="line">       ListNode cur = dummy;</span><br><span class="line">       <span class="keyword">while</span> (cur.next!=<span class="keyword">null</span>)&#123;  <span class="comment">// 取下一个值，判断next是否为空</span></span><br><span class="line">           <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">               ListNode del = cur.next;</span><br><span class="line">               cur.next = del.next;</span><br><span class="line">               del.next = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目二：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span> 处理后为 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>由于是排序链表，重复节点必相邻</li>
<li>pre，next指针 pre指针指向确定的节点，next指针相当于工作节点，一直指向不为重复的值</li>
<li>增加头节点，为了防止头节点就是重复节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pHead==<span class="keyword">null</span> || pHead.next==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> pHead;&#125;</span><br><span class="line">ListNode Head = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//创建新的头节点</span></span><br><span class="line">Head.next = pHead;</span><br><span class="line">ListNode pre  = Head;</span><br><span class="line">ListNode last = Head.next;</span><br><span class="line"><span class="keyword">while</span> (last!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(last.next!=<span class="keyword">null</span> &amp;&amp; last.val == last.next.val)&#123;</span><br><span class="line">        <span class="comment">// 找到最后的一个相同节点</span></span><br><span class="line">        <span class="keyword">while</span> (last.next!=<span class="keyword">null</span> &amp;&amp; last.val == last.next.val)&#123;</span><br><span class="line">            last = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = last.next;</span><br><span class="line">        last = last.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        last = last.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Head.next;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="调整数组的顺序使奇数位于偶数的前面"><a href="#调整数组的顺序使奇数位于偶数的前面" class="headerlink" title="调整数组的顺序使奇数位于偶数的前面"></a>调整数组的顺序使奇数位于偶数的前面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变</span><br></pre></td></tr></table></figure>

<ul>
<li>比较简单，类似快排中的partition</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j&amp;&amp;(nums[i]%<span class="number">2</span>)!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j&amp;&amp;(nums[j]%<span class="number">2</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="链表环的入口"><a href="#链表环的入口" class="headerlink" title="链表环的入口"></a>链表环的入口</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出<span class="literal">null</span>。</span><br></pre></td></tr></table></figure>

<ul>
<li>判断是否有环：快慢指针，一个跑两格，一个跑一格，相遇则为有环</li>
<li>找出入口节点：快指针回到头节点，两个一起跑相遇为入口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="comment">// 单节点或者无节点返回错误</span></span><br><span class="line">        <span class="keyword">if</span>(pHead ==<span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义快慢指针</span></span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; slow !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;  <span class="comment">//相遇，链表有环</span></span><br><span class="line">                fast = pHead;  <span class="comment">//快指针回头节点</span></span><br><span class="line">                <span class="keyword">while</span>(fast != slow)&#123;  <span class="comment">//两个一起走</span></span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span>(fast == slow)&#123;  <span class="comment">//再次相遇为环的入口节点</span></span><br><span class="line">                    <span class="keyword">return</span> slow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个链表，反转链表后，输出新链表的表头</span><br></pre></td></tr></table></figure>

<ul>
<li>传统的递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode node = ReverseList(head.next);</span><br><span class="line">                head.next.next = head;</span><br><span class="line">                head.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>三指针 ，断链的话需要保存后一个节点，当前节点指向前一个节点</li>
<li><img src="C:%5CUsers%5C%E5%8D%97%E5%A4%A7%E5%AE%8B%E4%BB%B2%E5%9F%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200227175142167.png" alt="image-20200227175142167"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则</span><br></pre></td></tr></table></figure>

<ul>
<li><p>增加头节点</p>
</li>
<li><pre><code class="java"> <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{
        ListNode head0 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);
        ListNode cur = head0;
        ListNode a = l1;
        ListNode b = l2;
        <span class="keyword">while</span> (a!=<span class="keyword">null</span>&amp;&amp;b!=<span class="keyword">null</span>){
            <span class="keyword">if</span> (a.val&lt;=b.val){
                cur.next = a;
                cur = a;
                a = a.next;
            }<span class="keyword">else</span> {
                cur.next = b;
                cur = b;
                b = b.next;
            }
        }
        <span class="keyword">if</span>(a==<span class="keyword">null</span>){
            cur.next = b;
        }
        <span class="keyword">if</span>(b==<span class="keyword">null</span>){
            cur.next = a;
        }
        <span class="keyword">return</span> head0.next;
    }
&lt;!--￼<span class="number">24</span>--&gt;</code></pre>
</li>
<li><p>非递归实现：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        head = ListNode(<span class="number">0</span>)  //额外头节点</span><br><span class="line">        tmp = head</span><br><span class="line">        <span class="keyword">while</span> pHead1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> pHead2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> pHead1.val &lt;= pHead2.val:</span><br><span class="line">                tmp.next = pHead1</span><br><span class="line">                pHead1 = pHead1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp.next = pHead2</span><br><span class="line">                pHead2 = pHead2.next</span><br><span class="line">            tmp = tmp.next  //这里需要注意</span><br><span class="line">        <span class="keyword">if</span> pHead1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            tmp.next = pHead2</span><br><span class="line">        <span class="keyword">elif</span> pHead2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            tmp.next = pHead1</span><br><span class="line">        <span class="keyword">return</span> head.next   //返回为额外头节点的下一个</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入两棵二叉树<span class="keyword">A</span>，B，判断B是不是<span class="keyword">A</span>的子结构。（ps：我们约定空树不是任意一个树的子结构）</span><br></pre></td></tr></table></figure>

<ul>
<li>首先在A中找B的根节点</li>
<li>找到后判断其子树</li>
<li>注意的是：与二叉树相关有大量的指针操作，判断是否为空</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span>||B ==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(A.val == B.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> isSub(A,B);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSubStructure(A.left, B)||isSubStructure(A.right, B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSub</span><span class="params">(TreeNode x,TreeNode y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="keyword">null</span>)&#123; <span class="comment">//  y搜索完了 未找到匹配项</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123; <span class="comment">// x 搜索完了 出错</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x.val!=y.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSub(x.left,y.left)&amp;&amp;isSub(x.right,y.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="树的镜像"><a href="#树的镜像" class="headerlink" title="树的镜像"></a>树的镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作给定的二叉树，将其变换为源二叉树的镜像。</span><br></pre></td></tr></table></figure>

<ul>
<li>交换根节点的左右子节点</li>
<li>递归子树</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>||(root.left == <span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        mirrorTree(root.left);</span><br><span class="line">        mirrorTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非递归，自定义栈实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 空树</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右均为空</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用来遍历的栈</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line"> </span><br><span class="line">    stack.push(root);</span><br><span class="line"> </span><br><span class="line">    TreeNode curNode;</span><br><span class="line">    TreeNode tempNode;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 深度优先</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      curNode = stack.pop();</span><br><span class="line">      <span class="keyword">if</span>(curNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(curNode.left == <span class="keyword">null</span> &amp;&amp; curNode.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 交换</span></span><br><span class="line">      tempNode = curNode.left;</span><br><span class="line">      curNode.left = curNode.right;</span><br><span class="line">      curNode.right = tempNode;</span><br><span class="line">      stack.push(curNode.left);</span><br><span class="line">      stack.push(curNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</span><br></pre></td></tr></table></figure>

<ul>
<li>比较左右子树的值，递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSym(pRoot.left,pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSym</span><span class="params">(TreeNode left,TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSym(left.left,right.right)&amp;&amp; isSym(left.right,right.left);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下<span class="number">4</span> X <span class="number">4</span>矩阵： <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> 则依次打印出数字<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">10.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> down = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 最上面一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=left;col&lt;=right;col++)&#123;</span><br><span class="line">                list.add(matrix[up][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向下逼近</span></span><br><span class="line">            up++;</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(up &gt; down)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最右边一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=up;row&lt;=down;row++)&#123;</span><br><span class="line">                list.add(matrix[row][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向左逼近</span></span><br><span class="line">            right--;</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最下面一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=right;col&gt;=left;col--)&#123;</span><br><span class="line">                list.add(matrix[down][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向上逼近</span></span><br><span class="line">            down--;</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(up &gt; down)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最左边一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row=down;row&gt;=up;row--)&#123;</span><br><span class="line">                list.add(matrix[row][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向右逼近</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="包含min函数的最小栈"><a href="#包含min函数的最小栈" class="headerlink" title="包含min函数的最小栈"></a>包含min函数的最小栈</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的<span class="variable">min</span>函数（时间复杂度应为<span class="variable">O</span>（<span class="number">1</span>））。</span><br><span class="line">注意：保证测试中不会当栈为空的时候，对栈调用<span class="function"><span class="title">pop</span>()或者<span class="title"><span class="built_in">min</span></span>()或者<span class="title">top</span>()方法。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>维护一个辅助栈，栈容量与原始栈相同：每次加元素，辅助栈始终添加最小值到栈顶，出栈一起出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty() || node &lt; stack2.peek())&#123;</span><br><span class="line">            stack2.push(node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack2.push(stack2.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1.pop();</span><br><span class="line">        stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>每次遇到最小的元素在压辅助栈</p>
</li>
<li><pre><code class="java">Stack&lt;Integer&gt; A, B;
    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>{
        A = <span class="keyword">new</span> Stack&lt;&gt;();
        B = <span class="keyword">new</span> Stack&lt;&gt;();
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
        A.add(x);
        <span class="keyword">if</span>(B.empty() || B.peek() &gt;= x)
            B.add(x);
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{
        <span class="keyword">if</span>(A.pop().equals(B.peek()))
            B.pop();
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> A.peek();
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> B.peek();
    }

&lt;!--￼<span class="number">37</span>--&gt;
输入两组整数序列，判断是否为压栈和弹出序列
&lt;!--￼<span class="number">38</span>--&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a>从上到下打印二叉树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从上往下打印出二叉树的每个节点，同层节点从左至右打印  （层次遍历）</span><br></pre></td></tr></table></figure>

<ul>
<li>利用队列，每次取出顶端元素打印</li>
<li>每次打印一个节点得时候，如果有子节点，则把子节点放入队列末尾，头部取出打印</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.add(root);</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">           TreeNode node = queue.poll();</span><br><span class="line">           res.add(node.val);</span><br><span class="line">           <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.add(node.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.add(node.right);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (Integer n :</span><br><span class="line">               res) &#123;</span><br><span class="line">           r[index++] = n;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        treeNodeTmp = [root]</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">while</span> treeNodeTmp:</span><br><span class="line">            tmpNode = treeNodeTmp[<span class="number">0</span>]</span><br><span class="line">            ret.append(tmpNode.val)</span><br><span class="line">            <span class="keyword">if</span> tmpNode.left:</span><br><span class="line">                treeNodeTmp.append(tmpNode.left)</span><br><span class="line">            <span class="keyword">if</span> tmpNode.right:</span><br><span class="line">                treeNodeTmp.append(tmpNode.right)</span><br><span class="line">            <span class="keyword">del</span> treeNodeTmp[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="多行打印二叉树"><a href="#多行打印二叉树" class="headerlink" title="多行打印二叉树"></a>多行打印二叉树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行</span><br></pre></td></tr></table></figure>

<ul>
<li>因为每层都是独立的，所以建立两个栈，一层节点的子节点全部放入一个栈交替进行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 注意这里每次循环size()，发生变化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self,pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nodeStack = [pRoot]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> nodeStack:</span><br><span class="line">            res = []</span><br><span class="line">            nextStack = [] <span class="comment"># 辅助栈存放下一层结点</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nodeStack:</span><br><span class="line">                res.append(i.val)</span><br><span class="line">                <span class="keyword">if</span> i.left:</span><br><span class="line">                    nextStack.append(i.left)</span><br><span class="line">                <span class="keyword">if</span> i.right:</span><br><span class="line">                    nextStack.append(i.right)</span><br><span class="line">            nodeStack = nextStack <span class="comment">#辅助栈存为主栈</span></span><br><span class="line">            result.append(res) <span class="comment">#添加该层结点</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="按之字形打印二叉树"><a href="#按之字形打印二叉树" class="headerlink" title="按之字形打印二叉树"></a>按之字形打印二叉树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</span><br></pre></td></tr></table></figure>

<ul>
<li>奇数反转</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">           List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">               TreeNode node = queue.poll();</span><br><span class="line">               tmp.add(node.val);</span><br><span class="line">               <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">               <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">1</span>) Collections.reverse(tmp);</span><br><span class="line">           res.add(tmp);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两个栈：一个奇数栈 一个偶数栈</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        <span class="keyword">int</span> layer = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//s1存奇数层节点</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s1 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        s1.push(pRoot);</span><br><span class="line">        <span class="comment">//s2存偶数层节点</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s2 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">         </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> (!s1.empty() || !s2.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layer%<span class="number">2</span> != <span class="number">0</span>) &#123;   <span class="comment">//  n &amp; 1 == 0，则n为偶数</span></span><br><span class="line">                ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">while</span> (!s1.empty()) &#123;</span><br><span class="line">                    TreeNode node = s1.pop();</span><br><span class="line">                    <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        temp.add(node.val);</span><br><span class="line">                        System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">                        s2.push(node.left);</span><br><span class="line">                        s2.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!temp.isEmpty()) &#123;</span><br><span class="line">                    list.add(temp);</span><br><span class="line">                    layer++;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">while</span> (!s2.empty()) &#123;</span><br><span class="line">                    TreeNode node = s2.pop();</span><br><span class="line">                    <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        temp.add(node.val);</span><br><span class="line">                        System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">                        s1.push(node.right);</span><br><span class="line">                        s1.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!temp.isEmpty()) &#123;</span><br><span class="line">                    list.add(temp);</span><br><span class="line">                    layer++;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出<span class="keyword">Yes</span>,否则输出<span class="keyword">No</span>。假设输入的数组的任意两个数字都互不相同。</span><br></pre></td></tr></table></figure>

<ul>
<li>首先找到右子树开始的节点</li>
<li>然后对右子树节点依次进行判断</li>
<li>依次遍历左右子树</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = sequence.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> root = sequence[len-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i]&gt;root) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;len-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[j]&lt;root) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> left=<span class="keyword">true</span>,right=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>) left=VerifySquenceOfBST(Arrays.copyOfRange(sequence,<span class="number">0</span>,i));<span class="comment">//左闭右开</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len-<span class="number">1</span>)  right=VerifySquenceOfBST(Arrays.copyOfRange(sequence,i,len-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的<span class="built_in">list</span>中，数组长度大的数组靠前)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>DFS</p>
</li>
<li><pre><code class="java">LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();
    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;(); 
    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) {
        recur(root, sum);
        <span class="keyword">return</span> res;
    }
    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root, <span class="keyword">int</span> tar)</span> </span>{
        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;
        path.add(root.val);
        tar -= root.val;
        <span class="keyword">if</span>(tar == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)
            res.add(<span class="keyword">new</span> LinkedList(path));
        recur(root.left, tar);
        recur(root.right, tar);
        path.removeLast();
    }

&lt;!--￼<span class="number">51</span>--&gt;
</code></pre>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        self.sums = expectNumber</span><br><span class="line">        self.DFS(root, result, [root.val])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self, root, result, path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span> <span class="keyword">and</span> sum(path) == self.sums:</span><br><span class="line">            result.append(path)</span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">            self.DFS(root.left, result, path+[root.left.val])</span><br><span class="line">        <span class="keyword">if</span> root.right !=<span class="literal">None</span>:</span><br><span class="line">            self.DFS(root.right,result,path+[root.right.val])</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="将二叉树转化为双向循环链表"><a href="#将二叉树转化为双向循环链表" class="headerlink" title="将二叉树转化为双向循环链表"></a>将二叉树转化为双向循环链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Node pre,head,tail;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       inOrder(root.left);</span><br><span class="line">       root.left = pre;</span><br><span class="line">       <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">           head = root;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           pre.right = root;</span><br><span class="line">       &#125;</span><br><span class="line">       pre = root;</span><br><span class="line">       tail = root;</span><br><span class="line">       inOrder(root.right);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       inOrder(root);</span><br><span class="line">       tail.right = head;</span><br><span class="line">       head.left = tail;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h4><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的<span class="built_in">head</span>。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</span><br></pre></td></tr></table></figure>

<ul>
<li><p>投机取巧</p>
</li>
<li><pre><code class="java">mport java.util.HashMap;
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span>
<span class="function">    </span>{
        HashMap&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;RandomListNode, RandomListNode&gt;();
        RandomListNode cur = pHead;
        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {
            map.put(cur, <span class="keyword">new</span> RandomListNode(cur.label));
            cur = cur.next;
        }
        cur = pHead;
        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        <span class="keyword">return</span> map.get(pHead);
    }
}
&lt;!--￼<span class="number">55</span>--&gt;
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
&lt;!--￼<span class="number">56</span>--&gt;




</code></pre>
</li>
</ul>
<h4 id="数组中超过一半的数字"><a href="#数组中超过一半的数字" class="headerlink" title="数组中超过一半的数字"></a>数组中超过一半的数字</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为<span class="number">9</span>的数组&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>&#125;。由于数字<span class="number">2</span>在数组中出现了<span class="number">5</span>次，超过数组长度的一半，因此输出<span class="number">2</span>。如果不存在则输出<span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>排序取中间</p>
</li>
<li><p>hash表</p>
</li>
<li><p>patition（改变数组）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">if</span>(array.length&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">int</span> end  = length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = length&gt;&gt;<span class="number">1</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> index = Partition(array,start,end);</span><br><span class="line">        <span class="keyword">while</span>(index!=middle)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index&gt;middle)&#123;</span><br><span class="line">                index = Partition(array,start,index-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                index = Partition(array,index+<span class="number">1</span>,end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = array[middle];</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == result)</span><br><span class="line">                times++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(times*<span class="number">2</span>&lt;length)&#123;</span><br><span class="line">            System.out.println(times);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = (array[start]+array[end])/<span class="number">2</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">while</span>(array[end]&gt;flag)&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array,start,end);</span><br><span class="line">            <span class="keyword">while</span>(array[start]&lt;=flag)&#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp =array[num1];</span><br><span class="line">        array[num1] =array[num2];</span><br><span class="line">        array[num2] =temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>根据数组特点</p>
<ul>
<li>方法：我们在遍历数组的时候，保存两个值，一个是数组中的数字，另一个是次数，当遍历到下一个数字的时候，如果和上一次的数字一样则次数加1，如果不一样次数减一(相当于抵消了)，如果次数为0了，那就保存下一个数字，并把次数设置为1，因为我们要找的数字如果存在最后一定是把次数设置为1的那个数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers.empty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//[1,2,3,2,4,2,5,2,3]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;numbers.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">0</span>)&#123;</span><br><span class="line">            temp = numbers[i];</span><br><span class="line">            time = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp == numbers[i])&#123;</span><br><span class="line">            ++time;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            --time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 temp 是否符合要求</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp == numbers[i])&#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; numbers.<span class="built_in">size</span>()/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
</li>
</ul>
<h4 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入n个整数，找出其中最小的K个数。例如输入<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>这<span class="number">8</span>个数字，则最小的<span class="number">4</span>个数字是<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,</span><br></pre></td></tr></table></figure>

<ul>
<li>维护一个最大堆，每次加入元素判断是否小于根节点，最终输出整个最大堆</li>
<li>java中使用优先队列来实现堆，此时重写优先队列中的比较函数</li>
<li>该方法常用于海量数据的获取  topk问题   <strong>O（nlogk</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> len = input.length;</span><br><span class="line">       <span class="keyword">if</span>(k&gt;len||k==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list;</span><br><span class="line">       &#125;</span><br><span class="line">       PriorityQueue&lt;Integer&gt; maxheap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> o2-o1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(maxheap.size()!=k)&#123;  <span class="comment">//maxheap不为k时不断的放入元素</span></span><br><span class="line">               maxheap.offer(input[i]);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (maxheap.peek()&gt;input[i])&#123;  <span class="comment">//等于k时 判断堆顶元素</span></span><br><span class="line">               maxheap.poll();</span><br><span class="line">             </span><br><span class="line">               maxheap.offer(input[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(Integer n:maxheap)&#123; <span class="comment">//遍历取出</span></span><br><span class="line">           list.add(n);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于快速排序（会改变原数组值）</li>
<li>思想：patition使得第k个元素的左边比他下，右边比他大    <strong>O（N）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = partition(input,start,end);</span><br><span class="line">        <span class="keyword">while</span>(index!=k-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;k-<span class="number">1</span>)&#123;</span><br><span class="line">        	end = index - <span class="number">1</span>;</span><br><span class="line">        	index = partition(input,start,end);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">            index = partition(input,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//输出前k个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用<span class="function"><span class="title">Insert</span>()方法读取数据流，使用<span class="title">GetMedian</span>()方法获取当前读取数据的中位数</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>问题在于该数据流是一直变化的</p>
</li>
<li><p>数据流排好序的</p>
</li>
<li><p>采用最大堆+最小堆的方式   堆中插入数据效率为O（logn）得到堆顶元素为O（1）</p>
</li>
<li><p>因为要求的是中位数，那么这两个堆，<strong>大顶堆用来存较小的数，从大到小排列</strong>；</p>
<p><strong>小顶堆存较大的数，从小到大的顺序排序</strong>，显然中位数就是大顶堆的根节点与小顶堆的根节点和的平均数。</p>
</li>
<li><p>实现细节：为了公平，规定偶数插入大顶堆，奇数插入小顶堆。再把相应最大最小的数添加到彼此的堆中</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小顶堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//大顶堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="number">15</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//记录偶数个还是奇数个</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每次插入小顶堆的是当前大顶堆中最大的数</span></span><br><span class="line">    <span class="comment">//每次插入大顶堆的是当前小顶堆中最小的数</span></span><br><span class="line">    <span class="comment">//这样保证小顶堆中的数永远大于等于大顶堆中的数</span></span><br><span class="line">    <span class="comment">//中位数就可以方便地从两者的根结点中获取了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//个数为偶数的话，则先插入到大顶堆，然后将大顶堆中最大的数插入小顶堆中</span></span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">            <span class="keyword">int</span> max = maxHeap.poll();</span><br><span class="line">            minHeap.offer(max);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//个数为奇数的话，则先插入到小顶堆，然后将小顶堆中最小的数插入大顶堆中</span></span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">            <span class="keyword">int</span> min = minHeap.poll();</span><br><span class="line">            maxHeap.offer(min);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前为偶数个，则取小顶堆和大顶堆的堆顶元素求平均</span></span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek() + maxHeap.peek())/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前为奇数个，则直接从小顶堆中取元素即可</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如:&#123;<span class="number">6</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">7</span>,<span class="number">-15</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,连续子向量的最大和为<span class="number">8</span>(从第<span class="number">0</span>个开始,到第<span class="number">3</span>个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>动态规划三步走</li>
</ul>
<ol>
<li>确定dp[]数组含义：截止这个数字为止，连续子数组最大的值</li>
<li>状态转移方程：dp[i] = max(dp[i-1]+array[i],array[i]) <ul>
<li>前一个数字的最大和与该处数字比较，取最大值</li>
</ul>
</li>
<li>base case：好像没啥，注意结果定义为数组第一个值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i] = math.max(dp[i-<span class="number">1</span>]+array[i],array[i])</span><br><span class="line">              max = math.max(max,dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1–n整数中1出现的次数"><a href="#1–n整数中1出现的次数" class="headerlink" title="1–n整数中1出现的次数"></a>1–n整数中1出现的次数</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求出<span class="number">1</span>~<span class="number">13</span>的整数中<span class="number">1</span>出现的次数,并算出<span class="number">100</span>~<span class="number">1300</span>的整数中<span class="number">1</span>出现的次数？为此他特别数了一下<span class="number">1</span>~<span class="number">13</span>中包含<span class="number">1</span>的数字有<span class="number">1</span>、<span class="number">10</span>、<span class="number">11</span>、<span class="number">12</span>、<span class="number">13</span>因此共出现<span class="number">6</span>次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中<span class="number">1</span>出现的次数（从<span class="number">1</span> 到 n 中<span class="number">1</span>出现的次数）。</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个 m*n 的棋盘中的每一个格都放一个礼物，每个礼物都有一定的价值（价值大于<span class="number">0</span>）.你可以从棋盘的左上角开始拿各种里的礼物，并每次向左或者向下移动一格，直到到达棋盘的右下角。给定一个棋盘及上面个的礼物，请计算你最多能拿走多少价值的礼物？</span><br></pre></td></tr></table></figure>

<img src="C:\Users\南大宋仲基\AppData\Roaming\Typora\typora-user-images\image-20200303214920868.png" alt="image-20200303214920868" style="zoom:50%;" />

<ol>
<li><p>dp[]数组含义：该格子的最大价值</p>
</li>
<li><p>转移方程：f(i,j) = max(f(i-1,j), f(i,j-1)) + gift[i,j]；</p>
</li>
<li><p>base case：可以初始化第一行，第一列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxValue1</span><span class="params">(<span class="keyword">int</span>[][] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> rows = arr.length; <span class="comment">//行</span></span><br><span class="line">		<span class="keyword">int</span> cols = arr[<span class="number">0</span>].length; <span class="comment">//列</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span>[][] maxValue = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">					up = maxValue[i-<span class="number">1</span>][j];</span><br><span class="line">				<span class="keyword">if</span>(j&gt;<span class="number">0</span>)</span><br><span class="line">					left = maxValue[i][j-<span class="number">1</span>];</span><br><span class="line">			maxValue[i][j] = Math.max(up, left) + arr[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> maxValue[rows-<span class="number">1</span>][cols-<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ul>
<li><p>优化：二维数组转为一维数组</p>
</li>
<li><p>只保留相邻行</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxValue2</span><span class="params">(<span class="keyword">int</span>[][] arr)</span> </span>{
        <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length==<span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">0</span>;

        <span class="keyword">int</span> rows = arr.length;
        <span class="keyword">int</span> cols = arr[<span class="number">0</span>].length;
        <span class="keyword">int</span>[] maxValue = <span class="keyword">new</span> <span class="keyword">int</span>[cols];
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++) {
            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++) {
                <span class="keyword">int</span> left = <span class="number">0</span>;
                <span class="keyword">int</span> up = <span class="number">0</span>;
                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)
                    up = maxValue[j];
                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)
                    left = maxValue[j-<span class="number">1</span>];
                maxValue[j] = Math.max(up, left)+arr[i][j];
            }
        }
        <span class="keyword">return</span> maxValue[cols-<span class="number">1</span>];
    }
&lt;!--￼<span class="number">70</span>--&gt;
请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。例如，在字符串中”arabcacfr”，最长非重复子字符串为”acfr”，长度为<span class="number">4</span>。
&lt;!--￼<span class="number">71</span>--&gt;</code></pre>
</li>
<li><p><img src="https://pic4.zhimg.com/80/v2-ec6f1e5c8bd7902a4d6b2ffdf024e54f_1440w.jpg" alt="img"></p>
</li>
<li><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span>
        <span class="comment"># 保存每个字符上一次出现的位置索引</span>
        pos = {}
        l = <span class="number">0</span>
        maxlen = <span class="number">0</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):
            <span class="keyword">if</span> pos.get(s[i]) <span class="keyword">is</span> <span class="literal">None</span>:                
                l += <span class="number">1</span>                
            <span class="keyword">else</span>:
                maxlen = max(l, maxlen)
                d = i - pos[s[i]]
                l = d <span class="keyword">if</span> d&lt;=l <span class="keyword">else</span> l+<span class="number">1</span>
            pos[s[i]] = i       
        <span class="keyword">return</span> max(l, maxlen)
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 借用arraylist</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public static int lengthOfLongestSubstring(String str) &#123;</span><br><span class="line">  		if(str.length()==0)</span><br><span class="line">  			return 0;</span><br><span class="line">  		</span><br><span class="line">  		int maxLength=1;</span><br><span class="line">  		List&lt;Character&gt; list = new ArrayList&lt;Character&gt;();</span><br><span class="line">  		list.add(str.charAt(0));</span><br><span class="line">  		for(int i=1;i&lt;str.length();i++) &#123;</span><br><span class="line">  			if(list.contains(str.charAt(i))) &#123;</span><br><span class="line">  				//返回与当前字符相同字符的索引</span><br><span class="line">  				int index = list.indexOf(str.charAt(i)); </span><br><span class="line">  				list = list.subList(index+1, list.size());</span><br><span class="line">  				list.add(str.charAt(i));</span><br><span class="line">  				maxLength = Math.max(maxLength, list.size());</span><br><span class="line">  			&#125;else &#123;</span><br><span class="line">  				list.add(str.charAt(i));</span><br><span class="line">  				maxLength = Math.max(maxLength, list.size());</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		return maxLength;</span><br><span class="line">  	&#125;</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
<hr>
<h4 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在字符串中找出第一个只出现一次的字符</span><br></pre></td></tr></table></figure>

<ul>
<li><p>笨办法：从头开始遍历，比较每次元素在后续是否有相同 为O（n^2）</p>
</li>
<li><p>hash表：java hashmap忽略</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">findFirstNoRepeatChar</span><span class="params">(String str)</span></span>{
        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.trim().length()==<span class="number">0</span>){
            <span class="keyword">return</span> <span class="string">'0'</span>;
        }
        <span class="keyword">int</span> []counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];
        str = str.toLowerCase(); <span class="comment">//防止出现大小写混乱的情况</span>
        <span class="keyword">int</span> len = str.length();
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++){
            counts[str.charAt(i) - <span class="string">'a'</span>]++;
        }
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++){
            <span class="keyword">if</span>(counts[str.charAt(i) - <span class="string">'a'</span>] == <span class="number">1</span>){
                <span class="keyword">return</span> str.charAt(i);
            }
        }
        <span class="keyword">return</span> <span class="string">'0'</span>;
    }
&lt;!--￼<span class="number">74</span>--&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h4><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数<span class="keyword">P</span>。并将<span class="keyword">P</span>对<span class="number">1000000007</span>取模的结果输出。 即输出<span class="keyword">P</span>%<span class="number">1000000007</span></span><br></pre></td></tr></table></figure>

<ul>
<li>归并排序的思想 时间复杂度为O（nlogn）</li>
<li>外部排序，需要额外O（n）空间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 使用递归</span></span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end)<span class="keyword">return</span>; <span class="comment">//结束边界</span></span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">        MergeSort(array, start, mid);</span><br><span class="line">        MergeSort(array, mid+<span class="number">1</span>, end);</span><br><span class="line">        MergeOne(array, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MergeOne</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end-start+<span class="number">1</span>];  <span class="comment">//引入额外空间</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,i=start,j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;= end)&#123;</span><br><span class="line"><span class="comment">//如果前面的元素小于后面的不能构成逆序对</span></span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt;= array[j])</span><br><span class="line">                temp[k++] = array[i++];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果前面的元素大于后面的，那么在前面元素之后的元素都能和后面的元素构成逆序对</span></span><br><span class="line">                temp[k++] = array[j++];</span><br><span class="line">                cnt = (cnt + (mid-i+<span class="number">1</span>))%<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;= mid)</span><br><span class="line">            temp[k++] = array[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=end)</span><br><span class="line">            temp[k++] = array[j++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;k; l++)&#123;</span><br><span class="line">            array[start+l] = temp[l];  <span class="comment">//辅助数组存入原数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        MergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</span><br></pre></td></tr></table></figure>

<ol>
<li>可以使用两个栈，依次弹出元素直到元素不相同     时间复杂度为O(M+N)</li>
<li>长的链表先走k步，两个链表在从头走    时间复杂度为O(M+N)</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">     <span class="comment"># write code here</span></span><br><span class="line">     pTmp1 = pHead1</span><br><span class="line">     pTmp2 = pHead2</span><br><span class="line">     <span class="comment">#当链表1 和链表2 同时存在的时候</span></span><br><span class="line">     <span class="keyword">while</span> pTmp1 <span class="keyword">and</span> pTmp2:</span><br><span class="line">         <span class="comment">#当两个链表移动到值相同的时候，这个位置就是结点，直接返回pTmp1或pTmp2</span></span><br><span class="line">         <span class="keyword">if</span> pTmp1 == pTmp2:</span><br><span class="line">             <span class="keyword">return</span> pTmp1</span><br><span class="line">         <span class="comment">#移动指针的位置，两个同时移动，</span></span><br><span class="line">         pTmp1 = pTmp1.next</span><br><span class="line">         pTmp2 = pTmp2.next</span><br><span class="line"></span><br><span class="line">     <span class="comment">#第一个参数给比较短的那个链表的值</span></span><br><span class="line">     <span class="comment">#第二个参数给比较长的链表的值</span></span><br><span class="line">     <span class="comment">#第三个参数是比较短的那个链表头</span></span><br><span class="line">     <span class="comment">#第四个参数是比较长的那个链表头</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">findEqual</span><span class="params">(longPointer, shorPointer, longHead, shortHead)</span>:</span></span><br><span class="line">         k = <span class="number">0</span></span><br><span class="line">         <span class="comment"># 寻找出链表长度之间的差值，让长的链表继续走，直到链表走完为止，走了多少步，就说明，两个链表之间的差值是多少。</span></span><br><span class="line">         <span class="keyword">while</span> longPointer:</span><br><span class="line">             longPointer = longPointer.next</span><br><span class="line">             k += <span class="number">1</span></span><br><span class="line">         <span class="comment">#然后：</span></span><br><span class="line">         <span class="comment"># 先让长的那个去走k步</span></span><br><span class="line">         longPointer = longHead</span><br><span class="line">         shortPointer = shortHead</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">             longPointer = longPointer.next</span><br><span class="line">         <span class="comment">#长的走k步之后，再让两个链表一起移动，直到两个链表移动的位置的值相等为止，那么这个点就是 两个链表的第一个公共结点。</span></span><br><span class="line">         <span class="keyword">while</span> longPointer != shortPointer:</span><br><span class="line">             longPointer = longPointer.next</span><br><span class="line">             shortPointer = shortPointer.next</span><br><span class="line">         <span class="keyword">return</span> shortPointer</span><br><span class="line">     <span class="comment">#如果两个链表不一样的长度，那么假设是 第一个链表长度长，第二个链表已经走完了，结束了，那么第一个链表还没有走完，那么就调用我们封装好的函数，或者是看下面注释的代码。</span></span><br><span class="line">     <span class="keyword">if</span> pTmp1:</span><br><span class="line">         <span class="keyword">return</span> findEqual(pTmp1,pTmp2,pHead1,pHead2)</span><br><span class="line">     <span class="keyword">if</span> pTmp2:</span><br><span class="line">         <span class="keyword">return</span> findEqual(pTmp2, pTmp1, pHead2, pHead1)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="在排序数组中查找数字"><a href="#在排序数组中查找数字" class="headerlink" title="在排序数组中查找数字"></a>在排序数组中查找数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目一：统计一个数字在排序数组中出现的次数。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>hash法   O（n）</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>{
         Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();
        <span class="comment">//常用的map赋值</span>
        <span class="keyword">int</span> length = array.length;
        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;length;i++){
            <span class="keyword">if</span>(!map.containsKey(array[i])){
                map.put(array[i],<span class="number">1</span>);
            }<span class="keyword">else</span> {
                map.put(array[i],map.get(array[i])+<span class="number">1</span>);
            }
        }
        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {
            <span class="keyword">if</span>(entry.getKey()==k)
                <span class="keyword">return</span> entry.getValue();
        }
        <span class="keyword">return</span> <span class="number">0</span>;
    }
&lt;!--￼<span class="number">80</span>--&gt;
</code></pre>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目二：<span class="number">0</span>-n<span class="number">-1</span>中缺失的数字，数组排序</span><br></pre></td></tr></table></figure>

<ul>
<li><p>题目转化为排序数组中第一个与下标不一致的元素</p>
</li>
<li><p>二分法：</p>
<ul>
<li>当下标一样，说明该值左边排好序，找右边</li>
<li>不一样：<ul>
<li>如果前一个数字为一致元素，则该下标为查找值</li>
<li>如果前一个不为一致元素，则查找左半边</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMissNumber</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num.length() == <span class="number">0</span> || num == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = num.length();</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[mid]!=mid)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid == <span class="number">0</span>||num[mid-<span class="number">1</span>]==mid-<span class="number">1</span>)&#123;<span class="comment">//mid为0无左值</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == length)&#123;<span class="comment">//找到最右边</span></span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目三：找出单调递增数组中数值和下标相等的元素</span><br></pre></td></tr></table></figure>

<ul>
<li>二分</li>
<li>mid  &gt;  下标：后半边全部大于</li>
<li>mid  &lt;  下标：左半边全部小于</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumSameAsIndex</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = num.length();</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = num.length();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid == num[mid])&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid &gt; num[mid])&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a>二叉搜索树的第k大节点</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （<span class="number">5</span>，<span class="number">3</span>，<span class="number">7</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">6</span>，<span class="number">8</span>）    中，按结点数值大小顺序第三小结点的值为<span class="number">4</span>。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>二叉树的中序遍历为顺序</p>
</li>
<li><p>一个额外空间存放二叉树的中序遍历</p>
</li>
<li><pre><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span>
        <span class="comment"># write code here</span>
        res = []
        <span class="comment">#中序遍历</span>
        <span class="function"><span class="keyword">def</span> <span class="title">preOrder</span><span class="params">(pRoot)</span>:</span>
            <span class="keyword">if</span> pRoot == <span class="literal">None</span>:
                <span class="keyword">return</span> <span class="literal">None</span>
            preOrder(pRoot.left)
            res.append(pRoot)
            preOrder(pRoot.right)

        preOrder(pRoot)
        <span class="keyword">if</span> len(res)&lt;k <span class="keyword">or</span> k&lt;<span class="number">1</span>:
            <span class="keyword">return</span> <span class="literal">None</span>
        <span class="keyword">return</span> res[k<span class="number">-1</span>]
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 非递归中序</span><br><span class="line"></span><br><span class="line">- 把左节点依次压栈，弹出节点找右子树</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  TreeNode KthNode(TreeNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="keyword">null</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">          Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">          <span class="keyword">while</span> (root != <span class="keyword">null</span> || ! stack.isEmpty()) &#123;</span><br><span class="line">              <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  stack.<span class="keyword">push</span>(root);</span><br><span class="line">                  root = root.left;</span><br><span class="line">              &#125;</span><br><span class="line">              root = stack.<span class="keyword">pop</span>();</span><br><span class="line">              <span class="keyword">count</span> ++;</span><br><span class="line">              <span class="keyword">if</span>(<span class="keyword">count</span> == k) <span class="keyword">return</span> root;</span><br><span class="line">              root = root.right;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<hr>
<h4 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最大深度等于   max(left,right)+1</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>{
        <span class="keyword">if</span>(root==<span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="number">0</span>;
        }<span class="keyword">else</span> {
            <span class="keyword">int</span> left = TreeDepth(root.left);
            <span class="keyword">int</span> right = TreeDepth(root.right);
            <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;
        }
    }
&lt;!--￼<span class="number">88</span>--&gt;


</code></pre>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断是否平衡二叉树</span><br></pre></td></tr></table></figure>

<ul>
<li><p>普通方法存在大量重复</p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> classSolution {
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>{
        <span class="keyword">if</span>(root == <span class="keyword">null</span>) {
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="keyword">return</span> Math.abs(maxDepth(root.left) - maxDepth(root.right)) &lt;= <span class="number">1</span> &amp;&amp;
            IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>{
        <span class="keyword">if</span>(root == <span class="keyword">null</span>) {
            <span class="keyword">return</span> <span class="number">0</span>;
        }
        <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
}
&lt;!--￼<span class="number">90</span>--&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="数组中出现的数字"><a href="#数组中出现的数字" class="headerlink" title="数组中出现的数字"></a>数组中出现的数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目一：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字</span><br></pre></td></tr></table></figure>

<ul>
<li><p>无聊的hash法</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>{
        <span class="keyword">int</span> length = array.length;
        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();
        <span class="comment">//常用的map赋值</span>
        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;length;i++){
            <span class="keyword">if</span>(!map.containsKey(array[i])){
                map.put(array[i],<span class="number">1</span>);
            }<span class="keyword">else</span> {
                map.put(array[i],map.get(array[i])+<span class="number">1</span>);
            }
        }
        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];
        <span class="keyword">int</span> k =<span class="number">0</span>;
        <span class="comment">//取出map集合中的key value 注意方法map.entryset()</span>
        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {
            <span class="keyword">if</span>(entry.getValue() == <span class="number">1</span>){
                num[k] = entry.getKey();
                k++;
            }
        }
        num1[<span class="number">0</span>]=num[<span class="number">0</span>];
        num2[<span class="number">0</span>]=num[<span class="number">1</span>];
    }
&lt;!--￼<span class="number">92</span>--&gt;


</code></pre>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目二：一个整型数组里除了一个数字之外，其他的数字都出现了三次。请写程序找出这一个只出现一次的数字</span><br></pre></td></tr></table></figure>

<ol>
<li>计算数组中所有数字对应的二进制数各个位置的和，即就是计算数组中所有数字对应的二进制数各个位置出现1的次数</li>
<li>若某一位上的数不能被3整除，则证明目标数字的这一位肯定为1</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindNumberApperingOnce</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number.size() &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bitSum[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//数组长度固定为O（1）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> bitmask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;=<span class="number">0</span>; j--)<span class="comment">//从低位开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitmask&amp;number[i])bitSum[j]++;</span><br><span class="line">            bitmask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)<span class="comment">//0是高位</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = result &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        result += bitSum[i] % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="和为s的数字"><a href="#和为s的数字" class="headerlink" title="和为s的数字"></a>和为s的数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>排序数组  二分</p>
</li>
<li><pre><code class="java"> <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>{
         ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();
        <span class="keyword">if</span> (array == <span class="keyword">null</span> )
            <span class="keyword">return</span> list;
        <span class="keyword">int</span> left = <span class="number">0</span>;
        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;
        <span class="keyword">while</span> (left &lt; right) {
            <span class="keyword">int</span> s = array[left] + array[right];
            <span class="keyword">if</span> (s == sum) {
                list.add(array[left]);
                list.add(array[right]);
                <span class="keyword">return</span> list;
            }<span class="keyword">else</span> {
                <span class="keyword">if</span> (s &gt; sum) {
                    right--;
                }<span class="keyword">else</span> {
                    left++;
                }
            }
        }
        <span class="keyword">return</span> list;
    }
&lt;!--￼<span class="number">96</span>--&gt;
输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
&lt;!--￼<span class="number">97</span>--&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目一：反转单词顺序</span><br></pre></td></tr></table></figure>

<ol>
<li>反转句子所有单词</li>
<li>反转每个单词</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">char</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || start &lt; <span class="number">0</span> || end &gt; array.Length - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = array[start];</span><br><span class="line">            array[start] = array[end];</span><br><span class="line">            array[end] = temp;</span><br><span class="line"></span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> string <span class="title">ReverseSentense</span><span class="params">(string sentense)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (string.IsNullOrEmpty(sentense))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] array = sentense.ToCharArray();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.Length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step1.先翻转整个句子</span></span><br><span class="line">        Reverse(array, start, end);</span><br><span class="line">        <span class="comment">// Step2.再翻转句中的每个单词</span></span><br><span class="line">        start = end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; array.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[start] == <span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                start++;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (end == array.Length || array[end] == <span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Reverse(array, start, --end);</span><br><span class="line">                start = end + <span class="number">1</span>;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> string(array);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目二:汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列<span class="attribute">S</span>=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</span><br></pre></td></tr></table></figure>

<ul>
<li><p>三次反转</p>
<ul>
<li>1.反转前面n个字符</li>
<li>2.反转后面n个字符</li>
<li>3.反转所有</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> len = chars.length;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(chars,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">    reverse(chars,n,len-<span class="number">1</span>);</span><br><span class="line">    reverse(chars,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer(len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c:chars)&#123;</span><br><span class="line">        sb.append(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h4 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a>队列的最大值</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;及滑动窗口的大小<span class="number">3</span>，那么一共存在<span class="number">6</span>个滑动窗口，他们的最大值分别为&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">5</span>&#125;； 针对数组&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;的滑动窗口有以下<span class="number">6</span>个： &#123;[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;， &#123;<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>],<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;， &#123;<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>],<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;， &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,[<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>],<span class="number">5</span>,<span class="number">1</span>&#125;， &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,[<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>],<span class="number">1</span>&#125;， &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,[<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>]&#125;。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>蛮力法，从头到尾滑动窗口 时间复杂度O（Nk）</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span>{
        ArrayList&lt;Integer&gt; list  = <span class="keyword">new</span> ArrayList&lt;Integer&gt; ();
        <span class="keyword">if</span>(size&gt;num.length||size==<span class="number">0</span>)
            <span class="keyword">return</span> list;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=num.length-size;i++){
            <span class="keyword">int</span> max = num[i];
            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;i+size;j++){
                <span class="keyword">if</span>(num[j]&gt;max){
                    max = num[j];
                }
            }
            list.add(max);
        }
        <span class="keyword">return</span> list;
    }
&lt;!--￼<span class="number">104</span>--&gt;












</code></pre>
</li>
</ul>
<h4 id="圆圈中最后的数字（约瑟夫问题）"><a href="#圆圈中最后的数字（约瑟夫问题）" class="headerlink" title="圆圈中最后的数字（约瑟夫问题）"></a>圆圈中最后的数字（约瑟夫问题）</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为<span class="number">0</span>的小朋友开始报数。每次喊到m<span class="number">-1</span>的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续<span class="number">0.</span>..m<span class="number">-1</span>报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从<span class="number">0</span>到n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">如果没有小朋友，请返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法一：模仿整个过程</p>
</li>
<li><pre><code class="java"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{
    <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{
        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) {
            list.add(i);
        }
        <span class="keyword">int</span> bt = <span class="number">0</span>;
        <span class="keyword">while</span> (list.size() &gt; <span class="number">1</span>) {
            bt = (bt + m - <span class="number">1</span>) % list.size();<span class="comment">//类似循环队列</span>
            list.remove(bt);
        }
        <span class="keyword">return</span> list.size() == <span class="number">1</span> ? list.get(<span class="number">0</span>) : -<span class="number">1</span>;
    }
}
&lt;!--￼<span class="number">106</span>--&gt;
假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可获得的最大利润是多少？
&lt;!--￼<span class="number">107</span>--&gt;


</code></pre>
</li>
</ul>
<hr>
<h4 id="树的公共祖先"><a href="#树的公共祖先" class="headerlink" title="树的公共祖先"></a>树的公共祖先</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">树中两个结点的最低公共祖先。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法一：假设是二叉搜索树（二叉搜索树是一个排序的二叉树，左子树的结点小于根结点，右子树的结点大于根结点），故找到一个结点，使其大于左子结点小于右子结点即可。</p>
</li>
<li><pre><code>public static TreeNode getLastCommonNode(TreeNode pRoot, TreeNode pLeft, TreeNode pRight){
    TreeNode treeNode = null;
    if(pRoot == null || pLeft.val &gt; pRight.val){
        return null;
    }
    if(pRoot.val &gt;= pRight.val){
        treeNode = getLastCommonNode(pRoot.left, pLeft, pRight);
    }
    if(pRoot.val &lt;= pLeft.val){
        treeNode = getLastCommonNode(pRoot.right, pLeft, pRight);
    }
    if(pRoot.val &gt;= pLeft.val &amp;&amp; pRoot.val &lt;= pRight.val){
        return pRoot;
    }
    return treeNode;
}
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 方法二：假设是普通的树，但是每个子结点都有指向父结点的指针，这样的话类似与前面的链表找公共结点一样。</span><br><span class="line"></span><br><span class="line">- 方法三：假设就是一棵普通的树，子结点没有指向父结点的指针。</span><br><span class="line"></span><br><span class="line">  - 定义两个数组，存放根节点分别到目标节点的路径，问题转化为查找两个数组第一个出现的相同值</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public static TreeNode get<span class="constructor">LastCommonParent(TreeNode <span class="params">pRoot</span>, TreeNode <span class="params">p1</span>, TreeNode <span class="params">p2</span>)</span>&#123;</span><br><span class="line">  	<span class="comment">//保存p1的路径</span></span><br><span class="line">  	ArrayList&lt;TreeNode&gt; path1 = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;<span class="literal">()</span>;</span><br><span class="line">  	<span class="comment">//保存p2的路径</span></span><br><span class="line">  	ArrayList&lt;TreeNode&gt; path2 = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;<span class="literal">()</span>;</span><br><span class="line">  	ArrayList&lt;TreeNode&gt; tmpList = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;<span class="literal">()</span>;</span><br><span class="line">  	get<span class="constructor">NodePath(<span class="params">pRoot</span>, <span class="params">p1</span>, <span class="params">tmpList</span>, <span class="params">path1</span>)</span>;</span><br><span class="line">  	get<span class="constructor">NodePath(<span class="params">pRoot</span>, <span class="params">p2</span>, <span class="params">tmpList</span>, <span class="params">path2</span>)</span>;</span><br><span class="line">  	<span class="comment">//如果路径不存在，返回空</span></span><br><span class="line">  	<span class="keyword">if</span>(path1.size<span class="literal">()</span><span class="operator"> == </span><span class="number">0</span><span class="operator"> || </span>path2.size<span class="literal">()</span><span class="operator"> == </span><span class="number">0</span>)&#123;</span><br><span class="line">  		return null;</span><br><span class="line">  	&#125;</span><br><span class="line">  	return get<span class="constructor">LastCommonParent(<span class="params">path1</span>, <span class="params">path2</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//获取根节点到目标节点的路径</span></span><br><span class="line">  public static void get<span class="constructor">NodePath(TreeNode <span class="params">pRoot</span>, TreeNode <span class="params">pNode</span>, ArrayList&lt;TreeNode&gt; <span class="params">tmpList</span>, ArrayList&lt;TreeNode&gt; <span class="params">path</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(pRoot<span class="operator"> == </span>pNode<span class="operator"> || </span>pRoot<span class="operator"> == </span>null)&#123;</span><br><span class="line">  		return ;</span><br><span class="line">  	&#125;</span><br><span class="line">  	tmpList.add(pRoot);</span><br><span class="line">  	ArrayList&lt;TreeNode&gt; childs = pRoot.children;</span><br><span class="line">  	for(TreeNode node : childs)&#123;</span><br><span class="line">  		<span class="keyword">if</span>(node<span class="operator"> == </span>pNode)&#123;</span><br><span class="line">  			path.add<span class="constructor">All(<span class="params">tmpList</span>)</span>;</span><br><span class="line">  			break;</span><br><span class="line">  		&#125;</span><br><span class="line">  		get<span class="constructor">NodePath(<span class="params">node</span>, <span class="params">pNode</span>, <span class="params">tmpList</span>, <span class="params">path</span>)</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	tmpList.remove(tmpList.size<span class="literal">()</span>-<span class="number">1</span>); <span class="comment">//清空集合</span></span><br><span class="line">  &#125;</span><br><span class="line">  	</span><br><span class="line">  <span class="keyword">private</span> static TreeNode get<span class="constructor">LastCommonParent(ArrayList&lt;TreeNode&gt; <span class="params">path1</span>, ArrayList&lt;TreeNode&gt; <span class="params">path2</span>)</span> &#123;</span><br><span class="line">  	TreeNode tmpNode = null;</span><br><span class="line">  	for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; path1.size<span class="literal">()</span>; i++)&#123;</span><br><span class="line">  		<span class="keyword">if</span>(path1.get(i)!=path2.get(i))&#123;</span><br><span class="line">  			break;</span><br><span class="line">  		&#125;</span><br><span class="line">  	    <span class="comment">//循环结束时tmpNode即为最后一个共同结点</span></span><br><span class="line">  		tmpNode = path1.get(i);</span><br><span class="line">  	&#125;</span><br><span class="line">  	return tmpNode;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</code></pre></li>
</ul>
<p>####</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/%E5%89%91%E6%8C%87offer/" data-id="ck9li3zxa000kt0vah1hih92g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20/">设计模式 </a>
          </li>
        
          <li>
            <a href="/2020/04/29/%E7%BD%91%E7%BB%9C/">网络</a>
          </li>
        
          <li>
            <a href="/2020/04/29/linux/">linux</a>
          </li>
        
          <li>
            <a href="/2020/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91/">高并发</a>
          </li>
        
          <li>
            <a href="/2020/04/29/Mysql%E9%9D%A2%E8%AF%95/">Mysql面试</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 MRZ<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>
</html>